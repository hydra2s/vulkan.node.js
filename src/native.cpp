#pragma once 
//
#ifndef NAPI_VERSION
#define NAPI_VERSION 8
#endif

//
#ifndef NAPI_EXPERIMENTAL
#define NAPI_EXPERIMENTAL
#endif

//
#ifndef VK_NO_PROTOTYPES
#define VK_NO_PROTOTYPES
#endif

//
#define WINDOWS_IGNORE_PACKING_MISMATCH

//
#ifdef _WIN32
#include <windows.h>
#include <eh.h>
#endif

//
#include <volk/volk.h>

//
#include <iostream>
#include <exception>
#include <string>
#include <sstream>
#include <napi.h>

//
#include "./sizes.h"
#include "./native.hpp"

//
#ifdef ENABLE_GLFW_SUPPORT
#include "./glfw.hpp"
#endif

//
static Napi::Value rawGetStructureSizeBySType(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    uint64_t address = 0ull;
    if (info_[0].IsNumber()) {
        return Napi::Number::New(env, vkGetStructureSizeBySType((VkStructureType)info_[0].As<Napi::Number>().Uint32Value()));
    }
    return Napi::Number::New(env, 0);
}

static Napi::Value rawCreateInstance(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    decltype(auto) pCreateInfo = (VkInstanceCreateInfo const*)GetAddress(env, info_[0]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[1]);

    decltype(auto) pInstance = (VkInstance*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateInstance(pCreateInfo, pAllocator, pInstance);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        volkLoadInstance(*pInstance);
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateInstance command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateInstance)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pInstance: " << (uint64_t)(pInstance) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyInstance(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[1]);
    try {
        ::vkDestroyInstance(instance, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyInstance command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyInstance)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawEnumeratePhysicalDevices(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pPhysicalDeviceCount = (uint32_t*)GetAddress(env, info_[1]);

    decltype(auto) pPhysicalDevices = (VkPhysicalDevice*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkEnumeratePhysicalDevices command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkEnumeratePhysicalDevices)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pPhysicalDeviceCount: " << (uint64_t)(pPhysicalDeviceCount) << std::endl;
        std::cerr << "    pPhysicalDevices: " << (uint64_t)(pPhysicalDevices) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawGetDeviceProcAddr(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pName = (char const*)GetAddress(env, info_[1]);
    try {
        ::vkGetDeviceProcAddr(device, pName);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeviceProcAddr command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeviceProcAddr)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pName: " << (uint64_t)(pName) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetInstanceProcAddr(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pName = (char const*)GetAddress(env, info_[1]);
    try {
        ::vkGetInstanceProcAddr(instance, pName);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetInstanceProcAddr command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetInstanceProcAddr)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pName: " << (uint64_t)(pName) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetPhysicalDeviceProperties(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pProperties = (VkPhysicalDeviceProperties*)GetAddress(env, info_[1]);
    try {
        ::vkGetPhysicalDeviceProperties(physicalDevice, pProperties);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceProperties command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceProperties)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetPhysicalDeviceQueueFamilyProperties(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pQueueFamilyPropertyCount = (uint32_t*)GetAddress(env, info_[1]);

    decltype(auto) pQueueFamilyProperties = (VkQueueFamilyProperties*)GetAddress(env, info_[2]);
    try {
        ::vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceQueueFamilyProperties command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceQueueFamilyProperties)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pQueueFamilyPropertyCount: " << (uint64_t)(pQueueFamilyPropertyCount) << std::endl;
        std::cerr << "    pQueueFamilyProperties: " << (uint64_t)(pQueueFamilyProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetPhysicalDeviceMemoryProperties(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pMemoryProperties = (VkPhysicalDeviceMemoryProperties*)GetAddress(env, info_[1]);
    try {
        ::vkGetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceMemoryProperties command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceMemoryProperties)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pMemoryProperties: " << (uint64_t)(pMemoryProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetPhysicalDeviceFeatures(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pFeatures = (VkPhysicalDeviceFeatures*)GetAddress(env, info_[1]);
    try {
        ::vkGetPhysicalDeviceFeatures(physicalDevice, pFeatures);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceFeatures command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceFeatures)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pFeatures: " << (uint64_t)(pFeatures) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetPhysicalDeviceFormatProperties(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (format)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) format = (VkFormat)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pFormatProperties = (VkFormatProperties*)GetAddress(env, info_[2]);
    try {
        ::vkGetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceFormatProperties command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceFormatProperties)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    format: " << (uint64_t)(format) << std::endl;
        std::cerr << "    pFormatProperties: " << (uint64_t)(pFormatProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetPhysicalDeviceImageFormatProperties(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 7) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (format)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) format = (VkFormat)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (type)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) type = (VkImageType)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (tiling)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) tiling = (VkImageTiling)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (usage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) usage = (VkImageUsageFlags)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (flags)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) flags = (VkImageCreateFlags)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());

    decltype(auto) pImageFormatProperties = (VkImageFormatProperties*)GetAddress(env, info_[6]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceImageFormatProperties command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceImageFormatProperties)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    format: " << (uint64_t)(format) << std::endl;
        std::cerr << "    type: " << (uint64_t)(type) << std::endl;
        std::cerr << "    tiling: " << (uint64_t)(tiling) << std::endl;
        std::cerr << "    usage: " << (uint64_t)(usage) << std::endl;
        std::cerr << "    flags: " << (uint64_t)(flags) << std::endl;
        std::cerr << "    pImageFormatProperties: " << (uint64_t)(pImageFormatProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawCreateDevice(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkDeviceCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pDevice = (VkDevice*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        volkLoadDevice(*pDevice);
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateDevice command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateDevice)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pDevice: " << (uint64_t)(pDevice) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyDevice(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[1]);
    try {
        ::vkDestroyDevice(device, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyDevice command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyDevice)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawEnumerateInstanceVersion(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 1) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    decltype(auto) pApiVersion = (uint32_t*)GetAddress(env, info_[0]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkEnumerateInstanceVersion(pApiVersion);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkEnumerateInstanceVersion command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkEnumerateInstanceVersion)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    pApiVersion: " << (uint64_t)(pApiVersion) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawEnumerateInstanceLayerProperties(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    decltype(auto) pPropertyCount = (uint32_t*)GetAddress(env, info_[0]);

    decltype(auto) pProperties = (VkLayerProperties*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkEnumerateInstanceLayerProperties(pPropertyCount, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkEnumerateInstanceLayerProperties command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkEnumerateInstanceLayerProperties)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    pPropertyCount: " << (uint64_t)(pPropertyCount) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawEnumerateInstanceExtensionProperties(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    decltype(auto) pLayerName = (char const*)GetAddress(env, info_[0]);

    decltype(auto) pPropertyCount = (uint32_t*)GetAddress(env, info_[1]);

    decltype(auto) pProperties = (VkExtensionProperties*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkEnumerateInstanceExtensionProperties(pLayerName, pPropertyCount, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkEnumerateInstanceExtensionProperties command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkEnumerateInstanceExtensionProperties)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    pLayerName: " << (uint64_t)(pLayerName) << std::endl;
        std::cerr << "    pPropertyCount: " << (uint64_t)(pPropertyCount) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawEnumerateDeviceLayerProperties(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pPropertyCount = (uint32_t*)GetAddress(env, info_[1]);

    decltype(auto) pProperties = (VkLayerProperties*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkEnumerateDeviceLayerProperties(physicalDevice, pPropertyCount, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkEnumerateDeviceLayerProperties command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkEnumerateDeviceLayerProperties)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pPropertyCount: " << (uint64_t)(pPropertyCount) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawEnumerateDeviceExtensionProperties(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pLayerName = (char const*)GetAddress(env, info_[1]);

    decltype(auto) pPropertyCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pProperties = (VkExtensionProperties*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, pPropertyCount, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkEnumerateDeviceExtensionProperties command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkEnumerateDeviceExtensionProperties)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pLayerName: " << (uint64_t)(pLayerName) << std::endl;
        std::cerr << "    pPropertyCount: " << (uint64_t)(pPropertyCount) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawGetDeviceQueue(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (queueFamilyIndex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queueFamilyIndex = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (queueIndex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queueIndex = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pQueue = (VkQueue*)GetAddress(env, info_[3]);
    try {
        ::vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeviceQueue command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeviceQueue)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    queueFamilyIndex: " << (uint64_t)(queueFamilyIndex) << std::endl;
        std::cerr << "    queueIndex: " << (uint64_t)(queueIndex) << std::endl;
        std::cerr << "    pQueue: " << (uint64_t)(pQueue) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawQueueSubmit(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (queue)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queue = (VkQueue)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (submitCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) submitCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pSubmits = (VkSubmitInfo const*)GetAddress(env, info_[2]);

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (fence)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) fence = (VkFence)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkQueueSubmit(queue, submitCount, pSubmits, fence);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkQueueSubmit command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkQueueSubmit)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    queue: " << (uint64_t)(queue) << std::endl;
        std::cerr << "    submitCount: " << (uint64_t)(submitCount) << std::endl;
        std::cerr << "    pSubmits: " << (uint64_t)(pSubmits) << std::endl;
        std::cerr << "    fence: " << (uint64_t)(fence) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawQueueWaitIdle(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 1) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (queue)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queue = (VkQueue)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkQueueWaitIdle(queue);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkQueueWaitIdle command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkQueueWaitIdle)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    queue: " << (uint64_t)(queue) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDeviceWaitIdle(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 1) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkDeviceWaitIdle(device);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDeviceWaitIdle command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDeviceWaitIdle)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawAllocateMemory(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocateInfo = (VkMemoryAllocateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pMemory = (VkDeviceMemory*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkAllocateMemory(device, pAllocateInfo, pAllocator, pMemory);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkAllocateMemory command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkAllocateMemory)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pAllocateInfo: " << (uint64_t)(pAllocateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pMemory: " << (uint64_t)(pMemory) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawFreeMemory(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (memory)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) memory = (VkDeviceMemory)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkFreeMemory(device, memory, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkFreeMemory command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkFreeMemory)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    memory: " << (uint64_t)(memory) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawMapMemory(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (memory)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) memory = (VkDeviceMemory)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (offset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) offset = (VkDeviceSize)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (size)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) size = (VkDeviceSize)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (flags)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) flags = (VkMemoryMapFlags)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    decltype(auto) ppData = (void**)GetAddress(env, info_[5]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkMapMemory(device, memory, offset, size, flags, ppData);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkMapMemory command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkMapMemory)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    memory: " << (uint64_t)(memory) << std::endl;
        std::cerr << "    offset: " << (uint64_t)(offset) << std::endl;
        std::cerr << "    size: " << (uint64_t)(size) << std::endl;
        std::cerr << "    flags: " << (uint64_t)(flags) << std::endl;
        std::cerr << "    ppData: " << (uint64_t)(ppData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawUnmapMemory(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (memory)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) memory = (VkDeviceMemory)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    try {
        ::vkUnmapMemory(device, memory);
    } catch(std::exception e) {
        std::cerr << "Exception with vkUnmapMemory command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkUnmapMemory)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    memory: " << (uint64_t)(memory) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawFlushMappedMemoryRanges(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (memoryRangeCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) memoryRangeCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pMemoryRanges = (VkMappedMemoryRange const*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkFlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkFlushMappedMemoryRanges command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkFlushMappedMemoryRanges)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    memoryRangeCount: " << (uint64_t)(memoryRangeCount) << std::endl;
        std::cerr << "    pMemoryRanges: " << (uint64_t)(pMemoryRanges) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawInvalidateMappedMemoryRanges(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (memoryRangeCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) memoryRangeCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pMemoryRanges = (VkMappedMemoryRange const*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkInvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkInvalidateMappedMemoryRanges command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkInvalidateMappedMemoryRanges)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    memoryRangeCount: " << (uint64_t)(memoryRangeCount) << std::endl;
        std::cerr << "    pMemoryRanges: " << (uint64_t)(pMemoryRanges) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawGetDeviceMemoryCommitment(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (memory)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) memory = (VkDeviceMemory)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pCommittedMemoryInBytes = (VkDeviceSize*)GetAddress(env, info_[2]);
    try {
        ::vkGetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeviceMemoryCommitment command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeviceMemoryCommitment)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    memory: " << (uint64_t)(memory) << std::endl;
        std::cerr << "    pCommittedMemoryInBytes: " << (uint64_t)(pCommittedMemoryInBytes) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetBufferMemoryRequirements(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (buffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) buffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pMemoryRequirements = (VkMemoryRequirements*)GetAddress(env, info_[2]);
    try {
        ::vkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetBufferMemoryRequirements command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetBufferMemoryRequirements)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    buffer: " << (uint64_t)(buffer) << std::endl;
        std::cerr << "    pMemoryRequirements: " << (uint64_t)(pMemoryRequirements) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawBindBufferMemory(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (buffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) buffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (memory)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) memory = (VkDeviceMemory)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (memoryOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) memoryOffset = (VkDeviceSize)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkBindBufferMemory(device, buffer, memory, memoryOffset);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkBindBufferMemory command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkBindBufferMemory)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    buffer: " << (uint64_t)(buffer) << std::endl;
        std::cerr << "    memory: " << (uint64_t)(memory) << std::endl;
        std::cerr << "    memoryOffset: " << (uint64_t)(memoryOffset) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawGetImageMemoryRequirements(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (image)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) image = (VkImage)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pMemoryRequirements = (VkMemoryRequirements*)GetAddress(env, info_[2]);
    try {
        ::vkGetImageMemoryRequirements(device, image, pMemoryRequirements);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetImageMemoryRequirements command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetImageMemoryRequirements)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    image: " << (uint64_t)(image) << std::endl;
        std::cerr << "    pMemoryRequirements: " << (uint64_t)(pMemoryRequirements) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawBindImageMemory(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (image)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) image = (VkImage)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (memory)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) memory = (VkDeviceMemory)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (memoryOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) memoryOffset = (VkDeviceSize)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkBindImageMemory(device, image, memory, memoryOffset);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkBindImageMemory command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkBindImageMemory)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    image: " << (uint64_t)(image) << std::endl;
        std::cerr << "    memory: " << (uint64_t)(memory) << std::endl;
        std::cerr << "    memoryOffset: " << (uint64_t)(memoryOffset) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawGetImageSparseMemoryRequirements(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (image)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) image = (VkImage)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pSparseMemoryRequirementCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pSparseMemoryRequirements = (VkSparseImageMemoryRequirements*)GetAddress(env, info_[3]);
    try {
        ::vkGetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetImageSparseMemoryRequirements command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetImageSparseMemoryRequirements)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    image: " << (uint64_t)(image) << std::endl;
        std::cerr << "    pSparseMemoryRequirementCount: " << (uint64_t)(pSparseMemoryRequirementCount) << std::endl;
        std::cerr << "    pSparseMemoryRequirements: " << (uint64_t)(pSparseMemoryRequirements) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetPhysicalDeviceSparseImageFormatProperties(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 8) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (format)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) format = (VkFormat)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (type)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) type = (VkImageType)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (samples)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) samples = (VkSampleCountFlagBits)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (usage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) usage = (VkImageUsageFlags)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    if (!info_[5].IsBigInt() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 5 argument (tiling)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) tiling = (VkImageTiling)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Int64Value());

    decltype(auto) pPropertyCount = (uint32_t*)GetAddress(env, info_[6]);

    decltype(auto) pProperties = (VkSparseImageFormatProperties*)GetAddress(env, info_[7]);
    try {
        ::vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceSparseImageFormatProperties command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceSparseImageFormatProperties)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    format: " << (uint64_t)(format) << std::endl;
        std::cerr << "    type: " << (uint64_t)(type) << std::endl;
        std::cerr << "    samples: " << (uint64_t)(samples) << std::endl;
        std::cerr << "    usage: " << (uint64_t)(usage) << std::endl;
        std::cerr << "    tiling: " << (uint64_t)(tiling) << std::endl;
        std::cerr << "    pPropertyCount: " << (uint64_t)(pPropertyCount) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawQueueBindSparse(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (queue)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queue = (VkQueue)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (bindInfoCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) bindInfoCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pBindInfo = (VkBindSparseInfo const*)GetAddress(env, info_[2]);

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (fence)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) fence = (VkFence)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkQueueBindSparse(queue, bindInfoCount, pBindInfo, fence);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkQueueBindSparse command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkQueueBindSparse)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    queue: " << (uint64_t)(queue) << std::endl;
        std::cerr << "    bindInfoCount: " << (uint64_t)(bindInfoCount) << std::endl;
        std::cerr << "    pBindInfo: " << (uint64_t)(pBindInfo) << std::endl;
        std::cerr << "    fence: " << (uint64_t)(fence) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawCreateFence(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkFenceCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pFence = (VkFence*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateFence(device, pCreateInfo, pAllocator, pFence);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateFence command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateFence)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pFence: " << (uint64_t)(pFence) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyFence(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (fence)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) fence = (VkFence)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyFence(device, fence, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyFence command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyFence)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    fence: " << (uint64_t)(fence) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawResetFences(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (fenceCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) fenceCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pFences = (VkFence const*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkResetFences(device, fenceCount, pFences);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkResetFences command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkResetFences)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    fenceCount: " << (uint64_t)(fenceCount) << std::endl;
        std::cerr << "    pFences: " << (uint64_t)(pFences) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawGetFenceStatus(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (fence)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) fence = (VkFence)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetFenceStatus(device, fence);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetFenceStatus command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetFenceStatus)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    fence: " << (uint64_t)(fence) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawWaitForFences(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (fenceCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) fenceCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pFences = (VkFence const*)GetAddress(env, info_[2]);

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (waitAll)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) waitAll = (VkBool32)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (timeout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) timeout = (uint64_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkWaitForFences(device, fenceCount, pFences, waitAll, timeout);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkWaitForFences command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkWaitForFences)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    fenceCount: " << (uint64_t)(fenceCount) << std::endl;
        std::cerr << "    pFences: " << (uint64_t)(pFences) << std::endl;
        std::cerr << "    waitAll: " << (uint64_t)(waitAll) << std::endl;
        std::cerr << "    timeout: " << (uint64_t)(timeout) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawCreateSemaphore(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkSemaphoreCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSemaphore = (VkSemaphore*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateSemaphore command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateSemaphore)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSemaphore: " << (uint64_t)(pSemaphore) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroySemaphore(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (semaphore)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) semaphore = (VkSemaphore)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroySemaphore(device, semaphore, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroySemaphore command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroySemaphore)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    semaphore: " << (uint64_t)(semaphore) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCreateEvent(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkEventCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pEvent = (VkEvent*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateEvent(device, pCreateInfo, pAllocator, pEvent);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateEvent command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateEvent)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pEvent: " << (uint64_t)(pEvent) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyEvent(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (event)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) event = (VkEvent)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyEvent(device, event, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyEvent command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyEvent)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    event: " << (uint64_t)(event) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetEventStatus(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (event)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) event = (VkEvent)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetEventStatus(device, event);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetEventStatus command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetEventStatus)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    event: " << (uint64_t)(event) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawSetEvent(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (event)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) event = (VkEvent)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkSetEvent(device, event);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkSetEvent command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkSetEvent)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    event: " << (uint64_t)(event) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawResetEvent(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (event)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) event = (VkEvent)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkResetEvent(device, event);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkResetEvent command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkResetEvent)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    event: " << (uint64_t)(event) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawCreateQueryPool(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkQueryPoolCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pQueryPool = (VkQueryPool*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateQueryPool command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateQueryPool)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pQueryPool: " << (uint64_t)(pQueryPool) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyQueryPool(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (queryPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryPool = (VkQueryPool)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyQueryPool(device, queryPool, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyQueryPool command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyQueryPool)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    queryPool: " << (uint64_t)(queryPool) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetQueryPoolResults(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 8) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (queryPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryPool = (VkQueryPool)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (firstQuery)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstQuery = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (queryCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryCount = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (dataSize)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dataSize = (size_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    decltype(auto) pData = (void*)GetAddress(env, info_[5]);

    if (!info_[6].IsBigInt() && !info_[6].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 6 argument (stride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stride = (VkDeviceSize)(info_[6].IsBigInt() ? info_[6].As<Napi::BigInt>().Uint64Value(&lossless) : info_[6].As<Napi::Number>().Int64Value());

    if (!info_[7].IsNumber() && !info_[7].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 7 argument (flags)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) flags = (VkQueryResultFlags)(info_[7].IsBigInt() ? info_[7].As<Napi::BigInt>().Uint64Value(&lossless) : info_[7].As<Napi::Number>().Uint32Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetQueryPoolResults command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetQueryPoolResults)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    queryPool: " << (uint64_t)(queryPool) << std::endl;
        std::cerr << "    firstQuery: " << (uint64_t)(firstQuery) << std::endl;
        std::cerr << "    queryCount: " << (uint64_t)(queryCount) << std::endl;
        std::cerr << "    dataSize: " << (uint64_t)(dataSize) << std::endl;
        std::cerr << "    pData: " << (uint64_t)(pData) << std::endl;
        std::cerr << "    stride: " << (uint64_t)(stride) << std::endl;
        std::cerr << "    flags: " << (uint64_t)(flags) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawResetQueryPool(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (queryPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryPool = (VkQueryPool)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (firstQuery)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstQuery = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (queryCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryCount = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());
    try {
        ::vkResetQueryPool(device, queryPool, firstQuery, queryCount);
    } catch(std::exception e) {
        std::cerr << "Exception with vkResetQueryPool command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkResetQueryPool)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    queryPool: " << (uint64_t)(queryPool) << std::endl;
        std::cerr << "    firstQuery: " << (uint64_t)(firstQuery) << std::endl;
        std::cerr << "    queryCount: " << (uint64_t)(queryCount) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCreateBuffer(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkBufferCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pBuffer = (VkBuffer*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateBuffer(device, pCreateInfo, pAllocator, pBuffer);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateBuffer command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateBuffer)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pBuffer: " << (uint64_t)(pBuffer) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyBuffer(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (buffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) buffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyBuffer(device, buffer, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyBuffer command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyBuffer)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    buffer: " << (uint64_t)(buffer) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCreateBufferView(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkBufferViewCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pView = (VkBufferView*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateBufferView(device, pCreateInfo, pAllocator, pView);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateBufferView command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateBufferView)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pView: " << (uint64_t)(pView) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyBufferView(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (bufferView)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) bufferView = (VkBufferView)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyBufferView(device, bufferView, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyBufferView command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyBufferView)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    bufferView: " << (uint64_t)(bufferView) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCreateImage(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkImageCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pImage = (VkImage*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateImage(device, pCreateInfo, pAllocator, pImage);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateImage command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateImage)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pImage: " << (uint64_t)(pImage) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyImage(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (image)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) image = (VkImage)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyImage(device, image, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyImage command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyImage)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    image: " << (uint64_t)(image) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetImageSubresourceLayout(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (image)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) image = (VkImage)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pSubresource = (VkImageSubresource const*)GetAddress(env, info_[2]);

    decltype(auto) pLayout = (VkSubresourceLayout*)GetAddress(env, info_[3]);
    try {
        ::vkGetImageSubresourceLayout(device, image, pSubresource, pLayout);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetImageSubresourceLayout command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetImageSubresourceLayout)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    image: " << (uint64_t)(image) << std::endl;
        std::cerr << "    pSubresource: " << (uint64_t)(pSubresource) << std::endl;
        std::cerr << "    pLayout: " << (uint64_t)(pLayout) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCreateImageView(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkImageViewCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pView = (VkImageView*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateImageView(device, pCreateInfo, pAllocator, pView);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateImageView command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateImageView)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pView: " << (uint64_t)(pView) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyImageView(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (imageView)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) imageView = (VkImageView)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyImageView(device, imageView, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyImageView command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyImageView)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    imageView: " << (uint64_t)(imageView) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCreateShaderModule(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkShaderModuleCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pShaderModule = (VkShaderModule*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateShaderModule command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateShaderModule)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pShaderModule: " << (uint64_t)(pShaderModule) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyShaderModule(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (shaderModule)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) shaderModule = (VkShaderModule)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyShaderModule(device, shaderModule, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyShaderModule command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyShaderModule)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    shaderModule: " << (uint64_t)(shaderModule) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCreatePipelineCache(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkPipelineCacheCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pPipelineCache = (VkPipelineCache*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreatePipelineCache command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreatePipelineCache)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pPipelineCache: " << (uint64_t)(pPipelineCache) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyPipelineCache(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipelineCache)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipelineCache = (VkPipelineCache)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyPipelineCache(device, pipelineCache, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyPipelineCache command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyPipelineCache)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pipelineCache: " << (uint64_t)(pipelineCache) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetPipelineCacheData(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipelineCache)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipelineCache = (VkPipelineCache)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pDataSize = (size_t*)GetAddress(env, info_[2]);

    decltype(auto) pData = (void*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPipelineCacheData(device, pipelineCache, pDataSize, pData);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPipelineCacheData command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPipelineCacheData)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pipelineCache: " << (uint64_t)(pipelineCache) << std::endl;
        std::cerr << "    pDataSize: " << (uint64_t)(pDataSize) << std::endl;
        std::cerr << "    pData: " << (uint64_t)(pData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawMergePipelineCaches(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (dstCache)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstCache = (VkPipelineCache)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (srcCacheCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) srcCacheCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pSrcCaches = (VkPipelineCache const*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkMergePipelineCaches command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkMergePipelineCaches)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    dstCache: " << (uint64_t)(dstCache) << std::endl;
        std::cerr << "    srcCacheCount: " << (uint64_t)(srcCacheCount) << std::endl;
        std::cerr << "    pSrcCaches: " << (uint64_t)(pSrcCaches) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawCreateGraphicsPipelines(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipelineCache)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipelineCache = (VkPipelineCache)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (createInfoCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) createInfoCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pCreateInfos = (VkGraphicsPipelineCreateInfo const*)GetAddress(env, info_[3]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[4]);

    decltype(auto) pPipelines = (VkPipeline*)GetAddress(env, info_[5]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateGraphicsPipelines command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateGraphicsPipelines)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pipelineCache: " << (uint64_t)(pipelineCache) << std::endl;
        std::cerr << "    createInfoCount: " << (uint64_t)(createInfoCount) << std::endl;
        std::cerr << "    pCreateInfos: " << (uint64_t)(pCreateInfos) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pPipelines: " << (uint64_t)(pPipelines) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawCreateComputePipelines(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipelineCache)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipelineCache = (VkPipelineCache)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (createInfoCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) createInfoCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pCreateInfos = (VkComputePipelineCreateInfo const*)GetAddress(env, info_[3]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[4]);

    decltype(auto) pPipelines = (VkPipeline*)GetAddress(env, info_[5]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateComputePipelines command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateComputePipelines)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pipelineCache: " << (uint64_t)(pipelineCache) << std::endl;
        std::cerr << "    createInfoCount: " << (uint64_t)(createInfoCount) << std::endl;
        std::cerr << "    pCreateInfos: " << (uint64_t)(pCreateInfos) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pPipelines: " << (uint64_t)(pPipelines) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#ifdef VK_HUAWEI_subpass_shading
static Napi::Value rawGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (renderpass)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) renderpass = (VkRenderPass)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pMaxWorkgroupSize = (VkExtent2D*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(device, renderpass, pMaxWorkgroupSize);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    renderpass: " << (uint64_t)(renderpass) << std::endl;
        std::cerr << "    pMaxWorkgroupSize: " << (uint64_t)(pMaxWorkgroupSize) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
static Napi::Value rawDestroyPipeline(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipeline)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipeline = (VkPipeline)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyPipeline(device, pipeline, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyPipeline command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyPipeline)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pipeline: " << (uint64_t)(pipeline) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCreatePipelineLayout(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkPipelineLayoutCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pPipelineLayout = (VkPipelineLayout*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreatePipelineLayout command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreatePipelineLayout)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pPipelineLayout: " << (uint64_t)(pPipelineLayout) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyPipelineLayout(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipelineLayout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipelineLayout = (VkPipelineLayout)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyPipelineLayout(device, pipelineLayout, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyPipelineLayout command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyPipelineLayout)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pipelineLayout: " << (uint64_t)(pipelineLayout) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCreateSampler(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkSamplerCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSampler = (VkSampler*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateSampler(device, pCreateInfo, pAllocator, pSampler);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateSampler command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateSampler)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSampler: " << (uint64_t)(pSampler) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroySampler(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (sampler)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) sampler = (VkSampler)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroySampler(device, sampler, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroySampler command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroySampler)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    sampler: " << (uint64_t)(sampler) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCreateDescriptorSetLayout(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkDescriptorSetLayoutCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSetLayout = (VkDescriptorSetLayout*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateDescriptorSetLayout command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateDescriptorSetLayout)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSetLayout: " << (uint64_t)(pSetLayout) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyDescriptorSetLayout(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (descriptorSetLayout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) descriptorSetLayout = (VkDescriptorSetLayout)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyDescriptorSetLayout command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyDescriptorSetLayout)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    descriptorSetLayout: " << (uint64_t)(descriptorSetLayout) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCreateDescriptorPool(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkDescriptorPoolCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pDescriptorPool = (VkDescriptorPool*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateDescriptorPool command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateDescriptorPool)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pDescriptorPool: " << (uint64_t)(pDescriptorPool) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyDescriptorPool(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (descriptorPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) descriptorPool = (VkDescriptorPool)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyDescriptorPool(device, descriptorPool, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyDescriptorPool command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyDescriptorPool)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    descriptorPool: " << (uint64_t)(descriptorPool) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawResetDescriptorPool(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (descriptorPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) descriptorPool = (VkDescriptorPool)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (flags)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) flags = (VkDescriptorPoolResetFlags)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkResetDescriptorPool(device, descriptorPool, flags);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkResetDescriptorPool command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkResetDescriptorPool)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    descriptorPool: " << (uint64_t)(descriptorPool) << std::endl;
        std::cerr << "    flags: " << (uint64_t)(flags) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawAllocateDescriptorSets(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocateInfo = (VkDescriptorSetAllocateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pDescriptorSets = (VkDescriptorSet*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkAllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkAllocateDescriptorSets command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkAllocateDescriptorSets)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pAllocateInfo: " << (uint64_t)(pAllocateInfo) << std::endl;
        std::cerr << "    pDescriptorSets: " << (uint64_t)(pDescriptorSets) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawFreeDescriptorSets(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (descriptorPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) descriptorPool = (VkDescriptorPool)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (descriptorSetCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) descriptorSetCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pDescriptorSets = (VkDescriptorSet const*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkFreeDescriptorSets command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkFreeDescriptorSets)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    descriptorPool: " << (uint64_t)(descriptorPool) << std::endl;
        std::cerr << "    descriptorSetCount: " << (uint64_t)(descriptorSetCount) << std::endl;
        std::cerr << "    pDescriptorSets: " << (uint64_t)(pDescriptorSets) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawUpdateDescriptorSets(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (descriptorWriteCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) descriptorWriteCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pDescriptorWrites = (VkWriteDescriptorSet const*)GetAddress(env, info_[2]);

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (descriptorCopyCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) descriptorCopyCount = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    decltype(auto) pDescriptorCopies = (VkCopyDescriptorSet const*)GetAddress(env, info_[4]);
    try {
        ::vkUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
    } catch(std::exception e) {
        std::cerr << "Exception with vkUpdateDescriptorSets command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkUpdateDescriptorSets)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    descriptorWriteCount: " << (uint64_t)(descriptorWriteCount) << std::endl;
        std::cerr << "    pDescriptorWrites: " << (uint64_t)(pDescriptorWrites) << std::endl;
        std::cerr << "    descriptorCopyCount: " << (uint64_t)(descriptorCopyCount) << std::endl;
        std::cerr << "    pDescriptorCopies: " << (uint64_t)(pDescriptorCopies) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCreateFramebuffer(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkFramebufferCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pFramebuffer = (VkFramebuffer*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateFramebuffer command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateFramebuffer)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pFramebuffer: " << (uint64_t)(pFramebuffer) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyFramebuffer(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (framebuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) framebuffer = (VkFramebuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyFramebuffer(device, framebuffer, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyFramebuffer command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyFramebuffer)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    framebuffer: " << (uint64_t)(framebuffer) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCreateRenderPass(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkRenderPassCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pRenderPass = (VkRenderPass*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateRenderPass command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateRenderPass)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pRenderPass: " << (uint64_t)(pRenderPass) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyRenderPass(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (renderPass)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) renderPass = (VkRenderPass)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyRenderPass(device, renderPass, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyRenderPass command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyRenderPass)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    renderPass: " << (uint64_t)(renderPass) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetRenderAreaGranularity(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (renderPass)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) renderPass = (VkRenderPass)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pGranularity = (VkExtent2D*)GetAddress(env, info_[2]);
    try {
        ::vkGetRenderAreaGranularity(device, renderPass, pGranularity);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetRenderAreaGranularity command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetRenderAreaGranularity)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    renderPass: " << (uint64_t)(renderPass) << std::endl;
        std::cerr << "    pGranularity: " << (uint64_t)(pGranularity) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCreateCommandPool(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkCommandPoolCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pCommandPool = (VkCommandPool*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateCommandPool command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateCommandPool)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pCommandPool: " << (uint64_t)(pCommandPool) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyCommandPool(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (commandPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandPool = (VkCommandPool)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyCommandPool(device, commandPool, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyCommandPool command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyCommandPool)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    commandPool: " << (uint64_t)(commandPool) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawResetCommandPool(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (commandPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandPool = (VkCommandPool)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (flags)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) flags = (VkCommandPoolResetFlags)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkResetCommandPool(device, commandPool, flags);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkResetCommandPool command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkResetCommandPool)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    commandPool: " << (uint64_t)(commandPool) << std::endl;
        std::cerr << "    flags: " << (uint64_t)(flags) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawAllocateCommandBuffers(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocateInfo = (VkCommandBufferAllocateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pCommandBuffers = (VkCommandBuffer*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkAllocateCommandBuffers command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkAllocateCommandBuffers)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pAllocateInfo: " << (uint64_t)(pAllocateInfo) << std::endl;
        std::cerr << "    pCommandBuffers: " << (uint64_t)(pCommandBuffers) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawFreeCommandBuffers(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (commandPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandPool = (VkCommandPool)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (commandBufferCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBufferCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pCommandBuffers = (VkCommandBuffer const*)GetAddress(env, info_[3]);
    try {
        ::vkFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers);
    } catch(std::exception e) {
        std::cerr << "Exception with vkFreeCommandBuffers command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkFreeCommandBuffers)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    commandPool: " << (uint64_t)(commandPool) << std::endl;
        std::cerr << "    commandBufferCount: " << (uint64_t)(commandBufferCount) << std::endl;
        std::cerr << "    pCommandBuffers: " << (uint64_t)(pCommandBuffers) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawBeginCommandBuffer(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pBeginInfo = (VkCommandBufferBeginInfo const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkBeginCommandBuffer(commandBuffer, pBeginInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkBeginCommandBuffer command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkBeginCommandBuffer)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pBeginInfo: " << (uint64_t)(pBeginInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawEndCommandBuffer(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 1) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkEndCommandBuffer(commandBuffer);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkEndCommandBuffer command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkEndCommandBuffer)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawResetCommandBuffer(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (flags)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) flags = (VkCommandBufferResetFlags)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkResetCommandBuffer(commandBuffer, flags);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkResetCommandBuffer command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkResetCommandBuffer)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    flags: " << (uint64_t)(flags) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawCmdBindPipeline(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipelineBindPoint)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipelineBindPoint = (VkPipelineBindPoint)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (pipeline)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipeline = (VkPipeline)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBindPipeline command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBindPipeline)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pipelineBindPoint: " << (uint64_t)(pipelineBindPoint) << std::endl;
        std::cerr << "    pipeline: " << (uint64_t)(pipeline) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetViewport(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (firstViewport)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstViewport = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (viewportCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) viewportCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pViewports = (VkViewport const*)GetAddress(env, info_[3]);
    try {
        ::vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetViewport command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetViewport)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    firstViewport: " << (uint64_t)(firstViewport) << std::endl;
        std::cerr << "    viewportCount: " << (uint64_t)(viewportCount) << std::endl;
        std::cerr << "    pViewports: " << (uint64_t)(pViewports) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetScissor(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (firstScissor)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstScissor = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (scissorCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) scissorCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pScissors = (VkRect2D const*)GetAddress(env, info_[3]);
    try {
        ::vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetScissor command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetScissor)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    firstScissor: " << (uint64_t)(firstScissor) << std::endl;
        std::cerr << "    scissorCount: " << (uint64_t)(scissorCount) << std::endl;
        std::cerr << "    pScissors: " << (uint64_t)(pScissors) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetLineWidth(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber()) { Napi::TypeError::New(env, "Wrong type, needs Number at 1 argument (lineWidth)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) lineWidth = (float)info_[1].As<Napi::Number>().FloatValue();
    try {
        ::vkCmdSetLineWidth(commandBuffer, lineWidth);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetLineWidth command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetLineWidth)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    lineWidth: " << (uint64_t)(lineWidth) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetDepthBias(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber()) { Napi::TypeError::New(env, "Wrong type, needs Number at 1 argument (depthBiasConstantFactor)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) depthBiasConstantFactor = (float)info_[1].As<Napi::Number>().FloatValue();

    if (!info_[2].IsNumber()) { Napi::TypeError::New(env, "Wrong type, needs Number at 2 argument (depthBiasClamp)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) depthBiasClamp = (float)info_[2].As<Napi::Number>().FloatValue();

    if (!info_[3].IsNumber()) { Napi::TypeError::New(env, "Wrong type, needs Number at 3 argument (depthBiasSlopeFactor)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) depthBiasSlopeFactor = (float)info_[3].As<Napi::Number>().FloatValue();
    try {
        ::vkCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetDepthBias command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetDepthBias)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    depthBiasConstantFactor: " << (uint64_t)(depthBiasConstantFactor) << std::endl;
        std::cerr << "    depthBiasClamp: " << (uint64_t)(depthBiasClamp) << std::endl;
        std::cerr << "    depthBiasSlopeFactor: " << (uint64_t)(depthBiasSlopeFactor) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetBlendConstants(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) blendConstants = (float const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdSetBlendConstants(commandBuffer, blendConstants);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetBlendConstants command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetBlendConstants)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    blendConstants: " << (uint64_t)(blendConstants) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetDepthBounds(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber()) { Napi::TypeError::New(env, "Wrong type, needs Number at 1 argument (minDepthBounds)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) minDepthBounds = (float)info_[1].As<Napi::Number>().FloatValue();

    if (!info_[2].IsNumber()) { Napi::TypeError::New(env, "Wrong type, needs Number at 2 argument (maxDepthBounds)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) maxDepthBounds = (float)info_[2].As<Napi::Number>().FloatValue();
    try {
        ::vkCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetDepthBounds command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetDepthBounds)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    minDepthBounds: " << (uint64_t)(minDepthBounds) << std::endl;
        std::cerr << "    maxDepthBounds: " << (uint64_t)(maxDepthBounds) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetStencilCompareMask(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (faceMask)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) faceMask = (VkStencilFaceFlags)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (compareMask)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) compareMask = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetStencilCompareMask command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetStencilCompareMask)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    faceMask: " << (uint64_t)(faceMask) << std::endl;
        std::cerr << "    compareMask: " << (uint64_t)(compareMask) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetStencilWriteMask(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (faceMask)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) faceMask = (VkStencilFaceFlags)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (writeMask)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) writeMask = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetStencilWriteMask command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetStencilWriteMask)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    faceMask: " << (uint64_t)(faceMask) << std::endl;
        std::cerr << "    writeMask: " << (uint64_t)(writeMask) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetStencilReference(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (faceMask)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) faceMask = (VkStencilFaceFlags)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (reference)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) reference = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetStencilReference(commandBuffer, faceMask, reference);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetStencilReference command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetStencilReference)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    faceMask: " << (uint64_t)(faceMask) << std::endl;
        std::cerr << "    reference: " << (uint64_t)(reference) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdBindDescriptorSets(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 8) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipelineBindPoint)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipelineBindPoint = (VkPipelineBindPoint)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (layout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) layout = (VkPipelineLayout)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (firstSet)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstSet = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (descriptorSetCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) descriptorSetCount = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    decltype(auto) pDescriptorSets = (VkDescriptorSet const*)GetAddress(env, info_[5]);

    if (!info_[6].IsNumber() && !info_[6].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 6 argument (dynamicOffsetCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dynamicOffsetCount = (uint32_t)(info_[6].IsBigInt() ? info_[6].As<Napi::BigInt>().Uint64Value(&lossless) : info_[6].As<Napi::Number>().Uint32Value());

    decltype(auto) pDynamicOffsets = (uint32_t const*)GetAddress(env, info_[7]);
    try {
        ::vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBindDescriptorSets command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBindDescriptorSets)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pipelineBindPoint: " << (uint64_t)(pipelineBindPoint) << std::endl;
        std::cerr << "    layout: " << (uint64_t)(layout) << std::endl;
        std::cerr << "    firstSet: " << (uint64_t)(firstSet) << std::endl;
        std::cerr << "    descriptorSetCount: " << (uint64_t)(descriptorSetCount) << std::endl;
        std::cerr << "    pDescriptorSets: " << (uint64_t)(pDescriptorSets) << std::endl;
        std::cerr << "    dynamicOffsetCount: " << (uint64_t)(dynamicOffsetCount) << std::endl;
        std::cerr << "    pDynamicOffsets: " << (uint64_t)(pDynamicOffsets) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdBindIndexBuffer(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (buffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) buffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (offset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) offset = (VkDeviceSize)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (indexType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) indexType = (VkIndexType)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBindIndexBuffer command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBindIndexBuffer)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    buffer: " << (uint64_t)(buffer) << std::endl;
        std::cerr << "    offset: " << (uint64_t)(offset) << std::endl;
        std::cerr << "    indexType: " << (uint64_t)(indexType) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdBindVertexBuffers(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (firstBinding)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstBinding = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (bindingCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) bindingCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pBuffers = (VkBuffer const*)GetAddress(env, info_[3]);

    decltype(auto) pOffsets = (VkDeviceSize const*)GetAddress(env, info_[4]);
    try {
        ::vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBindVertexBuffers command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBindVertexBuffers)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    firstBinding: " << (uint64_t)(firstBinding) << std::endl;
        std::cerr << "    bindingCount: " << (uint64_t)(bindingCount) << std::endl;
        std::cerr << "    pBuffers: " << (uint64_t)(pBuffers) << std::endl;
        std::cerr << "    pOffsets: " << (uint64_t)(pOffsets) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdDraw(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (vertexCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) vertexCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (instanceCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instanceCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (firstVertex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstVertex = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (firstInstance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstInstance = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDraw command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDraw)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    vertexCount: " << (uint64_t)(vertexCount) << std::endl;
        std::cerr << "    instanceCount: " << (uint64_t)(instanceCount) << std::endl;
        std::cerr << "    firstVertex: " << (uint64_t)(firstVertex) << std::endl;
        std::cerr << "    firstInstance: " << (uint64_t)(firstInstance) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdDrawIndexed(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (indexCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) indexCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (instanceCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instanceCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (firstIndex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstIndex = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (vertexOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) vertexOffset = (int32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Int64Value(&lossless) : info_[4].As<Napi::Number>().Int32Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (firstInstance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstInstance = (uint32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDrawIndexed command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDrawIndexed)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    indexCount: " << (uint64_t)(indexCount) << std::endl;
        std::cerr << "    instanceCount: " << (uint64_t)(instanceCount) << std::endl;
        std::cerr << "    firstIndex: " << (uint64_t)(firstIndex) << std::endl;
        std::cerr << "    vertexOffset: " << (uint64_t)(vertexOffset) << std::endl;
        std::cerr << "    firstInstance: " << (uint64_t)(firstInstance) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_EXT_multi_draw
static Napi::Value rawCmdDrawMultiEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (drawCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) drawCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pVertexInfo = (VkMultiDrawInfoEXT const*)GetAddress(env, info_[2]);

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (instanceCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instanceCount = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (firstInstance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstInstance = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (stride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stride = (uint32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdDrawMultiEXT(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDrawMultiEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDrawMultiEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    drawCount: " << (uint64_t)(drawCount) << std::endl;
        std::cerr << "    pVertexInfo: " << (uint64_t)(pVertexInfo) << std::endl;
        std::cerr << "    instanceCount: " << (uint64_t)(instanceCount) << std::endl;
        std::cerr << "    firstInstance: " << (uint64_t)(firstInstance) << std::endl;
        std::cerr << "    stride: " << (uint64_t)(stride) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_multi_draw
static Napi::Value rawCmdDrawMultiIndexedEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 7) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (drawCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) drawCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pIndexInfo = (VkMultiDrawIndexedInfoEXT const*)GetAddress(env, info_[2]);

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (instanceCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instanceCount = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (firstInstance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstInstance = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (stride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stride = (uint32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());

    decltype(auto) pVertexOffset = (int32_t const*)GetAddress(env, info_[6]);
    try {
        ::vkCmdDrawMultiIndexedEXT(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDrawMultiIndexedEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDrawMultiIndexedEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    drawCount: " << (uint64_t)(drawCount) << std::endl;
        std::cerr << "    pIndexInfo: " << (uint64_t)(pIndexInfo) << std::endl;
        std::cerr << "    instanceCount: " << (uint64_t)(instanceCount) << std::endl;
        std::cerr << "    firstInstance: " << (uint64_t)(firstInstance) << std::endl;
        std::cerr << "    stride: " << (uint64_t)(stride) << std::endl;
        std::cerr << "    pVertexOffset: " << (uint64_t)(pVertexOffset) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
static Napi::Value rawCmdDrawIndirect(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (buffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) buffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (offset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) offset = (VkDeviceSize)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (drawCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) drawCount = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (stride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stride = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDrawIndirect command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDrawIndirect)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    buffer: " << (uint64_t)(buffer) << std::endl;
        std::cerr << "    offset: " << (uint64_t)(offset) << std::endl;
        std::cerr << "    drawCount: " << (uint64_t)(drawCount) << std::endl;
        std::cerr << "    stride: " << (uint64_t)(stride) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdDrawIndexedIndirect(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (buffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) buffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (offset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) offset = (VkDeviceSize)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (drawCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) drawCount = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (stride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stride = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDrawIndexedIndirect command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDrawIndexedIndirect)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    buffer: " << (uint64_t)(buffer) << std::endl;
        std::cerr << "    offset: " << (uint64_t)(offset) << std::endl;
        std::cerr << "    drawCount: " << (uint64_t)(drawCount) << std::endl;
        std::cerr << "    stride: " << (uint64_t)(stride) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdDispatch(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (groupCountX)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) groupCountX = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (groupCountY)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) groupCountY = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (groupCountZ)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) groupCountZ = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDispatch command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDispatch)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    groupCountX: " << (uint64_t)(groupCountX) << std::endl;
        std::cerr << "    groupCountY: " << (uint64_t)(groupCountY) << std::endl;
        std::cerr << "    groupCountZ: " << (uint64_t)(groupCountZ) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdDispatchIndirect(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (buffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) buffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (offset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) offset = (VkDeviceSize)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdDispatchIndirect(commandBuffer, buffer, offset);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDispatchIndirect command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDispatchIndirect)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    buffer: " << (uint64_t)(buffer) << std::endl;
        std::cerr << "    offset: " << (uint64_t)(offset) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_HUAWEI_subpass_shading
static Napi::Value rawCmdSubpassShadingHUAWEI(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 1) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdSubpassShadingHUAWEI(commandBuffer);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSubpassShadingHUAWEI command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSubpassShadingHUAWEI)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
static Napi::Value rawCmdCopyBuffer(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (srcBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) srcBuffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (dstBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstBuffer = (VkBuffer)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (regionCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) regionCount = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    decltype(auto) pRegions = (VkBufferCopy const*)GetAddress(env, info_[4]);
    try {
        ::vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyBuffer command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyBuffer)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    srcBuffer: " << (uint64_t)(srcBuffer) << std::endl;
        std::cerr << "    dstBuffer: " << (uint64_t)(dstBuffer) << std::endl;
        std::cerr << "    regionCount: " << (uint64_t)(regionCount) << std::endl;
        std::cerr << "    pRegions: " << (uint64_t)(pRegions) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdCopyImage(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 7) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (srcImage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) srcImage = (VkImage)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (srcImageLayout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) srcImageLayout = (VkImageLayout)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (dstImage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstImage = (VkImage)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (dstImageLayout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstImageLayout = (VkImageLayout)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (regionCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) regionCount = (uint32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());

    decltype(auto) pRegions = (VkImageCopy const*)GetAddress(env, info_[6]);
    try {
        ::vkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyImage command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyImage)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    srcImage: " << (uint64_t)(srcImage) << std::endl;
        std::cerr << "    srcImageLayout: " << (uint64_t)(srcImageLayout) << std::endl;
        std::cerr << "    dstImage: " << (uint64_t)(dstImage) << std::endl;
        std::cerr << "    dstImageLayout: " << (uint64_t)(dstImageLayout) << std::endl;
        std::cerr << "    regionCount: " << (uint64_t)(regionCount) << std::endl;
        std::cerr << "    pRegions: " << (uint64_t)(pRegions) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdBlitImage(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 8) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (srcImage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) srcImage = (VkImage)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (srcImageLayout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) srcImageLayout = (VkImageLayout)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (dstImage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstImage = (VkImage)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (dstImageLayout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstImageLayout = (VkImageLayout)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (regionCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) regionCount = (uint32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());

    decltype(auto) pRegions = (VkImageBlit const*)GetAddress(env, info_[6]);

    if (!info_[7].IsBigInt() && !info_[7].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 7 argument (filter)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) filter = (VkFilter)(info_[7].IsBigInt() ? info_[7].As<Napi::BigInt>().Uint64Value(&lossless) : info_[7].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBlitImage command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBlitImage)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    srcImage: " << (uint64_t)(srcImage) << std::endl;
        std::cerr << "    srcImageLayout: " << (uint64_t)(srcImageLayout) << std::endl;
        std::cerr << "    dstImage: " << (uint64_t)(dstImage) << std::endl;
        std::cerr << "    dstImageLayout: " << (uint64_t)(dstImageLayout) << std::endl;
        std::cerr << "    regionCount: " << (uint64_t)(regionCount) << std::endl;
        std::cerr << "    pRegions: " << (uint64_t)(pRegions) << std::endl;
        std::cerr << "    filter: " << (uint64_t)(filter) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdCopyBufferToImage(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (srcBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) srcBuffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (dstImage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstImage = (VkImage)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (dstImageLayout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstImageLayout = (VkImageLayout)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (regionCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) regionCount = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    decltype(auto) pRegions = (VkBufferImageCopy const*)GetAddress(env, info_[5]);
    try {
        ::vkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyBufferToImage command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyBufferToImage)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    srcBuffer: " << (uint64_t)(srcBuffer) << std::endl;
        std::cerr << "    dstImage: " << (uint64_t)(dstImage) << std::endl;
        std::cerr << "    dstImageLayout: " << (uint64_t)(dstImageLayout) << std::endl;
        std::cerr << "    regionCount: " << (uint64_t)(regionCount) << std::endl;
        std::cerr << "    pRegions: " << (uint64_t)(pRegions) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdCopyImageToBuffer(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (srcImage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) srcImage = (VkImage)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (srcImageLayout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) srcImageLayout = (VkImageLayout)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (dstBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstBuffer = (VkBuffer)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (regionCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) regionCount = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    decltype(auto) pRegions = (VkBufferImageCopy const*)GetAddress(env, info_[5]);
    try {
        ::vkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyImageToBuffer command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyImageToBuffer)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    srcImage: " << (uint64_t)(srcImage) << std::endl;
        std::cerr << "    srcImageLayout: " << (uint64_t)(srcImageLayout) << std::endl;
        std::cerr << "    dstBuffer: " << (uint64_t)(dstBuffer) << std::endl;
        std::cerr << "    regionCount: " << (uint64_t)(regionCount) << std::endl;
        std::cerr << "    pRegions: " << (uint64_t)(pRegions) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_NV_copy_memory_indirect
static Napi::Value rawCmdCopyMemoryIndirectNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (copyBufferAddress)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) copyBufferAddress = (VkDeviceAddress)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (copyCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) copyCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (stride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stride = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdCopyMemoryIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyMemoryIndirectNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyMemoryIndirectNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    copyBufferAddress: " << (uint64_t)(copyBufferAddress) << std::endl;
        std::cerr << "    copyCount: " << (uint64_t)(copyCount) << std::endl;
        std::cerr << "    stride: " << (uint64_t)(stride) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_copy_memory_indirect
static Napi::Value rawCmdCopyMemoryToImageIndirectNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 7) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (copyBufferAddress)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) copyBufferAddress = (VkDeviceAddress)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (copyCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) copyCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (stride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stride = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (dstImage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstImage = (VkImage)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    if (!info_[5].IsBigInt() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 5 argument (dstImageLayout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstImageLayout = (VkImageLayout)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Int64Value());

    decltype(auto) pImageSubresources = (VkImageSubresourceLayers const*)GetAddress(env, info_[6]);
    try {
        ::vkCmdCopyMemoryToImageIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyMemoryToImageIndirectNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyMemoryToImageIndirectNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    copyBufferAddress: " << (uint64_t)(copyBufferAddress) << std::endl;
        std::cerr << "    copyCount: " << (uint64_t)(copyCount) << std::endl;
        std::cerr << "    stride: " << (uint64_t)(stride) << std::endl;
        std::cerr << "    dstImage: " << (uint64_t)(dstImage) << std::endl;
        std::cerr << "    dstImageLayout: " << (uint64_t)(dstImageLayout) << std::endl;
        std::cerr << "    pImageSubresources: " << (uint64_t)(pImageSubresources) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
static Napi::Value rawCmdUpdateBuffer(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (dstBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstBuffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (dstOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstOffset = (VkDeviceSize)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (dataSize)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dataSize = (VkDeviceSize)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    decltype(auto) pData = (void const*)GetAddress(env, info_[4]);
    try {
        ::vkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdUpdateBuffer command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdUpdateBuffer)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    dstBuffer: " << (uint64_t)(dstBuffer) << std::endl;
        std::cerr << "    dstOffset: " << (uint64_t)(dstOffset) << std::endl;
        std::cerr << "    dataSize: " << (uint64_t)(dataSize) << std::endl;
        std::cerr << "    pData: " << (uint64_t)(pData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdFillBuffer(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (dstBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstBuffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (dstOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstOffset = (VkDeviceSize)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (size)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) size = (VkDeviceSize)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (data)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) data = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdFillBuffer command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdFillBuffer)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    dstBuffer: " << (uint64_t)(dstBuffer) << std::endl;
        std::cerr << "    dstOffset: " << (uint64_t)(dstOffset) << std::endl;
        std::cerr << "    size: " << (uint64_t)(size) << std::endl;
        std::cerr << "    data: " << (uint64_t)(data) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdClearColorImage(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (image)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) image = (VkImage)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (imageLayout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) imageLayout = (VkImageLayout)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    decltype(auto) pColor = (VkClearColorValue const*)GetAddress(env, info_[3]);

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (rangeCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) rangeCount = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    decltype(auto) pRanges = (VkImageSubresourceRange const*)GetAddress(env, info_[5]);
    try {
        ::vkCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdClearColorImage command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdClearColorImage)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    image: " << (uint64_t)(image) << std::endl;
        std::cerr << "    imageLayout: " << (uint64_t)(imageLayout) << std::endl;
        std::cerr << "    pColor: " << (uint64_t)(pColor) << std::endl;
        std::cerr << "    rangeCount: " << (uint64_t)(rangeCount) << std::endl;
        std::cerr << "    pRanges: " << (uint64_t)(pRanges) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdClearDepthStencilImage(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (image)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) image = (VkImage)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (imageLayout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) imageLayout = (VkImageLayout)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    decltype(auto) pDepthStencil = (VkClearDepthStencilValue const*)GetAddress(env, info_[3]);

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (rangeCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) rangeCount = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    decltype(auto) pRanges = (VkImageSubresourceRange const*)GetAddress(env, info_[5]);
    try {
        ::vkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdClearDepthStencilImage command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdClearDepthStencilImage)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    image: " << (uint64_t)(image) << std::endl;
        std::cerr << "    imageLayout: " << (uint64_t)(imageLayout) << std::endl;
        std::cerr << "    pDepthStencil: " << (uint64_t)(pDepthStencil) << std::endl;
        std::cerr << "    rangeCount: " << (uint64_t)(rangeCount) << std::endl;
        std::cerr << "    pRanges: " << (uint64_t)(pRanges) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdClearAttachments(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (attachmentCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) attachmentCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pAttachments = (VkClearAttachment const*)GetAddress(env, info_[2]);

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (rectCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) rectCount = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    decltype(auto) pRects = (VkClearRect const*)GetAddress(env, info_[4]);
    try {
        ::vkCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdClearAttachments command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdClearAttachments)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    attachmentCount: " << (uint64_t)(attachmentCount) << std::endl;
        std::cerr << "    pAttachments: " << (uint64_t)(pAttachments) << std::endl;
        std::cerr << "    rectCount: " << (uint64_t)(rectCount) << std::endl;
        std::cerr << "    pRects: " << (uint64_t)(pRects) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdResolveImage(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 7) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (srcImage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) srcImage = (VkImage)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (srcImageLayout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) srcImageLayout = (VkImageLayout)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (dstImage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstImage = (VkImage)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (dstImageLayout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstImageLayout = (VkImageLayout)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (regionCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) regionCount = (uint32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());

    decltype(auto) pRegions = (VkImageResolve const*)GetAddress(env, info_[6]);
    try {
        ::vkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdResolveImage command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdResolveImage)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    srcImage: " << (uint64_t)(srcImage) << std::endl;
        std::cerr << "    srcImageLayout: " << (uint64_t)(srcImageLayout) << std::endl;
        std::cerr << "    dstImage: " << (uint64_t)(dstImage) << std::endl;
        std::cerr << "    dstImageLayout: " << (uint64_t)(dstImageLayout) << std::endl;
        std::cerr << "    regionCount: " << (uint64_t)(regionCount) << std::endl;
        std::cerr << "    pRegions: " << (uint64_t)(pRegions) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetEvent(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (event)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) event = (VkEvent)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (stageMask)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stageMask = (VkPipelineStageFlags)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetEvent(commandBuffer, event, stageMask);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetEvent command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetEvent)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    event: " << (uint64_t)(event) << std::endl;
        std::cerr << "    stageMask: " << (uint64_t)(stageMask) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdResetEvent(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (event)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) event = (VkEvent)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (stageMask)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stageMask = (VkPipelineStageFlags)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdResetEvent(commandBuffer, event, stageMask);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdResetEvent command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdResetEvent)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    event: " << (uint64_t)(event) << std::endl;
        std::cerr << "    stageMask: " << (uint64_t)(stageMask) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdWaitEvents(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 11) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (eventCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) eventCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pEvents = (VkEvent const*)GetAddress(env, info_[2]);

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (srcStageMask)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) srcStageMask = (VkPipelineStageFlags)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (dstStageMask)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstStageMask = (VkPipelineStageFlags)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (memoryBarrierCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) memoryBarrierCount = (uint32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());

    decltype(auto) pMemoryBarriers = (VkMemoryBarrier const*)GetAddress(env, info_[6]);

    if (!info_[7].IsNumber() && !info_[7].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 7 argument (bufferMemoryBarrierCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) bufferMemoryBarrierCount = (uint32_t)(info_[7].IsBigInt() ? info_[7].As<Napi::BigInt>().Uint64Value(&lossless) : info_[7].As<Napi::Number>().Uint32Value());

    decltype(auto) pBufferMemoryBarriers = (VkBufferMemoryBarrier const*)GetAddress(env, info_[8]);

    if (!info_[9].IsNumber() && !info_[9].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 9 argument (imageMemoryBarrierCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) imageMemoryBarrierCount = (uint32_t)(info_[9].IsBigInt() ? info_[9].As<Napi::BigInt>().Uint64Value(&lossless) : info_[9].As<Napi::Number>().Uint32Value());

    decltype(auto) pImageMemoryBarriers = (VkImageMemoryBarrier const*)GetAddress(env, info_[10]);
    try {
        ::vkCmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdWaitEvents command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdWaitEvents)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    eventCount: " << (uint64_t)(eventCount) << std::endl;
        std::cerr << "    pEvents: " << (uint64_t)(pEvents) << std::endl;
        std::cerr << "    srcStageMask: " << (uint64_t)(srcStageMask) << std::endl;
        std::cerr << "    dstStageMask: " << (uint64_t)(dstStageMask) << std::endl;
        std::cerr << "    memoryBarrierCount: " << (uint64_t)(memoryBarrierCount) << std::endl;
        std::cerr << "    pMemoryBarriers: " << (uint64_t)(pMemoryBarriers) << std::endl;
        std::cerr << "    bufferMemoryBarrierCount: " << (uint64_t)(bufferMemoryBarrierCount) << std::endl;
        std::cerr << "    pBufferMemoryBarriers: " << (uint64_t)(pBufferMemoryBarriers) << std::endl;
        std::cerr << "    imageMemoryBarrierCount: " << (uint64_t)(imageMemoryBarrierCount) << std::endl;
        std::cerr << "    pImageMemoryBarriers: " << (uint64_t)(pImageMemoryBarriers) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdPipelineBarrier(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 10) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (srcStageMask)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) srcStageMask = (VkPipelineStageFlags)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (dstStageMask)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstStageMask = (VkPipelineStageFlags)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (dependencyFlags)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dependencyFlags = (VkDependencyFlags)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (memoryBarrierCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) memoryBarrierCount = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    decltype(auto) pMemoryBarriers = (VkMemoryBarrier const*)GetAddress(env, info_[5]);

    if (!info_[6].IsNumber() && !info_[6].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 6 argument (bufferMemoryBarrierCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) bufferMemoryBarrierCount = (uint32_t)(info_[6].IsBigInt() ? info_[6].As<Napi::BigInt>().Uint64Value(&lossless) : info_[6].As<Napi::Number>().Uint32Value());

    decltype(auto) pBufferMemoryBarriers = (VkBufferMemoryBarrier const*)GetAddress(env, info_[7]);

    if (!info_[8].IsNumber() && !info_[8].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 8 argument (imageMemoryBarrierCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) imageMemoryBarrierCount = (uint32_t)(info_[8].IsBigInt() ? info_[8].As<Napi::BigInt>().Uint64Value(&lossless) : info_[8].As<Napi::Number>().Uint32Value());

    decltype(auto) pImageMemoryBarriers = (VkImageMemoryBarrier const*)GetAddress(env, info_[9]);
    try {
        ::vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdPipelineBarrier command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdPipelineBarrier)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    srcStageMask: " << (uint64_t)(srcStageMask) << std::endl;
        std::cerr << "    dstStageMask: " << (uint64_t)(dstStageMask) << std::endl;
        std::cerr << "    dependencyFlags: " << (uint64_t)(dependencyFlags) << std::endl;
        std::cerr << "    memoryBarrierCount: " << (uint64_t)(memoryBarrierCount) << std::endl;
        std::cerr << "    pMemoryBarriers: " << (uint64_t)(pMemoryBarriers) << std::endl;
        std::cerr << "    bufferMemoryBarrierCount: " << (uint64_t)(bufferMemoryBarrierCount) << std::endl;
        std::cerr << "    pBufferMemoryBarriers: " << (uint64_t)(pBufferMemoryBarriers) << std::endl;
        std::cerr << "    imageMemoryBarrierCount: " << (uint64_t)(imageMemoryBarrierCount) << std::endl;
        std::cerr << "    pImageMemoryBarriers: " << (uint64_t)(pImageMemoryBarriers) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdBeginQuery(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (queryPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryPool = (VkQueryPool)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (query)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) query = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (flags)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) flags = (VkQueryControlFlags)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdBeginQuery(commandBuffer, queryPool, query, flags);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBeginQuery command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBeginQuery)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    queryPool: " << (uint64_t)(queryPool) << std::endl;
        std::cerr << "    query: " << (uint64_t)(query) << std::endl;
        std::cerr << "    flags: " << (uint64_t)(flags) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdEndQuery(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (queryPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryPool = (VkQueryPool)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (query)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) query = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdEndQuery(commandBuffer, queryPool, query);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdEndQuery command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdEndQuery)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    queryPool: " << (uint64_t)(queryPool) << std::endl;
        std::cerr << "    query: " << (uint64_t)(query) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_EXT_conditional_rendering
static Napi::Value rawCmdBeginConditionalRenderingEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pConditionalRenderingBegin = (VkConditionalRenderingBeginInfoEXT const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBeginConditionalRenderingEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBeginConditionalRenderingEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pConditionalRenderingBegin: " << (uint64_t)(pConditionalRenderingBegin) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_conditional_rendering
static Napi::Value rawCmdEndConditionalRenderingEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 1) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdEndConditionalRenderingEXT(commandBuffer);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdEndConditionalRenderingEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdEndConditionalRenderingEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
static Napi::Value rawCmdResetQueryPool(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (queryPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryPool = (VkQueryPool)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (firstQuery)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstQuery = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (queryCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryCount = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdResetQueryPool command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdResetQueryPool)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    queryPool: " << (uint64_t)(queryPool) << std::endl;
        std::cerr << "    firstQuery: " << (uint64_t)(firstQuery) << std::endl;
        std::cerr << "    queryCount: " << (uint64_t)(queryCount) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdWriteTimestamp(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (pipelineStage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipelineStage = (VkPipelineStageFlagBits)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (queryPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryPool = (VkQueryPool)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (query)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) query = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdWriteTimestamp command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdWriteTimestamp)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pipelineStage: " << (uint64_t)(pipelineStage) << std::endl;
        std::cerr << "    queryPool: " << (uint64_t)(queryPool) << std::endl;
        std::cerr << "    query: " << (uint64_t)(query) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdCopyQueryPoolResults(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 8) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (queryPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryPool = (VkQueryPool)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (firstQuery)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstQuery = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (queryCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryCount = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (dstBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstBuffer = (VkBuffer)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    if (!info_[5].IsBigInt() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 5 argument (dstOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstOffset = (VkDeviceSize)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Int64Value());

    if (!info_[6].IsBigInt() && !info_[6].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 6 argument (stride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stride = (VkDeviceSize)(info_[6].IsBigInt() ? info_[6].As<Napi::BigInt>().Uint64Value(&lossless) : info_[6].As<Napi::Number>().Int64Value());

    if (!info_[7].IsNumber() && !info_[7].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 7 argument (flags)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) flags = (VkQueryResultFlags)(info_[7].IsBigInt() ? info_[7].As<Napi::BigInt>().Uint64Value(&lossless) : info_[7].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyQueryPoolResults command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyQueryPoolResults)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    queryPool: " << (uint64_t)(queryPool) << std::endl;
        std::cerr << "    firstQuery: " << (uint64_t)(firstQuery) << std::endl;
        std::cerr << "    queryCount: " << (uint64_t)(queryCount) << std::endl;
        std::cerr << "    dstBuffer: " << (uint64_t)(dstBuffer) << std::endl;
        std::cerr << "    dstOffset: " << (uint64_t)(dstOffset) << std::endl;
        std::cerr << "    stride: " << (uint64_t)(stride) << std::endl;
        std::cerr << "    flags: " << (uint64_t)(flags) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdPushConstants(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (layout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) layout = (VkPipelineLayout)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (stageFlags)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stageFlags = (VkShaderStageFlags)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (offset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) offset = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (size)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) size = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    decltype(auto) pValues = (void const*)GetAddress(env, info_[5]);
    try {
        ::vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdPushConstants command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdPushConstants)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    layout: " << (uint64_t)(layout) << std::endl;
        std::cerr << "    stageFlags: " << (uint64_t)(stageFlags) << std::endl;
        std::cerr << "    offset: " << (uint64_t)(offset) << std::endl;
        std::cerr << "    size: " << (uint64_t)(size) << std::endl;
        std::cerr << "    pValues: " << (uint64_t)(pValues) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdBeginRenderPass(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pRenderPassBegin = (VkRenderPassBeginInfo const*)GetAddress(env, info_[1]);

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (contents)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) contents = (VkSubpassContents)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBeginRenderPass command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBeginRenderPass)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pRenderPassBegin: " << (uint64_t)(pRenderPassBegin) << std::endl;
        std::cerr << "    contents: " << (uint64_t)(contents) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdNextSubpass(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (contents)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) contents = (VkSubpassContents)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdNextSubpass(commandBuffer, contents);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdNextSubpass command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdNextSubpass)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    contents: " << (uint64_t)(contents) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdEndRenderPass(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 1) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdEndRenderPass(commandBuffer);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdEndRenderPass command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdEndRenderPass)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdExecuteCommands(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (commandBufferCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBufferCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pCommandBuffers = (VkCommandBuffer const*)GetAddress(env, info_[2]);
    try {
        ::vkCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdExecuteCommands command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdExecuteCommands)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    commandBufferCount: " << (uint64_t)(commandBufferCount) << std::endl;
        std::cerr << "    pCommandBuffers: " << (uint64_t)(pCommandBuffers) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_KHR_android_surface
static Napi::Value rawCreateAndroidSurfaceKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkAndroidSurfaceCreateInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSurface = (VkSurfaceKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateAndroidSurfaceKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateAndroidSurfaceKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSurface: " << (uint64_t)(pSurface) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_display
static Napi::Value rawGetPhysicalDeviceDisplayPropertiesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pPropertyCount = (uint32_t*)GetAddress(env, info_[1]);

    decltype(auto) pProperties = (VkDisplayPropertiesKHR*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceDisplayPropertiesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceDisplayPropertiesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pPropertyCount: " << (uint64_t)(pPropertyCount) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_display
static Napi::Value rawGetPhysicalDeviceDisplayPlanePropertiesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pPropertyCount = (uint32_t*)GetAddress(env, info_[1]);

    decltype(auto) pProperties = (VkDisplayPlanePropertiesKHR*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceDisplayPlanePropertiesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceDisplayPlanePropertiesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pPropertyCount: " << (uint64_t)(pPropertyCount) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_display
static Napi::Value rawGetDisplayPlaneSupportedDisplaysKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (planeIndex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) planeIndex = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pDisplayCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pDisplays = (VkDisplayKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDisplayPlaneSupportedDisplaysKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDisplayPlaneSupportedDisplaysKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    planeIndex: " << (uint64_t)(planeIndex) << std::endl;
        std::cerr << "    pDisplayCount: " << (uint64_t)(pDisplayCount) << std::endl;
        std::cerr << "    pDisplays: " << (uint64_t)(pDisplays) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_display
static Napi::Value rawGetDisplayModePropertiesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (display)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) display = (VkDisplayKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pPropertyCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pProperties = (VkDisplayModePropertiesKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDisplayModePropertiesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDisplayModePropertiesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    display: " << (uint64_t)(display) << std::endl;
        std::cerr << "    pPropertyCount: " << (uint64_t)(pPropertyCount) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_display
static Napi::Value rawCreateDisplayModeKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (display)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) display = (VkDisplayKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkDisplayModeCreateInfoKHR const*)GetAddress(env, info_[2]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[3]);

    decltype(auto) pMode = (VkDisplayModeKHR*)GetAddress(env, info_[4]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateDisplayModeKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateDisplayModeKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    display: " << (uint64_t)(display) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pMode: " << (uint64_t)(pMode) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_display
static Napi::Value rawGetDisplayPlaneCapabilitiesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (mode)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) mode = (VkDisplayModeKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (planeIndex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) planeIndex = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pCapabilities = (VkDisplayPlaneCapabilitiesKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDisplayPlaneCapabilitiesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDisplayPlaneCapabilitiesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    mode: " << (uint64_t)(mode) << std::endl;
        std::cerr << "    planeIndex: " << (uint64_t)(planeIndex) << std::endl;
        std::cerr << "    pCapabilities: " << (uint64_t)(pCapabilities) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_display
static Napi::Value rawCreateDisplayPlaneSurfaceKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkDisplaySurfaceCreateInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSurface = (VkSurfaceKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateDisplayPlaneSurfaceKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateDisplayPlaneSurfaceKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSurface: " << (uint64_t)(pSurface) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_display_swapchain
static Napi::Value rawCreateSharedSwapchainsKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (swapchainCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) swapchainCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pCreateInfos = (VkSwapchainCreateInfoKHR const*)GetAddress(env, info_[2]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[3]);

    decltype(auto) pSwapchains = (VkSwapchainKHR*)GetAddress(env, info_[4]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateSharedSwapchainsKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateSharedSwapchainsKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    swapchainCount: " << (uint64_t)(swapchainCount) << std::endl;
        std::cerr << "    pCreateInfos: " << (uint64_t)(pCreateInfos) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSwapchains: " << (uint64_t)(pSwapchains) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_surface
static Napi::Value rawDestroySurfaceKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (surface)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) surface = (VkSurfaceKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroySurfaceKHR(instance, surface, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroySurfaceKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroySurfaceKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    surface: " << (uint64_t)(surface) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_surface
static Napi::Value rawGetPhysicalDeviceSurfaceSupportKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (queueFamilyIndex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queueFamilyIndex = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (surface)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) surface = (VkSurfaceKHR)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    decltype(auto) pSupported = (VkBool32*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceSurfaceSupportKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceSurfaceSupportKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    queueFamilyIndex: " << (uint64_t)(queueFamilyIndex) << std::endl;
        std::cerr << "    surface: " << (uint64_t)(surface) << std::endl;
        std::cerr << "    pSupported: " << (uint64_t)(pSupported) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_surface
static Napi::Value rawGetPhysicalDeviceSurfaceCapabilitiesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (surface)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) surface = (VkSurfaceKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pSurfaceCapabilities = (VkSurfaceCapabilitiesKHR*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceSurfaceCapabilitiesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceSurfaceCapabilitiesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    surface: " << (uint64_t)(surface) << std::endl;
        std::cerr << "    pSurfaceCapabilities: " << (uint64_t)(pSurfaceCapabilities) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_surface
static Napi::Value rawGetPhysicalDeviceSurfaceFormatsKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (surface)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) surface = (VkSurfaceKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pSurfaceFormatCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pSurfaceFormats = (VkSurfaceFormatKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceSurfaceFormatsKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceSurfaceFormatsKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    surface: " << (uint64_t)(surface) << std::endl;
        std::cerr << "    pSurfaceFormatCount: " << (uint64_t)(pSurfaceFormatCount) << std::endl;
        std::cerr << "    pSurfaceFormats: " << (uint64_t)(pSurfaceFormats) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_surface
static Napi::Value rawGetPhysicalDeviceSurfacePresentModesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (surface)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) surface = (VkSurfaceKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pPresentModeCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pPresentModes = (VkPresentModeKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceSurfacePresentModesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceSurfacePresentModesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    surface: " << (uint64_t)(surface) << std::endl;
        std::cerr << "    pPresentModeCount: " << (uint64_t)(pPresentModeCount) << std::endl;
        std::cerr << "    pPresentModes: " << (uint64_t)(pPresentModes) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_swapchain
static Napi::Value rawCreateSwapchainKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkSwapchainCreateInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSwapchain = (VkSwapchainKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateSwapchainKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateSwapchainKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSwapchain: " << (uint64_t)(pSwapchain) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_swapchain
static Napi::Value rawDestroySwapchainKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (swapchain)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) swapchain = (VkSwapchainKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroySwapchainKHR(device, swapchain, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroySwapchainKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroySwapchainKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    swapchain: " << (uint64_t)(swapchain) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_swapchain
static Napi::Value rawGetSwapchainImagesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (swapchain)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) swapchain = (VkSwapchainKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pSwapchainImageCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pSwapchainImages = (VkImage*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetSwapchainImagesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetSwapchainImagesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    swapchain: " << (uint64_t)(swapchain) << std::endl;
        std::cerr << "    pSwapchainImageCount: " << (uint64_t)(pSwapchainImageCount) << std::endl;
        std::cerr << "    pSwapchainImages: " << (uint64_t)(pSwapchainImages) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_swapchain
static Napi::Value rawAcquireNextImageKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (swapchain)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) swapchain = (VkSwapchainKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (timeout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) timeout = (uint64_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (semaphore)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) semaphore = (VkSemaphore)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (fence)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) fence = (VkFence)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    decltype(auto) pImageIndex = (uint32_t*)GetAddress(env, info_[5]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkAcquireNextImageKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkAcquireNextImageKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    swapchain: " << (uint64_t)(swapchain) << std::endl;
        std::cerr << "    timeout: " << (uint64_t)(timeout) << std::endl;
        std::cerr << "    semaphore: " << (uint64_t)(semaphore) << std::endl;
        std::cerr << "    fence: " << (uint64_t)(fence) << std::endl;
        std::cerr << "    pImageIndex: " << (uint64_t)(pImageIndex) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_swapchain
static Napi::Value rawQueuePresentKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (queue)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queue = (VkQueue)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pPresentInfo = (VkPresentInfoKHR const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkQueuePresentKHR(queue, pPresentInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkQueuePresentKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkQueuePresentKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    queue: " << (uint64_t)(queue) << std::endl;
        std::cerr << "    pPresentInfo: " << (uint64_t)(pPresentInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NN_vi_surface
static Napi::Value rawCreateViSurfaceNN(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkViSurfaceCreateInfoNN const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSurface = (VkSurfaceKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateViSurfaceNN command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateViSurfaceNN)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSurface: " << (uint64_t)(pSurface) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_wayland_surface
static Napi::Value rawCreateWaylandSurfaceKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkWaylandSurfaceCreateInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSurface = (VkSurfaceKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateWaylandSurfaceKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateWaylandSurfaceKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSurface: " << (uint64_t)(pSurface) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_wayland_surface
static Napi::Value rawGetPhysicalDeviceWaylandPresentationSupportKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (queueFamilyIndex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queueFamilyIndex = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) display = (wl_display*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceWaylandPresentationSupportKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceWaylandPresentationSupportKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    queueFamilyIndex: " << (uint64_t)(queueFamilyIndex) << std::endl;
        std::cerr << "    display: " << (uint64_t)(display) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_win32_surface
static Napi::Value rawCreateWin32SurfaceKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkWin32SurfaceCreateInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSurface = (VkSurfaceKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateWin32SurfaceKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateWin32SurfaceKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSurface: " << (uint64_t)(pSurface) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_win32_surface
static Napi::Value rawGetPhysicalDeviceWin32PresentationSupportKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (queueFamilyIndex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queueFamilyIndex = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceWin32PresentationSupportKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceWin32PresentationSupportKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    queueFamilyIndex: " << (uint64_t)(queueFamilyIndex) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_xlib_surface
static Napi::Value rawCreateXlibSurfaceKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkXlibSurfaceCreateInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSurface = (VkSurfaceKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateXlibSurfaceKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateXlibSurfaceKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSurface: " << (uint64_t)(pSurface) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_xlib_surface
static Napi::Value rawGetPhysicalDeviceXlibPresentationSupportKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (queueFamilyIndex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queueFamilyIndex = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) dpy = (Display*)GetAddress(env, info_[2]);

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (visualID)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) visualID = (VisualID)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceXlibPresentationSupportKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceXlibPresentationSupportKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    queueFamilyIndex: " << (uint64_t)(queueFamilyIndex) << std::endl;
        std::cerr << "    dpy: " << (uint64_t)(dpy) << std::endl;
        std::cerr << "    visualID: " << (uint64_t)(visualID) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_xcb_surface
static Napi::Value rawCreateXcbSurfaceKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkXcbSurfaceCreateInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSurface = (VkSurfaceKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateXcbSurfaceKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateXcbSurfaceKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSurface: " << (uint64_t)(pSurface) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_xcb_surface
static Napi::Value rawGetPhysicalDeviceXcbPresentationSupportKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (queueFamilyIndex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queueFamilyIndex = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) connection = (xcb_connection_t*)GetAddress(env, info_[2]);

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (visual_id)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) visual_id = (xcb_visualid_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceXcbPresentationSupportKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceXcbPresentationSupportKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    queueFamilyIndex: " << (uint64_t)(queueFamilyIndex) << std::endl;
        std::cerr << "    connection: " << (uint64_t)(connection) << std::endl;
        std::cerr << "    visual_id: " << (uint64_t)(visual_id) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_directfb_surface
static Napi::Value rawCreateDirectFBSurfaceEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkDirectFBSurfaceCreateInfoEXT const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSurface = (VkSurfaceKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateDirectFBSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateDirectFBSurfaceEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateDirectFBSurfaceEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSurface: " << (uint64_t)(pSurface) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_directfb_surface
static Napi::Value rawGetPhysicalDeviceDirectFBPresentationSupportEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (queueFamilyIndex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queueFamilyIndex = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) dfb = (IDirectFB*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceDirectFBPresentationSupportEXT(physicalDevice, queueFamilyIndex, dfb);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceDirectFBPresentationSupportEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceDirectFBPresentationSupportEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    queueFamilyIndex: " << (uint64_t)(queueFamilyIndex) << std::endl;
        std::cerr << "    dfb: " << (uint64_t)(dfb) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_FUCHSIA_imagepipe_surface
static Napi::Value rawCreateImagePipeSurfaceFUCHSIA(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkImagePipeSurfaceCreateInfoFUCHSIA const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSurface = (VkSurfaceKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateImagePipeSurfaceFUCHSIA(instance, pCreateInfo, pAllocator, pSurface);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateImagePipeSurfaceFUCHSIA command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateImagePipeSurfaceFUCHSIA)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSurface: " << (uint64_t)(pSurface) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_GGP_stream_descriptor_surface
static Napi::Value rawCreateStreamDescriptorSurfaceGGP(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkStreamDescriptorSurfaceCreateInfoGGP const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSurface = (VkSurfaceKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateStreamDescriptorSurfaceGGP(instance, pCreateInfo, pAllocator, pSurface);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateStreamDescriptorSurfaceGGP command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateStreamDescriptorSurfaceGGP)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSurface: " << (uint64_t)(pSurface) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_QNX_screen_surface
static Napi::Value rawCreateScreenSurfaceQNX(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkScreenSurfaceCreateInfoQNX const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSurface = (VkSurfaceKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateScreenSurfaceQNX(instance, pCreateInfo, pAllocator, pSurface);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateScreenSurfaceQNX command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateScreenSurfaceQNX)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSurface: " << (uint64_t)(pSurface) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_QNX_screen_surface
static Napi::Value rawGetPhysicalDeviceScreenPresentationSupportQNX(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (queueFamilyIndex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queueFamilyIndex = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) window = (_screen_window*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceScreenPresentationSupportQNX(physicalDevice, queueFamilyIndex, window);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceScreenPresentationSupportQNX command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceScreenPresentationSupportQNX)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    queueFamilyIndex: " << (uint64_t)(queueFamilyIndex) << std::endl;
        std::cerr << "    window: " << (uint64_t)(window) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_debug_report
static Napi::Value rawCreateDebugReportCallbackEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkDebugReportCallbackCreateInfoEXT const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pCallback = (VkDebugReportCallbackEXT*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateDebugReportCallbackEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateDebugReportCallbackEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pCallback: " << (uint64_t)(pCallback) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_debug_report
static Napi::Value rawDestroyDebugReportCallbackEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (callback)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) callback = (VkDebugReportCallbackEXT)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyDebugReportCallbackEXT(instance, callback, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyDebugReportCallbackEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyDebugReportCallbackEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    callback: " << (uint64_t)(callback) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_debug_report
static Napi::Value rawDebugReportMessageEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 8) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (flags)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) flags = (VkDebugReportFlagsEXT)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (objectType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) objectType = (VkDebugReportObjectTypeEXT)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (object)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) object = (uint64_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (location)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) location = (size_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (messageCode)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) messageCode = (int32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Int64Value(&lossless) : info_[5].As<Napi::Number>().Int32Value());

    decltype(auto) pLayerPrefix = (char const*)GetAddress(env, info_[6]);

    decltype(auto) pMessage = (char const*)GetAddress(env, info_[7]);
    try {
        ::vkDebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDebugReportMessageEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDebugReportMessageEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    flags: " << (uint64_t)(flags) << std::endl;
        std::cerr << "    objectType: " << (uint64_t)(objectType) << std::endl;
        std::cerr << "    object: " << (uint64_t)(object) << std::endl;
        std::cerr << "    location: " << (uint64_t)(location) << std::endl;
        std::cerr << "    messageCode: " << (uint64_t)(messageCode) << std::endl;
        std::cerr << "    pLayerPrefix: " << (uint64_t)(pLayerPrefix) << std::endl;
        std::cerr << "    pMessage: " << (uint64_t)(pMessage) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_debug_marker
static Napi::Value rawDebugMarkerSetObjectNameEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pNameInfo = (VkDebugMarkerObjectNameInfoEXT const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkDebugMarkerSetObjectNameEXT(device, pNameInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDebugMarkerSetObjectNameEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDebugMarkerSetObjectNameEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pNameInfo: " << (uint64_t)(pNameInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_debug_marker
static Napi::Value rawDebugMarkerSetObjectTagEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pTagInfo = (VkDebugMarkerObjectTagInfoEXT const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkDebugMarkerSetObjectTagEXT(device, pTagInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDebugMarkerSetObjectTagEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDebugMarkerSetObjectTagEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pTagInfo: " << (uint64_t)(pTagInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_debug_marker
static Napi::Value rawCmdDebugMarkerBeginEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pMarkerInfo = (VkDebugMarkerMarkerInfoEXT const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDebugMarkerBeginEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDebugMarkerBeginEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pMarkerInfo: " << (uint64_t)(pMarkerInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_debug_marker
static Napi::Value rawCmdDebugMarkerEndEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 1) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdDebugMarkerEndEXT(commandBuffer);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDebugMarkerEndEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDebugMarkerEndEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_debug_marker
static Napi::Value rawCmdDebugMarkerInsertEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pMarkerInfo = (VkDebugMarkerMarkerInfoEXT const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDebugMarkerInsertEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDebugMarkerInsertEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pMarkerInfo: " << (uint64_t)(pMarkerInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_external_memory_capabilities
static Napi::Value rawGetPhysicalDeviceExternalImageFormatPropertiesNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 8) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (format)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) format = (VkFormat)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (type)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) type = (VkImageType)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (tiling)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) tiling = (VkImageTiling)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (usage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) usage = (VkImageUsageFlags)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (flags)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) flags = (VkImageCreateFlags)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());

    if (!info_[6].IsNumber() && !info_[6].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 6 argument (externalHandleType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) externalHandleType = (VkExternalMemoryHandleTypeFlagsNV)(info_[6].IsBigInt() ? info_[6].As<Napi::BigInt>().Uint64Value(&lossless) : info_[6].As<Napi::Number>().Uint32Value());

    decltype(auto) pExternalImageFormatProperties = (VkExternalImageFormatPropertiesNV*)GetAddress(env, info_[7]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceExternalImageFormatPropertiesNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceExternalImageFormatPropertiesNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    format: " << (uint64_t)(format) << std::endl;
        std::cerr << "    type: " << (uint64_t)(type) << std::endl;
        std::cerr << "    tiling: " << (uint64_t)(tiling) << std::endl;
        std::cerr << "    usage: " << (uint64_t)(usage) << std::endl;
        std::cerr << "    flags: " << (uint64_t)(flags) << std::endl;
        std::cerr << "    externalHandleType: " << (uint64_t)(externalHandleType) << std::endl;
        std::cerr << "    pExternalImageFormatProperties: " << (uint64_t)(pExternalImageFormatProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_external_memory_win32
static Napi::Value rawGetMemoryWin32HandleNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (memory)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) memory = (VkDeviceMemory)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (handleType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) handleType = (VkExternalMemoryHandleTypeFlagsNV)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pHandle = (HANDLE*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetMemoryWin32HandleNV(device, memory, handleType, pHandle);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetMemoryWin32HandleNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetMemoryWin32HandleNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    memory: " << (uint64_t)(memory) << std::endl;
        std::cerr << "    handleType: " << (uint64_t)(handleType) << std::endl;
        std::cerr << "    pHandle: " << (uint64_t)(pHandle) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_device_generated_commands
static Napi::Value rawCmdExecuteGeneratedCommandsNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (isPreprocessed)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) isPreprocessed = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pGeneratedCommandsInfo = (VkGeneratedCommandsInfoNV const*)GetAddress(env, info_[2]);
    try {
        ::vkCmdExecuteGeneratedCommandsNV(commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdExecuteGeneratedCommandsNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdExecuteGeneratedCommandsNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    isPreprocessed: " << (uint64_t)(isPreprocessed) << std::endl;
        std::cerr << "    pGeneratedCommandsInfo: " << (uint64_t)(pGeneratedCommandsInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_device_generated_commands
static Napi::Value rawCmdPreprocessGeneratedCommandsNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pGeneratedCommandsInfo = (VkGeneratedCommandsInfoNV const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdPreprocessGeneratedCommandsNV(commandBuffer, pGeneratedCommandsInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdPreprocessGeneratedCommandsNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdPreprocessGeneratedCommandsNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pGeneratedCommandsInfo: " << (uint64_t)(pGeneratedCommandsInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_device_generated_commands
static Napi::Value rawCmdBindPipelineShaderGroupNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipelineBindPoint)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipelineBindPoint = (VkPipelineBindPoint)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (pipeline)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipeline = (VkPipeline)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (groupIndex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) groupIndex = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdBindPipelineShaderGroupNV(commandBuffer, pipelineBindPoint, pipeline, groupIndex);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBindPipelineShaderGroupNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBindPipelineShaderGroupNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pipelineBindPoint: " << (uint64_t)(pipelineBindPoint) << std::endl;
        std::cerr << "    pipeline: " << (uint64_t)(pipeline) << std::endl;
        std::cerr << "    groupIndex: " << (uint64_t)(groupIndex) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_device_generated_commands
static Napi::Value rawGetGeneratedCommandsMemoryRequirementsNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkGeneratedCommandsMemoryRequirementsInfoNV const*)GetAddress(env, info_[1]);

    decltype(auto) pMemoryRequirements = (VkMemoryRequirements2*)GetAddress(env, info_[2]);
    try {
        ::vkGetGeneratedCommandsMemoryRequirementsNV(device, pInfo, pMemoryRequirements);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetGeneratedCommandsMemoryRequirementsNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetGeneratedCommandsMemoryRequirementsNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        std::cerr << "    pMemoryRequirements: " << (uint64_t)(pMemoryRequirements) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_device_generated_commands
static Napi::Value rawCreateIndirectCommandsLayoutNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkIndirectCommandsLayoutCreateInfoNV const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pIndirectCommandsLayout = (VkIndirectCommandsLayoutNV*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateIndirectCommandsLayoutNV(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateIndirectCommandsLayoutNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateIndirectCommandsLayoutNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pIndirectCommandsLayout: " << (uint64_t)(pIndirectCommandsLayout) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_device_generated_commands
static Napi::Value rawDestroyIndirectCommandsLayoutNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (indirectCommandsLayout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) indirectCommandsLayout = (VkIndirectCommandsLayoutNV)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyIndirectCommandsLayoutNV(device, indirectCommandsLayout, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyIndirectCommandsLayoutNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyIndirectCommandsLayoutNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    indirectCommandsLayout: " << (uint64_t)(indirectCommandsLayout) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
static Napi::Value rawGetPhysicalDeviceFeatures2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pFeatures = (VkPhysicalDeviceFeatures2*)GetAddress(env, info_[1]);
    try {
        ::vkGetPhysicalDeviceFeatures2(physicalDevice, pFeatures);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceFeatures2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceFeatures2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pFeatures: " << (uint64_t)(pFeatures) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetPhysicalDeviceProperties2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pProperties = (VkPhysicalDeviceProperties2*)GetAddress(env, info_[1]);
    try {
        ::vkGetPhysicalDeviceProperties2(physicalDevice, pProperties);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceProperties2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceProperties2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetPhysicalDeviceFormatProperties2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (format)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) format = (VkFormat)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pFormatProperties = (VkFormatProperties2*)GetAddress(env, info_[2]);
    try {
        ::vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceFormatProperties2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceFormatProperties2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    format: " << (uint64_t)(format) << std::endl;
        std::cerr << "    pFormatProperties: " << (uint64_t)(pFormatProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetPhysicalDeviceImageFormatProperties2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pImageFormatInfo = (VkPhysicalDeviceImageFormatInfo2 const*)GetAddress(env, info_[1]);

    decltype(auto) pImageFormatProperties = (VkImageFormatProperties2*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceImageFormatProperties2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceImageFormatProperties2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pImageFormatInfo: " << (uint64_t)(pImageFormatInfo) << std::endl;
        std::cerr << "    pImageFormatProperties: " << (uint64_t)(pImageFormatProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawGetPhysicalDeviceQueueFamilyProperties2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pQueueFamilyPropertyCount = (uint32_t*)GetAddress(env, info_[1]);

    decltype(auto) pQueueFamilyProperties = (VkQueueFamilyProperties2*)GetAddress(env, info_[2]);
    try {
        ::vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceQueueFamilyProperties2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceQueueFamilyProperties2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pQueueFamilyPropertyCount: " << (uint64_t)(pQueueFamilyPropertyCount) << std::endl;
        std::cerr << "    pQueueFamilyProperties: " << (uint64_t)(pQueueFamilyProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetPhysicalDeviceMemoryProperties2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pMemoryProperties = (VkPhysicalDeviceMemoryProperties2*)GetAddress(env, info_[1]);
    try {
        ::vkGetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceMemoryProperties2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceMemoryProperties2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pMemoryProperties: " << (uint64_t)(pMemoryProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetPhysicalDeviceSparseImageFormatProperties2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pFormatInfo = (VkPhysicalDeviceSparseImageFormatInfo2 const*)GetAddress(env, info_[1]);

    decltype(auto) pPropertyCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pProperties = (VkSparseImageFormatProperties2*)GetAddress(env, info_[3]);
    try {
        ::vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceSparseImageFormatProperties2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceSparseImageFormatProperties2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pFormatInfo: " << (uint64_t)(pFormatInfo) << std::endl;
        std::cerr << "    pPropertyCount: " << (uint64_t)(pPropertyCount) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_KHR_push_descriptor
static Napi::Value rawCmdPushDescriptorSetKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipelineBindPoint)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipelineBindPoint = (VkPipelineBindPoint)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (layout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) layout = (VkPipelineLayout)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (set)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) set = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (descriptorWriteCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) descriptorWriteCount = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    decltype(auto) pDescriptorWrites = (VkWriteDescriptorSet const*)GetAddress(env, info_[5]);
    try {
        ::vkCmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdPushDescriptorSetKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdPushDescriptorSetKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pipelineBindPoint: " << (uint64_t)(pipelineBindPoint) << std::endl;
        std::cerr << "    layout: " << (uint64_t)(layout) << std::endl;
        std::cerr << "    set: " << (uint64_t)(set) << std::endl;
        std::cerr << "    descriptorWriteCount: " << (uint64_t)(descriptorWriteCount) << std::endl;
        std::cerr << "    pDescriptorWrites: " << (uint64_t)(pDescriptorWrites) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
static Napi::Value rawTrimCommandPool(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (commandPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandPool = (VkCommandPool)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (flags)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) flags = (VkCommandPoolTrimFlags)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());
    try {
        ::vkTrimCommandPool(device, commandPool, flags);
    } catch(std::exception e) {
        std::cerr << "Exception with vkTrimCommandPool command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkTrimCommandPool)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    commandPool: " << (uint64_t)(commandPool) << std::endl;
        std::cerr << "    flags: " << (uint64_t)(flags) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetPhysicalDeviceExternalBufferProperties(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pExternalBufferInfo = (VkPhysicalDeviceExternalBufferInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pExternalBufferProperties = (VkExternalBufferProperties*)GetAddress(env, info_[2]);
    try {
        ::vkGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceExternalBufferProperties command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceExternalBufferProperties)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pExternalBufferInfo: " << (uint64_t)(pExternalBufferInfo) << std::endl;
        std::cerr << "    pExternalBufferProperties: " << (uint64_t)(pExternalBufferProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_KHR_external_memory_win32
static Napi::Value rawGetMemoryWin32HandleKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pGetWin32HandleInfo = (VkMemoryGetWin32HandleInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pHandle = (HANDLE*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetMemoryWin32HandleKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetMemoryWin32HandleKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pGetWin32HandleInfo: " << (uint64_t)(pGetWin32HandleInfo) << std::endl;
        std::cerr << "    pHandle: " << (uint64_t)(pHandle) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_external_memory_win32
static Napi::Value rawGetMemoryWin32HandlePropertiesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (handleType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) handleType = (VkExternalMemoryHandleTypeFlagBits)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (handle)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) handle = (HANDLE)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    decltype(auto) pMemoryWin32HandleProperties = (VkMemoryWin32HandlePropertiesKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetMemoryWin32HandlePropertiesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetMemoryWin32HandlePropertiesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    handleType: " << (uint64_t)(handleType) << std::endl;
        std::cerr << "    handle: " << (uint64_t)(handle) << std::endl;
        std::cerr << "    pMemoryWin32HandleProperties: " << (uint64_t)(pMemoryWin32HandleProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_external_memory_fd
static Napi::Value rawGetMemoryFdKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pGetFdInfo = (VkMemoryGetFdInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pFd = (int*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetMemoryFdKHR(device, pGetFdInfo, pFd);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetMemoryFdKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetMemoryFdKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pGetFdInfo: " << (uint64_t)(pGetFdInfo) << std::endl;
        std::cerr << "    pFd: " << (uint64_t)(pFd) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_external_memory_fd
static Napi::Value rawGetMemoryFdPropertiesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (handleType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) handleType = (VkExternalMemoryHandleTypeFlagBits)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (fd)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) fd = (int)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    decltype(auto) pMemoryFdProperties = (VkMemoryFdPropertiesKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetMemoryFdPropertiesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetMemoryFdPropertiesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    handleType: " << (uint64_t)(handleType) << std::endl;
        std::cerr << "    fd: " << (uint64_t)(fd) << std::endl;
        std::cerr << "    pMemoryFdProperties: " << (uint64_t)(pMemoryFdProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_FUCHSIA_external_memory
static Napi::Value rawGetMemoryZirconHandleFUCHSIA(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pGetZirconHandleInfo = (VkMemoryGetZirconHandleInfoFUCHSIA const*)GetAddress(env, info_[1]);

    decltype(auto) pZirconHandle = (zx_handle_t*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetMemoryZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetMemoryZirconHandleFUCHSIA command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetMemoryZirconHandleFUCHSIA)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pGetZirconHandleInfo: " << (uint64_t)(pGetZirconHandleInfo) << std::endl;
        std::cerr << "    pZirconHandle: " << (uint64_t)(pZirconHandle) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_FUCHSIA_external_memory
static Napi::Value rawGetMemoryZirconHandlePropertiesFUCHSIA(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (handleType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) handleType = (VkExternalMemoryHandleTypeFlagBits)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (zirconHandle)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) zirconHandle = (zx_handle_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    decltype(auto) pMemoryZirconHandleProperties = (VkMemoryZirconHandlePropertiesFUCHSIA*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetMemoryZirconHandlePropertiesFUCHSIA(device, handleType, zirconHandle, pMemoryZirconHandleProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetMemoryZirconHandlePropertiesFUCHSIA command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetMemoryZirconHandlePropertiesFUCHSIA)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    handleType: " << (uint64_t)(handleType) << std::endl;
        std::cerr << "    zirconHandle: " << (uint64_t)(zirconHandle) << std::endl;
        std::cerr << "    pMemoryZirconHandleProperties: " << (uint64_t)(pMemoryZirconHandleProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_external_memory_rdma
static Napi::Value rawGetMemoryRemoteAddressNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pMemoryGetRemoteAddressInfo = (VkMemoryGetRemoteAddressInfoNV const*)GetAddress(env, info_[1]);

    decltype(auto) pAddress = (VkRemoteAddressNV*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetMemoryRemoteAddressNV(device, pMemoryGetRemoteAddressInfo, pAddress);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetMemoryRemoteAddressNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetMemoryRemoteAddressNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pMemoryGetRemoteAddressInfo: " << (uint64_t)(pMemoryGetRemoteAddressInfo) << std::endl;
        std::cerr << "    pAddress: " << (uint64_t)(pAddress) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
static Napi::Value rawGetPhysicalDeviceExternalSemaphoreProperties(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pExternalSemaphoreInfo = (VkPhysicalDeviceExternalSemaphoreInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pExternalSemaphoreProperties = (VkExternalSemaphoreProperties*)GetAddress(env, info_[2]);
    try {
        ::vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceExternalSemaphoreProperties command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceExternalSemaphoreProperties)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pExternalSemaphoreInfo: " << (uint64_t)(pExternalSemaphoreInfo) << std::endl;
        std::cerr << "    pExternalSemaphoreProperties: " << (uint64_t)(pExternalSemaphoreProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_KHR_external_semaphore_win32
static Napi::Value rawGetSemaphoreWin32HandleKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pGetWin32HandleInfo = (VkSemaphoreGetWin32HandleInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pHandle = (HANDLE*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetSemaphoreWin32HandleKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetSemaphoreWin32HandleKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pGetWin32HandleInfo: " << (uint64_t)(pGetWin32HandleInfo) << std::endl;
        std::cerr << "    pHandle: " << (uint64_t)(pHandle) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_external_semaphore_win32
static Napi::Value rawImportSemaphoreWin32HandleKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pImportSemaphoreWin32HandleInfo = (VkImportSemaphoreWin32HandleInfoKHR const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkImportSemaphoreWin32HandleKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkImportSemaphoreWin32HandleKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pImportSemaphoreWin32HandleInfo: " << (uint64_t)(pImportSemaphoreWin32HandleInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_external_semaphore_fd
static Napi::Value rawGetSemaphoreFdKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pGetFdInfo = (VkSemaphoreGetFdInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pFd = (int*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetSemaphoreFdKHR(device, pGetFdInfo, pFd);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetSemaphoreFdKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetSemaphoreFdKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pGetFdInfo: " << (uint64_t)(pGetFdInfo) << std::endl;
        std::cerr << "    pFd: " << (uint64_t)(pFd) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_external_semaphore_fd
static Napi::Value rawImportSemaphoreFdKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pImportSemaphoreFdInfo = (VkImportSemaphoreFdInfoKHR const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkImportSemaphoreFdKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkImportSemaphoreFdKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pImportSemaphoreFdInfo: " << (uint64_t)(pImportSemaphoreFdInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_FUCHSIA_external_semaphore
static Napi::Value rawGetSemaphoreZirconHandleFUCHSIA(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pGetZirconHandleInfo = (VkSemaphoreGetZirconHandleInfoFUCHSIA const*)GetAddress(env, info_[1]);

    decltype(auto) pZirconHandle = (zx_handle_t*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetSemaphoreZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetSemaphoreZirconHandleFUCHSIA command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetSemaphoreZirconHandleFUCHSIA)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pGetZirconHandleInfo: " << (uint64_t)(pGetZirconHandleInfo) << std::endl;
        std::cerr << "    pZirconHandle: " << (uint64_t)(pZirconHandle) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_FUCHSIA_external_semaphore
static Napi::Value rawImportSemaphoreZirconHandleFUCHSIA(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pImportSemaphoreZirconHandleInfo = (VkImportSemaphoreZirconHandleInfoFUCHSIA const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkImportSemaphoreZirconHandleFUCHSIA(device, pImportSemaphoreZirconHandleInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkImportSemaphoreZirconHandleFUCHSIA command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkImportSemaphoreZirconHandleFUCHSIA)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pImportSemaphoreZirconHandleInfo: " << (uint64_t)(pImportSemaphoreZirconHandleInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
static Napi::Value rawGetPhysicalDeviceExternalFenceProperties(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pExternalFenceInfo = (VkPhysicalDeviceExternalFenceInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pExternalFenceProperties = (VkExternalFenceProperties*)GetAddress(env, info_[2]);
    try {
        ::vkGetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceExternalFenceProperties command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceExternalFenceProperties)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pExternalFenceInfo: " << (uint64_t)(pExternalFenceInfo) << std::endl;
        std::cerr << "    pExternalFenceProperties: " << (uint64_t)(pExternalFenceProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_KHR_external_fence_win32
static Napi::Value rawGetFenceWin32HandleKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pGetWin32HandleInfo = (VkFenceGetWin32HandleInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pHandle = (HANDLE*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetFenceWin32HandleKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetFenceWin32HandleKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pGetWin32HandleInfo: " << (uint64_t)(pGetWin32HandleInfo) << std::endl;
        std::cerr << "    pHandle: " << (uint64_t)(pHandle) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_external_fence_win32
static Napi::Value rawImportFenceWin32HandleKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pImportFenceWin32HandleInfo = (VkImportFenceWin32HandleInfoKHR const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkImportFenceWin32HandleKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkImportFenceWin32HandleKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pImportFenceWin32HandleInfo: " << (uint64_t)(pImportFenceWin32HandleInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_external_fence_fd
static Napi::Value rawGetFenceFdKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pGetFdInfo = (VkFenceGetFdInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pFd = (int*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetFenceFdKHR(device, pGetFdInfo, pFd);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetFenceFdKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetFenceFdKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pGetFdInfo: " << (uint64_t)(pGetFdInfo) << std::endl;
        std::cerr << "    pFd: " << (uint64_t)(pFd) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_external_fence_fd
static Napi::Value rawImportFenceFdKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pImportFenceFdInfo = (VkImportFenceFdInfoKHR const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkImportFenceFdKHR(device, pImportFenceFdInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkImportFenceFdKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkImportFenceFdKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pImportFenceFdInfo: " << (uint64_t)(pImportFenceFdInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_direct_mode_display
static Napi::Value rawReleaseDisplayEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (display)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) display = (VkDisplayKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkReleaseDisplayEXT(physicalDevice, display);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkReleaseDisplayEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkReleaseDisplayEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    display: " << (uint64_t)(display) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_acquire_xlib_display
static Napi::Value rawAcquireXlibDisplayEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) dpy = (Display*)GetAddress(env, info_[1]);

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (display)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) display = (VkDisplayKHR)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkAcquireXlibDisplayEXT(physicalDevice, dpy, display);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkAcquireXlibDisplayEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkAcquireXlibDisplayEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    dpy: " << (uint64_t)(dpy) << std::endl;
        std::cerr << "    display: " << (uint64_t)(display) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_acquire_xlib_display
static Napi::Value rawGetRandROutputDisplayEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) dpy = (Display*)GetAddress(env, info_[1]);

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (rrOutput)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) rrOutput = (RROutput)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    decltype(auto) pDisplay = (VkDisplayKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetRandROutputDisplayEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetRandROutputDisplayEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    dpy: " << (uint64_t)(dpy) << std::endl;
        std::cerr << "    rrOutput: " << (uint64_t)(rrOutput) << std::endl;
        std::cerr << "    pDisplay: " << (uint64_t)(pDisplay) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_acquire_winrt_display
static Napi::Value rawAcquireWinrtDisplayNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (display)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) display = (VkDisplayKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkAcquireWinrtDisplayNV(physicalDevice, display);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkAcquireWinrtDisplayNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkAcquireWinrtDisplayNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    display: " << (uint64_t)(display) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_acquire_winrt_display
static Napi::Value rawGetWinrtDisplayNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (deviceRelativeId)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) deviceRelativeId = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pDisplay = (VkDisplayKHR*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetWinrtDisplayNV(physicalDevice, deviceRelativeId, pDisplay);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetWinrtDisplayNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetWinrtDisplayNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    deviceRelativeId: " << (uint64_t)(deviceRelativeId) << std::endl;
        std::cerr << "    pDisplay: " << (uint64_t)(pDisplay) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_display_control
static Napi::Value rawDisplayPowerControlEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (display)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) display = (VkDisplayKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pDisplayPowerInfo = (VkDisplayPowerInfoEXT const*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkDisplayPowerControlEXT(device, display, pDisplayPowerInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDisplayPowerControlEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDisplayPowerControlEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    display: " << (uint64_t)(display) << std::endl;
        std::cerr << "    pDisplayPowerInfo: " << (uint64_t)(pDisplayPowerInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_display_control
static Napi::Value rawRegisterDeviceEventEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pDeviceEventInfo = (VkDeviceEventInfoEXT const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pFence = (VkFence*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkRegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkRegisterDeviceEventEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkRegisterDeviceEventEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pDeviceEventInfo: " << (uint64_t)(pDeviceEventInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pFence: " << (uint64_t)(pFence) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_display_control
static Napi::Value rawRegisterDisplayEventEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (display)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) display = (VkDisplayKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pDisplayEventInfo = (VkDisplayEventInfoEXT const*)GetAddress(env, info_[2]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[3]);

    decltype(auto) pFence = (VkFence*)GetAddress(env, info_[4]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkRegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkRegisterDisplayEventEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkRegisterDisplayEventEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    display: " << (uint64_t)(display) << std::endl;
        std::cerr << "    pDisplayEventInfo: " << (uint64_t)(pDisplayEventInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pFence: " << (uint64_t)(pFence) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_display_control
static Napi::Value rawGetSwapchainCounterEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (swapchain)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) swapchain = (VkSwapchainKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (counter)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) counter = (VkSurfaceCounterFlagBitsEXT)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pCounterValue = (uint64_t*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetSwapchainCounterEXT(device, swapchain, counter, pCounterValue);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetSwapchainCounterEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetSwapchainCounterEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    swapchain: " << (uint64_t)(swapchain) << std::endl;
        std::cerr << "    counter: " << (uint64_t)(counter) << std::endl;
        std::cerr << "    pCounterValue: " << (uint64_t)(pCounterValue) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_display_surface_counter
static Napi::Value rawGetPhysicalDeviceSurfaceCapabilities2EXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (surface)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) surface = (VkSurfaceKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pSurfaceCapabilities = (VkSurfaceCapabilities2EXT*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceSurfaceCapabilities2EXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceSurfaceCapabilities2EXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    surface: " << (uint64_t)(surface) << std::endl;
        std::cerr << "    pSurfaceCapabilities: " << (uint64_t)(pSurfaceCapabilities) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
static Napi::Value rawEnumeratePhysicalDeviceGroups(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pPhysicalDeviceGroupCount = (uint32_t*)GetAddress(env, info_[1]);

    decltype(auto) pPhysicalDeviceGroupProperties = (VkPhysicalDeviceGroupProperties*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkEnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkEnumeratePhysicalDeviceGroups command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkEnumeratePhysicalDeviceGroups)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pPhysicalDeviceGroupCount: " << (uint64_t)(pPhysicalDeviceGroupCount) << std::endl;
        std::cerr << "    pPhysicalDeviceGroupProperties: " << (uint64_t)(pPhysicalDeviceGroupProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawGetDeviceGroupPeerMemoryFeatures(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (heapIndex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) heapIndex = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (localDeviceIndex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) localDeviceIndex = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (remoteDeviceIndex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) remoteDeviceIndex = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    decltype(auto) pPeerMemoryFeatures = (VkPeerMemoryFeatureFlags*)GetAddress(env, info_[4]);
    try {
        ::vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeviceGroupPeerMemoryFeatures command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeviceGroupPeerMemoryFeatures)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    heapIndex: " << (uint64_t)(heapIndex) << std::endl;
        std::cerr << "    localDeviceIndex: " << (uint64_t)(localDeviceIndex) << std::endl;
        std::cerr << "    remoteDeviceIndex: " << (uint64_t)(remoteDeviceIndex) << std::endl;
        std::cerr << "    pPeerMemoryFeatures: " << (uint64_t)(pPeerMemoryFeatures) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawBindBufferMemory2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (bindInfoCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) bindInfoCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pBindInfos = (VkBindBufferMemoryInfo const*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkBindBufferMemory2(device, bindInfoCount, pBindInfos);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkBindBufferMemory2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkBindBufferMemory2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    bindInfoCount: " << (uint64_t)(bindInfoCount) << std::endl;
        std::cerr << "    pBindInfos: " << (uint64_t)(pBindInfos) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawBindImageMemory2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (bindInfoCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) bindInfoCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pBindInfos = (VkBindImageMemoryInfo const*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkBindImageMemory2(device, bindInfoCount, pBindInfos);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkBindImageMemory2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkBindImageMemory2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    bindInfoCount: " << (uint64_t)(bindInfoCount) << std::endl;
        std::cerr << "    pBindInfos: " << (uint64_t)(pBindInfos) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawCmdSetDeviceMask(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (deviceMask)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) deviceMask = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetDeviceMask(commandBuffer, deviceMask);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetDeviceMask command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetDeviceMask)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    deviceMask: " << (uint64_t)(deviceMask) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_KHR_device_group
static Napi::Value rawGetDeviceGroupPresentCapabilitiesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pDeviceGroupPresentCapabilities = (VkDeviceGroupPresentCapabilitiesKHR*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetDeviceGroupPresentCapabilitiesKHR(device, pDeviceGroupPresentCapabilities);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeviceGroupPresentCapabilitiesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeviceGroupPresentCapabilitiesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pDeviceGroupPresentCapabilities: " << (uint64_t)(pDeviceGroupPresentCapabilities) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_device_group
static Napi::Value rawGetDeviceGroupSurfacePresentModesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (surface)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) surface = (VkSurfaceKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pModes = (VkDeviceGroupPresentModeFlagsKHR*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetDeviceGroupSurfacePresentModesKHR(device, surface, pModes);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeviceGroupSurfacePresentModesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeviceGroupSurfacePresentModesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    surface: " << (uint64_t)(surface) << std::endl;
        std::cerr << "    pModes: " << (uint64_t)(pModes) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_device_group
static Napi::Value rawAcquireNextImage2KHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pAcquireInfo = (VkAcquireNextImageInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pImageIndex = (uint32_t*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkAcquireNextImage2KHR(device, pAcquireInfo, pImageIndex);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkAcquireNextImage2KHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkAcquireNextImage2KHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pAcquireInfo: " << (uint64_t)(pAcquireInfo) << std::endl;
        std::cerr << "    pImageIndex: " << (uint64_t)(pImageIndex) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
static Napi::Value rawCmdDispatchBase(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 7) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (baseGroupX)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) baseGroupX = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (baseGroupY)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) baseGroupY = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (baseGroupZ)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) baseGroupZ = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (groupCountX)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) groupCountX = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (groupCountY)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) groupCountY = (uint32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());

    if (!info_[6].IsNumber() && !info_[6].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 6 argument (groupCountZ)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) groupCountZ = (uint32_t)(info_[6].IsBigInt() ? info_[6].As<Napi::BigInt>().Uint64Value(&lossless) : info_[6].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDispatchBase command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDispatchBase)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    baseGroupX: " << (uint64_t)(baseGroupX) << std::endl;
        std::cerr << "    baseGroupY: " << (uint64_t)(baseGroupY) << std::endl;
        std::cerr << "    baseGroupZ: " << (uint64_t)(baseGroupZ) << std::endl;
        std::cerr << "    groupCountX: " << (uint64_t)(groupCountX) << std::endl;
        std::cerr << "    groupCountY: " << (uint64_t)(groupCountY) << std::endl;
        std::cerr << "    groupCountZ: " << (uint64_t)(groupCountZ) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_KHR_device_group
static Napi::Value rawGetPhysicalDevicePresentRectanglesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (surface)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) surface = (VkSurfaceKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pRectCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pRects = (VkRect2D*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDevicePresentRectanglesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDevicePresentRectanglesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    surface: " << (uint64_t)(surface) << std::endl;
        std::cerr << "    pRectCount: " << (uint64_t)(pRectCount) << std::endl;
        std::cerr << "    pRects: " << (uint64_t)(pRects) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
static Napi::Value rawCreateDescriptorUpdateTemplate(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkDescriptorUpdateTemplateCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pDescriptorUpdateTemplate = (VkDescriptorUpdateTemplate*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateDescriptorUpdateTemplate command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateDescriptorUpdateTemplate)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pDescriptorUpdateTemplate: " << (uint64_t)(pDescriptorUpdateTemplate) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyDescriptorUpdateTemplate(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (descriptorUpdateTemplate)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyDescriptorUpdateTemplate command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyDescriptorUpdateTemplate)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    descriptorUpdateTemplate: " << (uint64_t)(descriptorUpdateTemplate) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawUpdateDescriptorSetWithTemplate(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (descriptorSet)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) descriptorSet = (VkDescriptorSet)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (descriptorUpdateTemplate)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    decltype(auto) pData = (void const*)GetAddress(env, info_[3]);
    try {
        ::vkUpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData);
    } catch(std::exception e) {
        std::cerr << "Exception with vkUpdateDescriptorSetWithTemplate command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkUpdateDescriptorSetWithTemplate)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    descriptorSet: " << (uint64_t)(descriptorSet) << std::endl;
        std::cerr << "    descriptorUpdateTemplate: " << (uint64_t)(descriptorUpdateTemplate) << std::endl;
        std::cerr << "    pData: " << (uint64_t)(pData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_KHR_descriptor_update_template
static Napi::Value rawCmdPushDescriptorSetWithTemplateKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (descriptorUpdateTemplate)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (layout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) layout = (VkPipelineLayout)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (set)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) set = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    decltype(auto) pData = (void const*)GetAddress(env, info_[4]);
    try {
        ::vkCmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdPushDescriptorSetWithTemplateKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdPushDescriptorSetWithTemplateKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    descriptorUpdateTemplate: " << (uint64_t)(descriptorUpdateTemplate) << std::endl;
        std::cerr << "    layout: " << (uint64_t)(layout) << std::endl;
        std::cerr << "    set: " << (uint64_t)(set) << std::endl;
        std::cerr << "    pData: " << (uint64_t)(pData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_hdr_metadata
static Napi::Value rawSetHdrMetadataEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (swapchainCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) swapchainCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pSwapchains = (VkSwapchainKHR const*)GetAddress(env, info_[2]);

    decltype(auto) pMetadata = (VkHdrMetadataEXT const*)GetAddress(env, info_[3]);
    try {
        ::vkSetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata);
    } catch(std::exception e) {
        std::cerr << "Exception with vkSetHdrMetadataEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkSetHdrMetadataEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    swapchainCount: " << (uint64_t)(swapchainCount) << std::endl;
        std::cerr << "    pSwapchains: " << (uint64_t)(pSwapchains) << std::endl;
        std::cerr << "    pMetadata: " << (uint64_t)(pMetadata) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_shared_presentable_image
static Napi::Value rawGetSwapchainStatusKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (swapchain)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) swapchain = (VkSwapchainKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetSwapchainStatusKHR(device, swapchain);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetSwapchainStatusKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetSwapchainStatusKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    swapchain: " << (uint64_t)(swapchain) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_GOOGLE_display_timing
static Napi::Value rawGetRefreshCycleDurationGOOGLE(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (swapchain)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) swapchain = (VkSwapchainKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pDisplayTimingProperties = (VkRefreshCycleDurationGOOGLE*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetRefreshCycleDurationGOOGLE command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetRefreshCycleDurationGOOGLE)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    swapchain: " << (uint64_t)(swapchain) << std::endl;
        std::cerr << "    pDisplayTimingProperties: " << (uint64_t)(pDisplayTimingProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_GOOGLE_display_timing
static Napi::Value rawGetPastPresentationTimingGOOGLE(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (swapchain)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) swapchain = (VkSwapchainKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pPresentationTimingCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pPresentationTimings = (VkPastPresentationTimingGOOGLE*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPastPresentationTimingGOOGLE command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPastPresentationTimingGOOGLE)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    swapchain: " << (uint64_t)(swapchain) << std::endl;
        std::cerr << "    pPresentationTimingCount: " << (uint64_t)(pPresentationTimingCount) << std::endl;
        std::cerr << "    pPresentationTimings: " << (uint64_t)(pPresentationTimings) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_MVK_ios_surface
static Napi::Value rawCreateIOSSurfaceMVK(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkIOSSurfaceCreateInfoMVK const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSurface = (VkSurfaceKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateIOSSurfaceMVK command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateIOSSurfaceMVK)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSurface: " << (uint64_t)(pSurface) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_MVK_macos_surface
static Napi::Value rawCreateMacOSSurfaceMVK(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkMacOSSurfaceCreateInfoMVK const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSurface = (VkSurfaceKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateMacOSSurfaceMVK command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateMacOSSurfaceMVK)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSurface: " << (uint64_t)(pSurface) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_metal_surface
static Napi::Value rawCreateMetalSurfaceEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkMetalSurfaceCreateInfoEXT const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSurface = (VkSurfaceKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateMetalSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateMetalSurfaceEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateMetalSurfaceEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSurface: " << (uint64_t)(pSurface) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_clip_space_w_scaling
static Napi::Value rawCmdSetViewportWScalingNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (firstViewport)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstViewport = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (viewportCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) viewportCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pViewportWScalings = (VkViewportWScalingNV const*)GetAddress(env, info_[3]);
    try {
        ::vkCmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetViewportWScalingNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetViewportWScalingNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    firstViewport: " << (uint64_t)(firstViewport) << std::endl;
        std::cerr << "    viewportCount: " << (uint64_t)(viewportCount) << std::endl;
        std::cerr << "    pViewportWScalings: " << (uint64_t)(pViewportWScalings) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_discard_rectangles
static Napi::Value rawCmdSetDiscardRectangleEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (firstDiscardRectangle)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstDiscardRectangle = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (discardRectangleCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) discardRectangleCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pDiscardRectangles = (VkRect2D const*)GetAddress(env, info_[3]);
    try {
        ::vkCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetDiscardRectangleEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetDiscardRectangleEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    firstDiscardRectangle: " << (uint64_t)(firstDiscardRectangle) << std::endl;
        std::cerr << "    discardRectangleCount: " << (uint64_t)(discardRectangleCount) << std::endl;
        std::cerr << "    pDiscardRectangles: " << (uint64_t)(pDiscardRectangles) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_sample_locations
static Napi::Value rawCmdSetSampleLocationsEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pSampleLocationsInfo = (VkSampleLocationsInfoEXT const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetSampleLocationsEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetSampleLocationsEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pSampleLocationsInfo: " << (uint64_t)(pSampleLocationsInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_sample_locations
static Napi::Value rawGetPhysicalDeviceMultisamplePropertiesEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (samples)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) samples = (VkSampleCountFlagBits)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pMultisampleProperties = (VkMultisamplePropertiesEXT*)GetAddress(env, info_[2]);
    try {
        ::vkGetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceMultisamplePropertiesEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceMultisamplePropertiesEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    samples: " << (uint64_t)(samples) << std::endl;
        std::cerr << "    pMultisampleProperties: " << (uint64_t)(pMultisampleProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_get_surface_capabilities2
static Napi::Value rawGetPhysicalDeviceSurfaceCapabilities2KHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pSurfaceInfo = (VkPhysicalDeviceSurfaceInfo2KHR const*)GetAddress(env, info_[1]);

    decltype(auto) pSurfaceCapabilities = (VkSurfaceCapabilities2KHR*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceSurfaceCapabilities2KHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceSurfaceCapabilities2KHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pSurfaceInfo: " << (uint64_t)(pSurfaceInfo) << std::endl;
        std::cerr << "    pSurfaceCapabilities: " << (uint64_t)(pSurfaceCapabilities) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_get_surface_capabilities2
static Napi::Value rawGetPhysicalDeviceSurfaceFormats2KHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pSurfaceInfo = (VkPhysicalDeviceSurfaceInfo2KHR const*)GetAddress(env, info_[1]);

    decltype(auto) pSurfaceFormatCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pSurfaceFormats = (VkSurfaceFormat2KHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceSurfaceFormats2KHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceSurfaceFormats2KHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pSurfaceInfo: " << (uint64_t)(pSurfaceInfo) << std::endl;
        std::cerr << "    pSurfaceFormatCount: " << (uint64_t)(pSurfaceFormatCount) << std::endl;
        std::cerr << "    pSurfaceFormats: " << (uint64_t)(pSurfaceFormats) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_get_display_properties2
static Napi::Value rawGetPhysicalDeviceDisplayProperties2KHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pPropertyCount = (uint32_t*)GetAddress(env, info_[1]);

    decltype(auto) pProperties = (VkDisplayProperties2KHR*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceDisplayProperties2KHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceDisplayProperties2KHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pPropertyCount: " << (uint64_t)(pPropertyCount) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_get_display_properties2
static Napi::Value rawGetPhysicalDeviceDisplayPlaneProperties2KHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pPropertyCount = (uint32_t*)GetAddress(env, info_[1]);

    decltype(auto) pProperties = (VkDisplayPlaneProperties2KHR*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceDisplayPlaneProperties2KHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceDisplayPlaneProperties2KHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pPropertyCount: " << (uint64_t)(pPropertyCount) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_get_display_properties2
static Napi::Value rawGetDisplayModeProperties2KHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (display)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) display = (VkDisplayKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pPropertyCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pProperties = (VkDisplayModeProperties2KHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDisplayModeProperties2KHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDisplayModeProperties2KHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    display: " << (uint64_t)(display) << std::endl;
        std::cerr << "    pPropertyCount: " << (uint64_t)(pPropertyCount) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_get_display_properties2
static Napi::Value rawGetDisplayPlaneCapabilities2KHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pDisplayPlaneInfo = (VkDisplayPlaneInfo2KHR const*)GetAddress(env, info_[1]);

    decltype(auto) pCapabilities = (VkDisplayPlaneCapabilities2KHR*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDisplayPlaneCapabilities2KHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDisplayPlaneCapabilities2KHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pDisplayPlaneInfo: " << (uint64_t)(pDisplayPlaneInfo) << std::endl;
        std::cerr << "    pCapabilities: " << (uint64_t)(pCapabilities) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
static Napi::Value rawGetBufferMemoryRequirements2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkBufferMemoryRequirementsInfo2 const*)GetAddress(env, info_[1]);

    decltype(auto) pMemoryRequirements = (VkMemoryRequirements2*)GetAddress(env, info_[2]);
    try {
        ::vkGetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetBufferMemoryRequirements2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetBufferMemoryRequirements2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        std::cerr << "    pMemoryRequirements: " << (uint64_t)(pMemoryRequirements) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetImageMemoryRequirements2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkImageMemoryRequirementsInfo2 const*)GetAddress(env, info_[1]);

    decltype(auto) pMemoryRequirements = (VkMemoryRequirements2*)GetAddress(env, info_[2]);
    try {
        ::vkGetImageMemoryRequirements2(device, pInfo, pMemoryRequirements);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetImageMemoryRequirements2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetImageMemoryRequirements2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        std::cerr << "    pMemoryRequirements: " << (uint64_t)(pMemoryRequirements) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetImageSparseMemoryRequirements2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkImageSparseMemoryRequirementsInfo2 const*)GetAddress(env, info_[1]);

    decltype(auto) pSparseMemoryRequirementCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pSparseMemoryRequirements = (VkSparseImageMemoryRequirements2*)GetAddress(env, info_[3]);
    try {
        ::vkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetImageSparseMemoryRequirements2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetImageSparseMemoryRequirements2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        std::cerr << "    pSparseMemoryRequirementCount: " << (uint64_t)(pSparseMemoryRequirementCount) << std::endl;
        std::cerr << "    pSparseMemoryRequirements: " << (uint64_t)(pSparseMemoryRequirements) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetDeviceBufferMemoryRequirements(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkDeviceBufferMemoryRequirements const*)GetAddress(env, info_[1]);

    decltype(auto) pMemoryRequirements = (VkMemoryRequirements2*)GetAddress(env, info_[2]);
    try {
        ::vkGetDeviceBufferMemoryRequirements(device, pInfo, pMemoryRequirements);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeviceBufferMemoryRequirements command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeviceBufferMemoryRequirements)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        std::cerr << "    pMemoryRequirements: " << (uint64_t)(pMemoryRequirements) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetDeviceImageMemoryRequirements(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkDeviceImageMemoryRequirements const*)GetAddress(env, info_[1]);

    decltype(auto) pMemoryRequirements = (VkMemoryRequirements2*)GetAddress(env, info_[2]);
    try {
        ::vkGetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeviceImageMemoryRequirements command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeviceImageMemoryRequirements)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        std::cerr << "    pMemoryRequirements: " << (uint64_t)(pMemoryRequirements) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetDeviceImageSparseMemoryRequirements(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkDeviceImageMemoryRequirements const*)GetAddress(env, info_[1]);

    decltype(auto) pSparseMemoryRequirementCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pSparseMemoryRequirements = (VkSparseImageMemoryRequirements2*)GetAddress(env, info_[3]);
    try {
        ::vkGetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeviceImageSparseMemoryRequirements command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeviceImageSparseMemoryRequirements)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        std::cerr << "    pSparseMemoryRequirementCount: " << (uint64_t)(pSparseMemoryRequirementCount) << std::endl;
        std::cerr << "    pSparseMemoryRequirements: " << (uint64_t)(pSparseMemoryRequirements) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCreateSamplerYcbcrConversion(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkSamplerYcbcrConversionCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pYcbcrConversion = (VkSamplerYcbcrConversion*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateSamplerYcbcrConversion command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateSamplerYcbcrConversion)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pYcbcrConversion: " << (uint64_t)(pYcbcrConversion) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroySamplerYcbcrConversion(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (ycbcrConversion)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) ycbcrConversion = (VkSamplerYcbcrConversion)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroySamplerYcbcrConversion command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroySamplerYcbcrConversion)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    ycbcrConversion: " << (uint64_t)(ycbcrConversion) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetDeviceQueue2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pQueueInfo = (VkDeviceQueueInfo2 const*)GetAddress(env, info_[1]);

    decltype(auto) pQueue = (VkQueue*)GetAddress(env, info_[2]);
    try {
        ::vkGetDeviceQueue2(device, pQueueInfo, pQueue);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeviceQueue2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeviceQueue2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pQueueInfo: " << (uint64_t)(pQueueInfo) << std::endl;
        std::cerr << "    pQueue: " << (uint64_t)(pQueue) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_EXT_validation_cache
static Napi::Value rawCreateValidationCacheEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkValidationCacheCreateInfoEXT const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pValidationCache = (VkValidationCacheEXT*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateValidationCacheEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateValidationCacheEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pValidationCache: " << (uint64_t)(pValidationCache) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_validation_cache
static Napi::Value rawDestroyValidationCacheEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (validationCache)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) validationCache = (VkValidationCacheEXT)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyValidationCacheEXT(device, validationCache, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyValidationCacheEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyValidationCacheEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    validationCache: " << (uint64_t)(validationCache) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_validation_cache
static Napi::Value rawGetValidationCacheDataEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (validationCache)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) validationCache = (VkValidationCacheEXT)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pDataSize = (size_t*)GetAddress(env, info_[2]);

    decltype(auto) pData = (void*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetValidationCacheDataEXT(device, validationCache, pDataSize, pData);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetValidationCacheDataEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetValidationCacheDataEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    validationCache: " << (uint64_t)(validationCache) << std::endl;
        std::cerr << "    pDataSize: " << (uint64_t)(pDataSize) << std::endl;
        std::cerr << "    pData: " << (uint64_t)(pData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_validation_cache
static Napi::Value rawMergeValidationCachesEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (dstCache)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstCache = (VkValidationCacheEXT)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (srcCacheCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) srcCacheCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pSrcCaches = (VkValidationCacheEXT const*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkMergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkMergeValidationCachesEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkMergeValidationCachesEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    dstCache: " << (uint64_t)(dstCache) << std::endl;
        std::cerr << "    srcCacheCount: " << (uint64_t)(srcCacheCount) << std::endl;
        std::cerr << "    pSrcCaches: " << (uint64_t)(pSrcCaches) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
static Napi::Value rawGetDescriptorSetLayoutSupport(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkDescriptorSetLayoutCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pSupport = (VkDescriptorSetLayoutSupport*)GetAddress(env, info_[2]);
    try {
        ::vkGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDescriptorSetLayoutSupport command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDescriptorSetLayoutSupport)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pSupport: " << (uint64_t)(pSupport) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_ANDROID_native_buffer
static Napi::Value rawGetSwapchainGrallocUsageANDROID(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (format)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) format = (VkFormat)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (imageUsage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) imageUsage = (VkImageUsageFlags)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) grallocUsage = (int*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetSwapchainGrallocUsageANDROID(device, format, imageUsage, grallocUsage);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetSwapchainGrallocUsageANDROID command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetSwapchainGrallocUsageANDROID)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    format: " << (uint64_t)(format) << std::endl;
        std::cerr << "    imageUsage: " << (uint64_t)(imageUsage) << std::endl;
        std::cerr << "    grallocUsage: " << (uint64_t)(grallocUsage) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_ANDROID_native_buffer
static Napi::Value rawGetSwapchainGrallocUsage2ANDROID(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (format)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) format = (VkFormat)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (imageUsage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) imageUsage = (VkImageUsageFlags)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (swapchainImageUsage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) swapchainImageUsage = (VkSwapchainImageUsageFlagsANDROID)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    decltype(auto) grallocConsumerUsage = (uint64_t*)GetAddress(env, info_[4]);

    decltype(auto) grallocProducerUsage = (uint64_t*)GetAddress(env, info_[5]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetSwapchainGrallocUsage2ANDROID(device, format, imageUsage, swapchainImageUsage, grallocConsumerUsage, grallocProducerUsage);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetSwapchainGrallocUsage2ANDROID command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetSwapchainGrallocUsage2ANDROID)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    format: " << (uint64_t)(format) << std::endl;
        std::cerr << "    imageUsage: " << (uint64_t)(imageUsage) << std::endl;
        std::cerr << "    swapchainImageUsage: " << (uint64_t)(swapchainImageUsage) << std::endl;
        std::cerr << "    grallocConsumerUsage: " << (uint64_t)(grallocConsumerUsage) << std::endl;
        std::cerr << "    grallocProducerUsage: " << (uint64_t)(grallocProducerUsage) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_ANDROID_native_buffer
static Napi::Value rawAcquireImageANDROID(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (image)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) image = (VkImage)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (nativeFenceFd)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) nativeFenceFd = (int)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (semaphore)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) semaphore = (VkSemaphore)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (fence)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) fence = (VkFence)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkAcquireImageANDROID(device, image, nativeFenceFd, semaphore, fence);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkAcquireImageANDROID command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkAcquireImageANDROID)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    image: " << (uint64_t)(image) << std::endl;
        std::cerr << "    nativeFenceFd: " << (uint64_t)(nativeFenceFd) << std::endl;
        std::cerr << "    semaphore: " << (uint64_t)(semaphore) << std::endl;
        std::cerr << "    fence: " << (uint64_t)(fence) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_ANDROID_native_buffer
static Napi::Value rawQueueSignalReleaseImageANDROID(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (queue)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queue = (VkQueue)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (waitSemaphoreCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) waitSemaphoreCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pWaitSemaphores = (VkSemaphore const*)GetAddress(env, info_[2]);

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (image)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) image = (VkImage)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    decltype(auto) pNativeFenceFd = (int*)GetAddress(env, info_[4]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkQueueSignalReleaseImageANDROID(queue, waitSemaphoreCount, pWaitSemaphores, image, pNativeFenceFd);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkQueueSignalReleaseImageANDROID command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkQueueSignalReleaseImageANDROID)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    queue: " << (uint64_t)(queue) << std::endl;
        std::cerr << "    waitSemaphoreCount: " << (uint64_t)(waitSemaphoreCount) << std::endl;
        std::cerr << "    pWaitSemaphores: " << (uint64_t)(pWaitSemaphores) << std::endl;
        std::cerr << "    image: " << (uint64_t)(image) << std::endl;
        std::cerr << "    pNativeFenceFd: " << (uint64_t)(pNativeFenceFd) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_AMD_shader_info
static Napi::Value rawGetShaderInfoAMD(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipeline)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipeline = (VkPipeline)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (shaderStage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) shaderStage = (VkShaderStageFlagBits)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (infoType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) infoType = (VkShaderInfoTypeAMD)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    decltype(auto) pInfoSize = (size_t*)GetAddress(env, info_[4]);

    decltype(auto) pInfo = (void*)GetAddress(env, info_[5]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetShaderInfoAMD command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetShaderInfoAMD)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pipeline: " << (uint64_t)(pipeline) << std::endl;
        std::cerr << "    shaderStage: " << (uint64_t)(shaderStage) << std::endl;
        std::cerr << "    infoType: " << (uint64_t)(infoType) << std::endl;
        std::cerr << "    pInfoSize: " << (uint64_t)(pInfoSize) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_AMD_display_native_hdr
static Napi::Value rawSetLocalDimmingAMD(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (swapChain)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) swapChain = (VkSwapchainKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (localDimmingEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) localDimmingEnable = (VkBool32)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());
    try {
        ::vkSetLocalDimmingAMD(device, swapChain, localDimmingEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkSetLocalDimmingAMD command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkSetLocalDimmingAMD)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    swapChain: " << (uint64_t)(swapChain) << std::endl;
        std::cerr << "    localDimmingEnable: " << (uint64_t)(localDimmingEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_calibrated_timestamps
static Napi::Value rawGetPhysicalDeviceCalibrateableTimeDomainsEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pTimeDomainCount = (uint32_t*)GetAddress(env, info_[1]);

    decltype(auto) pTimeDomains = (VkTimeDomainEXT*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceCalibrateableTimeDomainsEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pTimeDomainCount: " << (uint64_t)(pTimeDomainCount) << std::endl;
        std::cerr << "    pTimeDomains: " << (uint64_t)(pTimeDomains) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_calibrated_timestamps
static Napi::Value rawGetCalibratedTimestampsEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (timestampCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) timestampCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pTimestampInfos = (VkCalibratedTimestampInfoEXT const*)GetAddress(env, info_[2]);

    decltype(auto) pTimestamps = (uint64_t*)GetAddress(env, info_[3]);

    decltype(auto) pMaxDeviation = (uint64_t*)GetAddress(env, info_[4]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetCalibratedTimestampsEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetCalibratedTimestampsEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    timestampCount: " << (uint64_t)(timestampCount) << std::endl;
        std::cerr << "    pTimestampInfos: " << (uint64_t)(pTimestampInfos) << std::endl;
        std::cerr << "    pTimestamps: " << (uint64_t)(pTimestamps) << std::endl;
        std::cerr << "    pMaxDeviation: " << (uint64_t)(pMaxDeviation) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_debug_utils
static Napi::Value rawSetDebugUtilsObjectNameEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pNameInfo = (VkDebugUtilsObjectNameInfoEXT const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkSetDebugUtilsObjectNameEXT(device, pNameInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkSetDebugUtilsObjectNameEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkSetDebugUtilsObjectNameEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pNameInfo: " << (uint64_t)(pNameInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_debug_utils
static Napi::Value rawSetDebugUtilsObjectTagEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pTagInfo = (VkDebugUtilsObjectTagInfoEXT const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkSetDebugUtilsObjectTagEXT(device, pTagInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkSetDebugUtilsObjectTagEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkSetDebugUtilsObjectTagEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pTagInfo: " << (uint64_t)(pTagInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_debug_utils
static Napi::Value rawQueueBeginDebugUtilsLabelEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (queue)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queue = (VkQueue)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pLabelInfo = (VkDebugUtilsLabelEXT const*)GetAddress(env, info_[1]);
    try {
        ::vkQueueBeginDebugUtilsLabelEXT(queue, pLabelInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkQueueBeginDebugUtilsLabelEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkQueueBeginDebugUtilsLabelEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    queue: " << (uint64_t)(queue) << std::endl;
        std::cerr << "    pLabelInfo: " << (uint64_t)(pLabelInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_debug_utils
static Napi::Value rawQueueEndDebugUtilsLabelEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 1) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (queue)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queue = (VkQueue)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());
    try {
        ::vkQueueEndDebugUtilsLabelEXT(queue);
    } catch(std::exception e) {
        std::cerr << "Exception with vkQueueEndDebugUtilsLabelEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkQueueEndDebugUtilsLabelEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    queue: " << (uint64_t)(queue) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_debug_utils
static Napi::Value rawQueueInsertDebugUtilsLabelEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (queue)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queue = (VkQueue)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pLabelInfo = (VkDebugUtilsLabelEXT const*)GetAddress(env, info_[1]);
    try {
        ::vkQueueInsertDebugUtilsLabelEXT(queue, pLabelInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkQueueInsertDebugUtilsLabelEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkQueueInsertDebugUtilsLabelEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    queue: " << (uint64_t)(queue) << std::endl;
        std::cerr << "    pLabelInfo: " << (uint64_t)(pLabelInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_debug_utils
static Napi::Value rawCmdBeginDebugUtilsLabelEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pLabelInfo = (VkDebugUtilsLabelEXT const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBeginDebugUtilsLabelEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBeginDebugUtilsLabelEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pLabelInfo: " << (uint64_t)(pLabelInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_debug_utils
static Napi::Value rawCmdEndDebugUtilsLabelEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 1) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdEndDebugUtilsLabelEXT(commandBuffer);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdEndDebugUtilsLabelEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdEndDebugUtilsLabelEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_debug_utils
static Napi::Value rawCmdInsertDebugUtilsLabelEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pLabelInfo = (VkDebugUtilsLabelEXT const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdInsertDebugUtilsLabelEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdInsertDebugUtilsLabelEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pLabelInfo: " << (uint64_t)(pLabelInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_debug_utils
static Napi::Value rawCreateDebugUtilsMessengerEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkDebugUtilsMessengerCreateInfoEXT const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pMessenger = (VkDebugUtilsMessengerEXT*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateDebugUtilsMessengerEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateDebugUtilsMessengerEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pMessenger: " << (uint64_t)(pMessenger) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_debug_utils
static Napi::Value rawDestroyDebugUtilsMessengerEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (messenger)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) messenger = (VkDebugUtilsMessengerEXT)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyDebugUtilsMessengerEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyDebugUtilsMessengerEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    messenger: " << (uint64_t)(messenger) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_debug_utils
static Napi::Value rawSubmitDebugUtilsMessageEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (messageSeverity)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) messageSeverity = (VkDebugUtilsMessageSeverityFlagBitsEXT)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (messageTypes)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) messageTypes = (VkDebugUtilsMessageTypeFlagsEXT)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pCallbackData = (VkDebugUtilsMessengerCallbackDataEXT const*)GetAddress(env, info_[3]);
    try {
        ::vkSubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData);
    } catch(std::exception e) {
        std::cerr << "Exception with vkSubmitDebugUtilsMessageEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkSubmitDebugUtilsMessageEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    messageSeverity: " << (uint64_t)(messageSeverity) << std::endl;
        std::cerr << "    messageTypes: " << (uint64_t)(messageTypes) << std::endl;
        std::cerr << "    pCallbackData: " << (uint64_t)(pCallbackData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_external_memory_host
static Napi::Value rawGetMemoryHostPointerPropertiesEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (handleType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) handleType = (VkExternalMemoryHandleTypeFlagBits)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pHostPointer = (void const*)GetAddress(env, info_[2]);

    decltype(auto) pMemoryHostPointerProperties = (VkMemoryHostPointerPropertiesEXT*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetMemoryHostPointerPropertiesEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetMemoryHostPointerPropertiesEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    handleType: " << (uint64_t)(handleType) << std::endl;
        std::cerr << "    pHostPointer: " << (uint64_t)(pHostPointer) << std::endl;
        std::cerr << "    pMemoryHostPointerProperties: " << (uint64_t)(pMemoryHostPointerProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_AMD_buffer_marker
static Napi::Value rawCmdWriteBufferMarkerAMD(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (pipelineStage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipelineStage = (VkPipelineStageFlagBits)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (dstBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstBuffer = (VkBuffer)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (dstOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstOffset = (VkDeviceSize)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (marker)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) marker = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdWriteBufferMarkerAMD command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdWriteBufferMarkerAMD)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pipelineStage: " << (uint64_t)(pipelineStage) << std::endl;
        std::cerr << "    dstBuffer: " << (uint64_t)(dstBuffer) << std::endl;
        std::cerr << "    dstOffset: " << (uint64_t)(dstOffset) << std::endl;
        std::cerr << "    marker: " << (uint64_t)(marker) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
static Napi::Value rawCreateRenderPass2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkRenderPassCreateInfo2 const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pRenderPass = (VkRenderPass*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateRenderPass2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateRenderPass2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pRenderPass: " << (uint64_t)(pRenderPass) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawCmdBeginRenderPass2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pRenderPassBegin = (VkRenderPassBeginInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pSubpassBeginInfo = (VkSubpassBeginInfo const*)GetAddress(env, info_[2]);
    try {
        ::vkCmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBeginRenderPass2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBeginRenderPass2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pRenderPassBegin: " << (uint64_t)(pRenderPassBegin) << std::endl;
        std::cerr << "    pSubpassBeginInfo: " << (uint64_t)(pSubpassBeginInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdNextSubpass2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pSubpassBeginInfo = (VkSubpassBeginInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pSubpassEndInfo = (VkSubpassEndInfo const*)GetAddress(env, info_[2]);
    try {
        ::vkCmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdNextSubpass2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdNextSubpass2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pSubpassBeginInfo: " << (uint64_t)(pSubpassBeginInfo) << std::endl;
        std::cerr << "    pSubpassEndInfo: " << (uint64_t)(pSubpassEndInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdEndRenderPass2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pSubpassEndInfo = (VkSubpassEndInfo const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdEndRenderPass2(commandBuffer, pSubpassEndInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdEndRenderPass2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdEndRenderPass2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pSubpassEndInfo: " << (uint64_t)(pSubpassEndInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawGetSemaphoreCounterValue(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (semaphore)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) semaphore = (VkSemaphore)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pValue = (uint64_t*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetSemaphoreCounterValue(device, semaphore, pValue);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetSemaphoreCounterValue command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetSemaphoreCounterValue)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    semaphore: " << (uint64_t)(semaphore) << std::endl;
        std::cerr << "    pValue: " << (uint64_t)(pValue) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawWaitSemaphores(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pWaitInfo = (VkSemaphoreWaitInfo const*)GetAddress(env, info_[1]);

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (timeout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) timeout = (uint64_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkWaitSemaphores(device, pWaitInfo, timeout);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkWaitSemaphores command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkWaitSemaphores)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pWaitInfo: " << (uint64_t)(pWaitInfo) << std::endl;
        std::cerr << "    timeout: " << (uint64_t)(timeout) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawSignalSemaphore(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pSignalInfo = (VkSemaphoreSignalInfo const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkSignalSemaphore(device, pSignalInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkSignalSemaphore command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkSignalSemaphore)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pSignalInfo: " << (uint64_t)(pSignalInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
static Napi::Value rawGetAndroidHardwareBufferPropertiesANDROID(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) buffer = (AHardwareBuffer const*)GetAddress(env, info_[1]);

    decltype(auto) pProperties = (VkAndroidHardwareBufferPropertiesANDROID*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetAndroidHardwareBufferPropertiesANDROID(device, buffer, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetAndroidHardwareBufferPropertiesANDROID command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetAndroidHardwareBufferPropertiesANDROID)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    buffer: " << (uint64_t)(buffer) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
static Napi::Value rawGetMemoryAndroidHardwareBufferANDROID(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkMemoryGetAndroidHardwareBufferInfoANDROID const*)GetAddress(env, info_[1]);

    decltype(auto) pBuffer = (AHardwareBuffer**)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetMemoryAndroidHardwareBufferANDROID(device, pInfo, pBuffer);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetMemoryAndroidHardwareBufferANDROID command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetMemoryAndroidHardwareBufferANDROID)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        std::cerr << "    pBuffer: " << (uint64_t)(pBuffer) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
static Napi::Value rawCmdDrawIndirectCount(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 7) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (buffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) buffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (offset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) offset = (VkDeviceSize)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (countBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) countBuffer = (VkBuffer)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (countBufferOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) countBufferOffset = (VkDeviceSize)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (maxDrawCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) maxDrawCount = (uint32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());

    if (!info_[6].IsNumber() && !info_[6].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 6 argument (stride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stride = (uint32_t)(info_[6].IsBigInt() ? info_[6].As<Napi::BigInt>().Uint64Value(&lossless) : info_[6].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDrawIndirectCount command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDrawIndirectCount)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    buffer: " << (uint64_t)(buffer) << std::endl;
        std::cerr << "    offset: " << (uint64_t)(offset) << std::endl;
        std::cerr << "    countBuffer: " << (uint64_t)(countBuffer) << std::endl;
        std::cerr << "    countBufferOffset: " << (uint64_t)(countBufferOffset) << std::endl;
        std::cerr << "    maxDrawCount: " << (uint64_t)(maxDrawCount) << std::endl;
        std::cerr << "    stride: " << (uint64_t)(stride) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdDrawIndexedIndirectCount(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 7) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (buffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) buffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (offset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) offset = (VkDeviceSize)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (countBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) countBuffer = (VkBuffer)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (countBufferOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) countBufferOffset = (VkDeviceSize)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (maxDrawCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) maxDrawCount = (uint32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());

    if (!info_[6].IsNumber() && !info_[6].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 6 argument (stride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stride = (uint32_t)(info_[6].IsBigInt() ? info_[6].As<Napi::BigInt>().Uint64Value(&lossless) : info_[6].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDrawIndexedIndirectCount command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDrawIndexedIndirectCount)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    buffer: " << (uint64_t)(buffer) << std::endl;
        std::cerr << "    offset: " << (uint64_t)(offset) << std::endl;
        std::cerr << "    countBuffer: " << (uint64_t)(countBuffer) << std::endl;
        std::cerr << "    countBufferOffset: " << (uint64_t)(countBufferOffset) << std::endl;
        std::cerr << "    maxDrawCount: " << (uint64_t)(maxDrawCount) << std::endl;
        std::cerr << "    stride: " << (uint64_t)(stride) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_NV_device_diagnostic_checkpoints
static Napi::Value rawCmdSetCheckpointNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCheckpointMarker = (void const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdSetCheckpointNV(commandBuffer, pCheckpointMarker);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetCheckpointNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetCheckpointNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pCheckpointMarker: " << (uint64_t)(pCheckpointMarker) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
static Napi::Value rawGetQueueCheckpointDataNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (queue)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queue = (VkQueue)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCheckpointDataCount = (uint32_t*)GetAddress(env, info_[1]);

    decltype(auto) pCheckpointData = (VkCheckpointDataNV*)GetAddress(env, info_[2]);
    try {
        ::vkGetQueueCheckpointDataNV(queue, pCheckpointDataCount, pCheckpointData);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetQueueCheckpointDataNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetQueueCheckpointDataNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    queue: " << (uint64_t)(queue) << std::endl;
        std::cerr << "    pCheckpointDataCount: " << (uint64_t)(pCheckpointDataCount) << std::endl;
        std::cerr << "    pCheckpointData: " << (uint64_t)(pCheckpointData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_transform_feedback
static Napi::Value rawCmdBindTransformFeedbackBuffersEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (firstBinding)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstBinding = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (bindingCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) bindingCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pBuffers = (VkBuffer const*)GetAddress(env, info_[3]);

    decltype(auto) pOffsets = (VkDeviceSize const*)GetAddress(env, info_[4]);

    decltype(auto) pSizes = (VkDeviceSize const*)GetAddress(env, info_[5]);
    try {
        ::vkCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBindTransformFeedbackBuffersEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBindTransformFeedbackBuffersEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    firstBinding: " << (uint64_t)(firstBinding) << std::endl;
        std::cerr << "    bindingCount: " << (uint64_t)(bindingCount) << std::endl;
        std::cerr << "    pBuffers: " << (uint64_t)(pBuffers) << std::endl;
        std::cerr << "    pOffsets: " << (uint64_t)(pOffsets) << std::endl;
        std::cerr << "    pSizes: " << (uint64_t)(pSizes) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_transform_feedback
static Napi::Value rawCmdBeginTransformFeedbackEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (firstCounterBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstCounterBuffer = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (counterBufferCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) counterBufferCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pCounterBuffers = (VkBuffer const*)GetAddress(env, info_[3]);

    decltype(auto) pCounterBufferOffsets = (VkDeviceSize const*)GetAddress(env, info_[4]);
    try {
        ::vkCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBeginTransformFeedbackEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBeginTransformFeedbackEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    firstCounterBuffer: " << (uint64_t)(firstCounterBuffer) << std::endl;
        std::cerr << "    counterBufferCount: " << (uint64_t)(counterBufferCount) << std::endl;
        std::cerr << "    pCounterBuffers: " << (uint64_t)(pCounterBuffers) << std::endl;
        std::cerr << "    pCounterBufferOffsets: " << (uint64_t)(pCounterBufferOffsets) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_transform_feedback
static Napi::Value rawCmdEndTransformFeedbackEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (firstCounterBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstCounterBuffer = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (counterBufferCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) counterBufferCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pCounterBuffers = (VkBuffer const*)GetAddress(env, info_[3]);

    decltype(auto) pCounterBufferOffsets = (VkDeviceSize const*)GetAddress(env, info_[4]);
    try {
        ::vkCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdEndTransformFeedbackEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdEndTransformFeedbackEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    firstCounterBuffer: " << (uint64_t)(firstCounterBuffer) << std::endl;
        std::cerr << "    counterBufferCount: " << (uint64_t)(counterBufferCount) << std::endl;
        std::cerr << "    pCounterBuffers: " << (uint64_t)(pCounterBuffers) << std::endl;
        std::cerr << "    pCounterBufferOffsets: " << (uint64_t)(pCounterBufferOffsets) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_transform_feedback
static Napi::Value rawCmdBeginQueryIndexedEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (queryPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryPool = (VkQueryPool)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (query)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) query = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (flags)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) flags = (VkQueryControlFlags)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (index)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) index = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBeginQueryIndexedEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBeginQueryIndexedEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    queryPool: " << (uint64_t)(queryPool) << std::endl;
        std::cerr << "    query: " << (uint64_t)(query) << std::endl;
        std::cerr << "    flags: " << (uint64_t)(flags) << std::endl;
        std::cerr << "    index: " << (uint64_t)(index) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_transform_feedback
static Napi::Value rawCmdEndQueryIndexedEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (queryPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryPool = (VkQueryPool)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (query)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) query = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (index)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) index = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdEndQueryIndexedEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdEndQueryIndexedEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    queryPool: " << (uint64_t)(queryPool) << std::endl;
        std::cerr << "    query: " << (uint64_t)(query) << std::endl;
        std::cerr << "    index: " << (uint64_t)(index) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_transform_feedback
static Napi::Value rawCmdDrawIndirectByteCountEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 7) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (instanceCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instanceCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (firstInstance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstInstance = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (counterBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) counterBuffer = (VkBuffer)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (counterBufferOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) counterBufferOffset = (VkDeviceSize)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (counterOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) counterOffset = (uint32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());

    if (!info_[6].IsNumber() && !info_[6].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 6 argument (vertexStride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) vertexStride = (uint32_t)(info_[6].IsBigInt() ? info_[6].As<Napi::BigInt>().Uint64Value(&lossless) : info_[6].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDrawIndirectByteCountEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDrawIndirectByteCountEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    instanceCount: " << (uint64_t)(instanceCount) << std::endl;
        std::cerr << "    firstInstance: " << (uint64_t)(firstInstance) << std::endl;
        std::cerr << "    counterBuffer: " << (uint64_t)(counterBuffer) << std::endl;
        std::cerr << "    counterBufferOffset: " << (uint64_t)(counterBufferOffset) << std::endl;
        std::cerr << "    counterOffset: " << (uint64_t)(counterOffset) << std::endl;
        std::cerr << "    vertexStride: " << (uint64_t)(vertexStride) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_scissor_exclusive
static Napi::Value rawCmdSetExclusiveScissorNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (firstExclusiveScissor)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstExclusiveScissor = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (exclusiveScissorCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) exclusiveScissorCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pExclusiveScissors = (VkRect2D const*)GetAddress(env, info_[3]);
    try {
        ::vkCmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetExclusiveScissorNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetExclusiveScissorNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    firstExclusiveScissor: " << (uint64_t)(firstExclusiveScissor) << std::endl;
        std::cerr << "    exclusiveScissorCount: " << (uint64_t)(exclusiveScissorCount) << std::endl;
        std::cerr << "    pExclusiveScissors: " << (uint64_t)(pExclusiveScissors) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_shading_rate_image
static Napi::Value rawCmdBindShadingRateImageNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (imageView)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) imageView = (VkImageView)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (imageLayout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) imageLayout = (VkImageLayout)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBindShadingRateImageNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBindShadingRateImageNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    imageView: " << (uint64_t)(imageView) << std::endl;
        std::cerr << "    imageLayout: " << (uint64_t)(imageLayout) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_shading_rate_image
static Napi::Value rawCmdSetViewportShadingRatePaletteNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (firstViewport)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstViewport = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (viewportCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) viewportCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pShadingRatePalettes = (VkShadingRatePaletteNV const*)GetAddress(env, info_[3]);
    try {
        ::vkCmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetViewportShadingRatePaletteNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetViewportShadingRatePaletteNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    firstViewport: " << (uint64_t)(firstViewport) << std::endl;
        std::cerr << "    viewportCount: " << (uint64_t)(viewportCount) << std::endl;
        std::cerr << "    pShadingRatePalettes: " << (uint64_t)(pShadingRatePalettes) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_shading_rate_image
static Napi::Value rawCmdSetCoarseSampleOrderNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (sampleOrderType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) sampleOrderType = (VkCoarseSampleOrderTypeNV)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (customSampleOrderCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) customSampleOrderCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pCustomSampleOrders = (VkCoarseSampleOrderCustomNV const*)GetAddress(env, info_[3]);
    try {
        ::vkCmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetCoarseSampleOrderNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetCoarseSampleOrderNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    sampleOrderType: " << (uint64_t)(sampleOrderType) << std::endl;
        std::cerr << "    customSampleOrderCount: " << (uint64_t)(customSampleOrderCount) << std::endl;
        std::cerr << "    pCustomSampleOrders: " << (uint64_t)(pCustomSampleOrders) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_mesh_shader
static Napi::Value rawCmdDrawMeshTasksNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (taskCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) taskCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (firstTask)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstTask = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDrawMeshTasksNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDrawMeshTasksNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    taskCount: " << (uint64_t)(taskCount) << std::endl;
        std::cerr << "    firstTask: " << (uint64_t)(firstTask) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_mesh_shader
static Napi::Value rawCmdDrawMeshTasksIndirectNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (buffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) buffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (offset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) offset = (VkDeviceSize)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (drawCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) drawCount = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (stride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stride = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDrawMeshTasksIndirectNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDrawMeshTasksIndirectNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    buffer: " << (uint64_t)(buffer) << std::endl;
        std::cerr << "    offset: " << (uint64_t)(offset) << std::endl;
        std::cerr << "    drawCount: " << (uint64_t)(drawCount) << std::endl;
        std::cerr << "    stride: " << (uint64_t)(stride) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_mesh_shader
static Napi::Value rawCmdDrawMeshTasksIndirectCountNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 7) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (buffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) buffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (offset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) offset = (VkDeviceSize)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (countBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) countBuffer = (VkBuffer)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (countBufferOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) countBufferOffset = (VkDeviceSize)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (maxDrawCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) maxDrawCount = (uint32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());

    if (!info_[6].IsNumber() && !info_[6].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 6 argument (stride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stride = (uint32_t)(info_[6].IsBigInt() ? info_[6].As<Napi::BigInt>().Uint64Value(&lossless) : info_[6].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDrawMeshTasksIndirectCountNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDrawMeshTasksIndirectCountNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    buffer: " << (uint64_t)(buffer) << std::endl;
        std::cerr << "    offset: " << (uint64_t)(offset) << std::endl;
        std::cerr << "    countBuffer: " << (uint64_t)(countBuffer) << std::endl;
        std::cerr << "    countBufferOffset: " << (uint64_t)(countBufferOffset) << std::endl;
        std::cerr << "    maxDrawCount: " << (uint64_t)(maxDrawCount) << std::endl;
        std::cerr << "    stride: " << (uint64_t)(stride) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_mesh_shader
static Napi::Value rawCmdDrawMeshTasksEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (groupCountX)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) groupCountX = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (groupCountY)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) groupCountY = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (groupCountZ)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) groupCountZ = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdDrawMeshTasksEXT(commandBuffer, groupCountX, groupCountY, groupCountZ);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDrawMeshTasksEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDrawMeshTasksEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    groupCountX: " << (uint64_t)(groupCountX) << std::endl;
        std::cerr << "    groupCountY: " << (uint64_t)(groupCountY) << std::endl;
        std::cerr << "    groupCountZ: " << (uint64_t)(groupCountZ) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_mesh_shader
static Napi::Value rawCmdDrawMeshTasksIndirectEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (buffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) buffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (offset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) offset = (VkDeviceSize)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (drawCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) drawCount = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (stride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stride = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdDrawMeshTasksIndirectEXT(commandBuffer, buffer, offset, drawCount, stride);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDrawMeshTasksIndirectEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDrawMeshTasksIndirectEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    buffer: " << (uint64_t)(buffer) << std::endl;
        std::cerr << "    offset: " << (uint64_t)(offset) << std::endl;
        std::cerr << "    drawCount: " << (uint64_t)(drawCount) << std::endl;
        std::cerr << "    stride: " << (uint64_t)(stride) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_mesh_shader
static Napi::Value rawCmdDrawMeshTasksIndirectCountEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 7) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (buffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) buffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (offset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) offset = (VkDeviceSize)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (countBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) countBuffer = (VkBuffer)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (countBufferOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) countBufferOffset = (VkDeviceSize)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (maxDrawCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) maxDrawCount = (uint32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());

    if (!info_[6].IsNumber() && !info_[6].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 6 argument (stride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stride = (uint32_t)(info_[6].IsBigInt() ? info_[6].As<Napi::BigInt>().Uint64Value(&lossless) : info_[6].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdDrawMeshTasksIndirectCountEXT(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDrawMeshTasksIndirectCountEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDrawMeshTasksIndirectCountEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    buffer: " << (uint64_t)(buffer) << std::endl;
        std::cerr << "    offset: " << (uint64_t)(offset) << std::endl;
        std::cerr << "    countBuffer: " << (uint64_t)(countBuffer) << std::endl;
        std::cerr << "    countBufferOffset: " << (uint64_t)(countBufferOffset) << std::endl;
        std::cerr << "    maxDrawCount: " << (uint64_t)(maxDrawCount) << std::endl;
        std::cerr << "    stride: " << (uint64_t)(stride) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_ray_tracing
static Napi::Value rawCompileDeferredNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipeline)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipeline = (VkPipeline)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (shader)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) shader = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCompileDeferredNV(device, pipeline, shader);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCompileDeferredNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCompileDeferredNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pipeline: " << (uint64_t)(pipeline) << std::endl;
        std::cerr << "    shader: " << (uint64_t)(shader) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_ray_tracing
static Napi::Value rawCreateAccelerationStructureNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkAccelerationStructureCreateInfoNV const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pAccelerationStructure = (VkAccelerationStructureNV*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateAccelerationStructureNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateAccelerationStructureNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pAccelerationStructure: " << (uint64_t)(pAccelerationStructure) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_HUAWEI_invocation_mask
static Napi::Value rawCmdBindInvocationMaskHUAWEI(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (imageView)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) imageView = (VkImageView)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (imageLayout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) imageLayout = (VkImageLayout)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdBindInvocationMaskHUAWEI(commandBuffer, imageView, imageLayout);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBindInvocationMaskHUAWEI command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBindInvocationMaskHUAWEI)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    imageView: " << (uint64_t)(imageView) << std::endl;
        std::cerr << "    imageLayout: " << (uint64_t)(imageLayout) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_acceleration_structure
static Napi::Value rawDestroyAccelerationStructureKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (accelerationStructure)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) accelerationStructure = (VkAccelerationStructureKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyAccelerationStructureKHR(device, accelerationStructure, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyAccelerationStructureKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyAccelerationStructureKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    accelerationStructure: " << (uint64_t)(accelerationStructure) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_ray_tracing
static Napi::Value rawDestroyAccelerationStructureNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (accelerationStructure)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) accelerationStructure = (VkAccelerationStructureNV)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyAccelerationStructureNV(device, accelerationStructure, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyAccelerationStructureNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyAccelerationStructureNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    accelerationStructure: " << (uint64_t)(accelerationStructure) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_ray_tracing
static Napi::Value rawGetAccelerationStructureMemoryRequirementsNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkAccelerationStructureMemoryRequirementsInfoNV const*)GetAddress(env, info_[1]);

    decltype(auto) pMemoryRequirements = (VkMemoryRequirements2KHR*)GetAddress(env, info_[2]);
    try {
        ::vkGetAccelerationStructureMemoryRequirementsNV(device, pInfo, pMemoryRequirements);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetAccelerationStructureMemoryRequirementsNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetAccelerationStructureMemoryRequirementsNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        std::cerr << "    pMemoryRequirements: " << (uint64_t)(pMemoryRequirements) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_ray_tracing
static Napi::Value rawBindAccelerationStructureMemoryNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (bindInfoCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) bindInfoCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pBindInfos = (VkBindAccelerationStructureMemoryInfoNV const*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkBindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkBindAccelerationStructureMemoryNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkBindAccelerationStructureMemoryNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    bindInfoCount: " << (uint64_t)(bindInfoCount) << std::endl;
        std::cerr << "    pBindInfos: " << (uint64_t)(pBindInfos) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_ray_tracing
static Napi::Value rawCmdCopyAccelerationStructureNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (dst)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dst = (VkAccelerationStructureNV)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (src)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) src = (VkAccelerationStructureNV)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (mode)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) mode = (VkCopyAccelerationStructureModeKHR)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyAccelerationStructureNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyAccelerationStructureNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    dst: " << (uint64_t)(dst) << std::endl;
        std::cerr << "    src: " << (uint64_t)(src) << std::endl;
        std::cerr << "    mode: " << (uint64_t)(mode) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_acceleration_structure
static Napi::Value rawCmdCopyAccelerationStructureKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkCopyAccelerationStructureInfoKHR const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdCopyAccelerationStructureKHR(commandBuffer, pInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyAccelerationStructureKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyAccelerationStructureKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_acceleration_structure
static Napi::Value rawCopyAccelerationStructureKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (deferredOperation)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) deferredOperation = (VkDeferredOperationKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkCopyAccelerationStructureInfoKHR const*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCopyAccelerationStructureKHR(device, deferredOperation, pInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCopyAccelerationStructureKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCopyAccelerationStructureKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    deferredOperation: " << (uint64_t)(deferredOperation) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_acceleration_structure
static Napi::Value rawCmdCopyAccelerationStructureToMemoryKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkCopyAccelerationStructureToMemoryInfoKHR const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdCopyAccelerationStructureToMemoryKHR(commandBuffer, pInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyAccelerationStructureToMemoryKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyAccelerationStructureToMemoryKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_acceleration_structure
static Napi::Value rawCopyAccelerationStructureToMemoryKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (deferredOperation)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) deferredOperation = (VkDeferredOperationKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkCopyAccelerationStructureToMemoryInfoKHR const*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCopyAccelerationStructureToMemoryKHR(device, deferredOperation, pInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCopyAccelerationStructureToMemoryKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCopyAccelerationStructureToMemoryKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    deferredOperation: " << (uint64_t)(deferredOperation) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_acceleration_structure
static Napi::Value rawCmdCopyMemoryToAccelerationStructureKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkCopyMemoryToAccelerationStructureInfoKHR const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdCopyMemoryToAccelerationStructureKHR(commandBuffer, pInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyMemoryToAccelerationStructureKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyMemoryToAccelerationStructureKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_acceleration_structure
static Napi::Value rawCopyMemoryToAccelerationStructureKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (deferredOperation)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) deferredOperation = (VkDeferredOperationKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkCopyMemoryToAccelerationStructureInfoKHR const*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCopyMemoryToAccelerationStructureKHR(device, deferredOperation, pInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCopyMemoryToAccelerationStructureKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCopyMemoryToAccelerationStructureKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    deferredOperation: " << (uint64_t)(deferredOperation) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_acceleration_structure
static Napi::Value rawCmdWriteAccelerationStructuresPropertiesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (accelerationStructureCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) accelerationStructureCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pAccelerationStructures = (VkAccelerationStructureKHR const*)GetAddress(env, info_[2]);

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (queryType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryType = (VkQueryType)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (queryPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryPool = (VkQueryPool)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (firstQuery)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstQuery = (uint32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdWriteAccelerationStructuresPropertiesKHR(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdWriteAccelerationStructuresPropertiesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdWriteAccelerationStructuresPropertiesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    accelerationStructureCount: " << (uint64_t)(accelerationStructureCount) << std::endl;
        std::cerr << "    pAccelerationStructures: " << (uint64_t)(pAccelerationStructures) << std::endl;
        std::cerr << "    queryType: " << (uint64_t)(queryType) << std::endl;
        std::cerr << "    queryPool: " << (uint64_t)(queryPool) << std::endl;
        std::cerr << "    firstQuery: " << (uint64_t)(firstQuery) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_ray_tracing
static Napi::Value rawCmdWriteAccelerationStructuresPropertiesNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (accelerationStructureCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) accelerationStructureCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pAccelerationStructures = (VkAccelerationStructureNV const*)GetAddress(env, info_[2]);

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (queryType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryType = (VkQueryType)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (queryPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryPool = (VkQueryPool)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (firstQuery)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstQuery = (uint32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdWriteAccelerationStructuresPropertiesNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdWriteAccelerationStructuresPropertiesNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    accelerationStructureCount: " << (uint64_t)(accelerationStructureCount) << std::endl;
        std::cerr << "    pAccelerationStructures: " << (uint64_t)(pAccelerationStructures) << std::endl;
        std::cerr << "    queryType: " << (uint64_t)(queryType) << std::endl;
        std::cerr << "    queryPool: " << (uint64_t)(queryPool) << std::endl;
        std::cerr << "    firstQuery: " << (uint64_t)(firstQuery) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_ray_tracing
static Napi::Value rawCmdBuildAccelerationStructureNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 9) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkAccelerationStructureInfoNV const*)GetAddress(env, info_[1]);

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (instanceData)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instanceData = (VkBuffer)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (instanceOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instanceOffset = (VkDeviceSize)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (update)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) update = (VkBool32)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    if (!info_[5].IsBigInt() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 5 argument (dst)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dst = (VkAccelerationStructureNV)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Int64Value());

    if (!info_[6].IsBigInt() && !info_[6].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 6 argument (src)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) src = (VkAccelerationStructureNV)(info_[6].IsBigInt() ? info_[6].As<Napi::BigInt>().Uint64Value(&lossless) : info_[6].As<Napi::Number>().Int64Value());

    if (!info_[7].IsBigInt() && !info_[7].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 7 argument (scratch)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) scratch = (VkBuffer)(info_[7].IsBigInt() ? info_[7].As<Napi::BigInt>().Uint64Value(&lossless) : info_[7].As<Napi::Number>().Int64Value());

    if (!info_[8].IsBigInt() && !info_[8].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 8 argument (scratchOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) scratchOffset = (VkDeviceSize)(info_[8].IsBigInt() ? info_[8].As<Napi::BigInt>().Uint64Value(&lossless) : info_[8].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBuildAccelerationStructureNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBuildAccelerationStructureNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        std::cerr << "    instanceData: " << (uint64_t)(instanceData) << std::endl;
        std::cerr << "    instanceOffset: " << (uint64_t)(instanceOffset) << std::endl;
        std::cerr << "    update: " << (uint64_t)(update) << std::endl;
        std::cerr << "    dst: " << (uint64_t)(dst) << std::endl;
        std::cerr << "    src: " << (uint64_t)(src) << std::endl;
        std::cerr << "    scratch: " << (uint64_t)(scratch) << std::endl;
        std::cerr << "    scratchOffset: " << (uint64_t)(scratchOffset) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_acceleration_structure
static Napi::Value rawWriteAccelerationStructuresPropertiesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 7) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (accelerationStructureCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) accelerationStructureCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pAccelerationStructures = (VkAccelerationStructureKHR const*)GetAddress(env, info_[2]);

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (queryType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryType = (VkQueryType)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (dataSize)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dataSize = (size_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    decltype(auto) pData = (void*)GetAddress(env, info_[5]);

    if (!info_[6].IsBigInt() && !info_[6].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 6 argument (stride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stride = (size_t)(info_[6].IsBigInt() ? info_[6].As<Napi::BigInt>().Uint64Value(&lossless) : info_[6].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkWriteAccelerationStructuresPropertiesKHR(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkWriteAccelerationStructuresPropertiesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkWriteAccelerationStructuresPropertiesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    accelerationStructureCount: " << (uint64_t)(accelerationStructureCount) << std::endl;
        std::cerr << "    pAccelerationStructures: " << (uint64_t)(pAccelerationStructures) << std::endl;
        std::cerr << "    queryType: " << (uint64_t)(queryType) << std::endl;
        std::cerr << "    dataSize: " << (uint64_t)(dataSize) << std::endl;
        std::cerr << "    pData: " << (uint64_t)(pData) << std::endl;
        std::cerr << "    stride: " << (uint64_t)(stride) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_ray_tracing_pipeline
static Napi::Value rawCmdTraceRaysKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 8) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pRaygenShaderBindingTable = (VkStridedDeviceAddressRegionKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pMissShaderBindingTable = (VkStridedDeviceAddressRegionKHR const*)GetAddress(env, info_[2]);

    decltype(auto) pHitShaderBindingTable = (VkStridedDeviceAddressRegionKHR const*)GetAddress(env, info_[3]);

    decltype(auto) pCallableShaderBindingTable = (VkStridedDeviceAddressRegionKHR const*)GetAddress(env, info_[4]);

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (width)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) width = (uint32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());

    if (!info_[6].IsNumber() && !info_[6].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 6 argument (height)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) height = (uint32_t)(info_[6].IsBigInt() ? info_[6].As<Napi::BigInt>().Uint64Value(&lossless) : info_[6].As<Napi::Number>().Uint32Value());

    if (!info_[7].IsNumber() && !info_[7].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 7 argument (depth)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) depth = (uint32_t)(info_[7].IsBigInt() ? info_[7].As<Napi::BigInt>().Uint64Value(&lossless) : info_[7].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdTraceRaysKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdTraceRaysKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdTraceRaysKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pRaygenShaderBindingTable: " << (uint64_t)(pRaygenShaderBindingTable) << std::endl;
        std::cerr << "    pMissShaderBindingTable: " << (uint64_t)(pMissShaderBindingTable) << std::endl;
        std::cerr << "    pHitShaderBindingTable: " << (uint64_t)(pHitShaderBindingTable) << std::endl;
        std::cerr << "    pCallableShaderBindingTable: " << (uint64_t)(pCallableShaderBindingTable) << std::endl;
        std::cerr << "    width: " << (uint64_t)(width) << std::endl;
        std::cerr << "    height: " << (uint64_t)(height) << std::endl;
        std::cerr << "    depth: " << (uint64_t)(depth) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_ray_tracing
static Napi::Value rawCmdTraceRaysNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 15) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (raygenShaderBindingTableBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) raygenShaderBindingTableBuffer = (VkBuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (raygenShaderBindingOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) raygenShaderBindingOffset = (VkDeviceSize)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (missShaderBindingTableBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) missShaderBindingTableBuffer = (VkBuffer)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (missShaderBindingOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) missShaderBindingOffset = (VkDeviceSize)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    if (!info_[5].IsBigInt() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 5 argument (missShaderBindingStride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) missShaderBindingStride = (VkDeviceSize)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Int64Value());

    if (!info_[6].IsBigInt() && !info_[6].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 6 argument (hitShaderBindingTableBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) hitShaderBindingTableBuffer = (VkBuffer)(info_[6].IsBigInt() ? info_[6].As<Napi::BigInt>().Uint64Value(&lossless) : info_[6].As<Napi::Number>().Int64Value());

    if (!info_[7].IsBigInt() && !info_[7].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 7 argument (hitShaderBindingOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) hitShaderBindingOffset = (VkDeviceSize)(info_[7].IsBigInt() ? info_[7].As<Napi::BigInt>().Uint64Value(&lossless) : info_[7].As<Napi::Number>().Int64Value());

    if (!info_[8].IsBigInt() && !info_[8].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 8 argument (hitShaderBindingStride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) hitShaderBindingStride = (VkDeviceSize)(info_[8].IsBigInt() ? info_[8].As<Napi::BigInt>().Uint64Value(&lossless) : info_[8].As<Napi::Number>().Int64Value());

    if (!info_[9].IsBigInt() && !info_[9].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 9 argument (callableShaderBindingTableBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) callableShaderBindingTableBuffer = (VkBuffer)(info_[9].IsBigInt() ? info_[9].As<Napi::BigInt>().Uint64Value(&lossless) : info_[9].As<Napi::Number>().Int64Value());

    if (!info_[10].IsBigInt() && !info_[10].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 10 argument (callableShaderBindingOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) callableShaderBindingOffset = (VkDeviceSize)(info_[10].IsBigInt() ? info_[10].As<Napi::BigInt>().Uint64Value(&lossless) : info_[10].As<Napi::Number>().Int64Value());

    if (!info_[11].IsBigInt() && !info_[11].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 11 argument (callableShaderBindingStride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) callableShaderBindingStride = (VkDeviceSize)(info_[11].IsBigInt() ? info_[11].As<Napi::BigInt>().Uint64Value(&lossless) : info_[11].As<Napi::Number>().Int64Value());

    if (!info_[12].IsNumber() && !info_[12].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 12 argument (width)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) width = (uint32_t)(info_[12].IsBigInt() ? info_[12].As<Napi::BigInt>().Uint64Value(&lossless) : info_[12].As<Napi::Number>().Uint32Value());

    if (!info_[13].IsNumber() && !info_[13].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 13 argument (height)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) height = (uint32_t)(info_[13].IsBigInt() ? info_[13].As<Napi::BigInt>().Uint64Value(&lossless) : info_[13].As<Napi::Number>().Uint32Value());

    if (!info_[14].IsNumber() && !info_[14].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 14 argument (depth)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) depth = (uint32_t)(info_[14].IsBigInt() ? info_[14].As<Napi::BigInt>().Uint64Value(&lossless) : info_[14].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdTraceRaysNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdTraceRaysNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    raygenShaderBindingTableBuffer: " << (uint64_t)(raygenShaderBindingTableBuffer) << std::endl;
        std::cerr << "    raygenShaderBindingOffset: " << (uint64_t)(raygenShaderBindingOffset) << std::endl;
        std::cerr << "    missShaderBindingTableBuffer: " << (uint64_t)(missShaderBindingTableBuffer) << std::endl;
        std::cerr << "    missShaderBindingOffset: " << (uint64_t)(missShaderBindingOffset) << std::endl;
        std::cerr << "    missShaderBindingStride: " << (uint64_t)(missShaderBindingStride) << std::endl;
        std::cerr << "    hitShaderBindingTableBuffer: " << (uint64_t)(hitShaderBindingTableBuffer) << std::endl;
        std::cerr << "    hitShaderBindingOffset: " << (uint64_t)(hitShaderBindingOffset) << std::endl;
        std::cerr << "    hitShaderBindingStride: " << (uint64_t)(hitShaderBindingStride) << std::endl;
        std::cerr << "    callableShaderBindingTableBuffer: " << (uint64_t)(callableShaderBindingTableBuffer) << std::endl;
        std::cerr << "    callableShaderBindingOffset: " << (uint64_t)(callableShaderBindingOffset) << std::endl;
        std::cerr << "    callableShaderBindingStride: " << (uint64_t)(callableShaderBindingStride) << std::endl;
        std::cerr << "    width: " << (uint64_t)(width) << std::endl;
        std::cerr << "    height: " << (uint64_t)(height) << std::endl;
        std::cerr << "    depth: " << (uint64_t)(depth) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_ray_tracing_pipeline
static Napi::Value rawGetRayTracingShaderGroupHandlesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipeline)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipeline = (VkPipeline)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (firstGroup)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstGroup = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (groupCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) groupCount = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (dataSize)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dataSize = (size_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    decltype(auto) pData = (void*)GetAddress(env, info_[5]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetRayTracingShaderGroupHandlesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetRayTracingShaderGroupHandlesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pipeline: " << (uint64_t)(pipeline) << std::endl;
        std::cerr << "    firstGroup: " << (uint64_t)(firstGroup) << std::endl;
        std::cerr << "    groupCount: " << (uint64_t)(groupCount) << std::endl;
        std::cerr << "    dataSize: " << (uint64_t)(dataSize) << std::endl;
        std::cerr << "    pData: " << (uint64_t)(pData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_ray_tracing_pipeline
static Napi::Value rawGetRayTracingCaptureReplayShaderGroupHandlesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipeline)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipeline = (VkPipeline)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (firstGroup)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstGroup = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (groupCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) groupCount = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (dataSize)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dataSize = (size_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    decltype(auto) pData = (void*)GetAddress(env, info_[5]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetRayTracingCaptureReplayShaderGroupHandlesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetRayTracingCaptureReplayShaderGroupHandlesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pipeline: " << (uint64_t)(pipeline) << std::endl;
        std::cerr << "    firstGroup: " << (uint64_t)(firstGroup) << std::endl;
        std::cerr << "    groupCount: " << (uint64_t)(groupCount) << std::endl;
        std::cerr << "    dataSize: " << (uint64_t)(dataSize) << std::endl;
        std::cerr << "    pData: " << (uint64_t)(pData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_ray_tracing
static Napi::Value rawGetAccelerationStructureHandleNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (accelerationStructure)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) accelerationStructure = (VkAccelerationStructureNV)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (dataSize)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dataSize = (size_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    decltype(auto) pData = (void*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetAccelerationStructureHandleNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetAccelerationStructureHandleNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    accelerationStructure: " << (uint64_t)(accelerationStructure) << std::endl;
        std::cerr << "    dataSize: " << (uint64_t)(dataSize) << std::endl;
        std::cerr << "    pData: " << (uint64_t)(pData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_ray_tracing
static Napi::Value rawCreateRayTracingPipelinesNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipelineCache)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipelineCache = (VkPipelineCache)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (createInfoCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) createInfoCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pCreateInfos = (VkRayTracingPipelineCreateInfoNV const*)GetAddress(env, info_[3]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[4]);

    decltype(auto) pPipelines = (VkPipeline*)GetAddress(env, info_[5]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateRayTracingPipelinesNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateRayTracingPipelinesNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pipelineCache: " << (uint64_t)(pipelineCache) << std::endl;
        std::cerr << "    createInfoCount: " << (uint64_t)(createInfoCount) << std::endl;
        std::cerr << "    pCreateInfos: " << (uint64_t)(pCreateInfos) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pPipelines: " << (uint64_t)(pPipelines) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_ray_tracing_pipeline
static Napi::Value rawCreateRayTracingPipelinesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 7) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (deferredOperation)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) deferredOperation = (VkDeferredOperationKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (pipelineCache)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipelineCache = (VkPipelineCache)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (createInfoCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) createInfoCount = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    decltype(auto) pCreateInfos = (VkRayTracingPipelineCreateInfoKHR const*)GetAddress(env, info_[4]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[5]);

    decltype(auto) pPipelines = (VkPipeline*)GetAddress(env, info_[6]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateRayTracingPipelinesKHR(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateRayTracingPipelinesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateRayTracingPipelinesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    deferredOperation: " << (uint64_t)(deferredOperation) << std::endl;
        std::cerr << "    pipelineCache: " << (uint64_t)(pipelineCache) << std::endl;
        std::cerr << "    createInfoCount: " << (uint64_t)(createInfoCount) << std::endl;
        std::cerr << "    pCreateInfos: " << (uint64_t)(pCreateInfos) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pPipelines: " << (uint64_t)(pPipelines) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_cooperative_matrix
static Napi::Value rawGetPhysicalDeviceCooperativeMatrixPropertiesNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pPropertyCount = (uint32_t*)GetAddress(env, info_[1]);

    decltype(auto) pProperties = (VkCooperativeMatrixPropertiesNV*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceCooperativeMatrixPropertiesNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceCooperativeMatrixPropertiesNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pPropertyCount: " << (uint64_t)(pPropertyCount) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_ray_tracing_pipeline
static Napi::Value rawCmdTraceRaysIndirectKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pRaygenShaderBindingTable = (VkStridedDeviceAddressRegionKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pMissShaderBindingTable = (VkStridedDeviceAddressRegionKHR const*)GetAddress(env, info_[2]);

    decltype(auto) pHitShaderBindingTable = (VkStridedDeviceAddressRegionKHR const*)GetAddress(env, info_[3]);

    decltype(auto) pCallableShaderBindingTable = (VkStridedDeviceAddressRegionKHR const*)GetAddress(env, info_[4]);

    if (!info_[5].IsBigInt() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 5 argument (indirectDeviceAddress)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) indirectDeviceAddress = (VkDeviceAddress)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdTraceRaysIndirectKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdTraceRaysIndirectKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdTraceRaysIndirectKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pRaygenShaderBindingTable: " << (uint64_t)(pRaygenShaderBindingTable) << std::endl;
        std::cerr << "    pMissShaderBindingTable: " << (uint64_t)(pMissShaderBindingTable) << std::endl;
        std::cerr << "    pHitShaderBindingTable: " << (uint64_t)(pHitShaderBindingTable) << std::endl;
        std::cerr << "    pCallableShaderBindingTable: " << (uint64_t)(pCallableShaderBindingTable) << std::endl;
        std::cerr << "    indirectDeviceAddress: " << (uint64_t)(indirectDeviceAddress) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
static Napi::Value rawCmdTraceRaysIndirect2KHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (indirectDeviceAddress)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) indirectDeviceAddress = (VkDeviceAddress)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdTraceRaysIndirect2KHR(commandBuffer, indirectDeviceAddress);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdTraceRaysIndirect2KHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdTraceRaysIndirect2KHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    indirectDeviceAddress: " << (uint64_t)(indirectDeviceAddress) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_acceleration_structure
static Napi::Value rawGetDeviceAccelerationStructureCompatibilityKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pVersionInfo = (VkAccelerationStructureVersionInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pCompatibility = (VkAccelerationStructureCompatibilityKHR*)GetAddress(env, info_[2]);
    try {
        ::vkGetDeviceAccelerationStructureCompatibilityKHR(device, pVersionInfo, pCompatibility);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeviceAccelerationStructureCompatibilityKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeviceAccelerationStructureCompatibilityKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pVersionInfo: " << (uint64_t)(pVersionInfo) << std::endl;
        std::cerr << "    pCompatibility: " << (uint64_t)(pCompatibility) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_ray_tracing_pipeline
static Napi::Value rawGetRayTracingShaderGroupStackSizeKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipeline)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipeline = (VkPipeline)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (group)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) group = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (groupShader)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) groupShader = (VkShaderGroupShaderKHR)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());
    uint64_t returnable = 0ull; try {
        decltype(auto) result = ::vkGetRayTracingShaderGroupStackSizeKHR(device, pipeline, group, groupShader);
        returnable = (uint64_t)(result);
        return Napi::BigInt::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetRayTracingShaderGroupStackSizeKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetRayTracingShaderGroupStackSizeKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pipeline: " << (uint64_t)(pipeline) << std::endl;
        std::cerr << "    group: " << (uint64_t)(group) << std::endl;
        std::cerr << "    groupShader: " << (uint64_t)(groupShader) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::BigInt::New(env, returnable);
}
#endif
#ifdef VK_KHR_ray_tracing_pipeline
static Napi::Value rawCmdSetRayTracingPipelineStackSizeKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (pipelineStackSize)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipelineStackSize = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetRayTracingPipelineStackSizeKHR(commandBuffer, pipelineStackSize);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetRayTracingPipelineStackSizeKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetRayTracingPipelineStackSizeKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pipelineStackSize: " << (uint64_t)(pipelineStackSize) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NVX_image_view_handle
static Napi::Value rawGetImageViewHandleNVX(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkImageViewHandleInfoNVX const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetImageViewHandleNVX(device, pInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetImageViewHandleNVX command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetImageViewHandleNVX)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NVX_image_view_handle
static Napi::Value rawGetImageViewAddressNVX(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (imageView)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) imageView = (VkImageView)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pProperties = (VkImageViewAddressPropertiesNVX*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetImageViewAddressNVX(device, imageView, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetImageViewAddressNVX command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetImageViewAddressNVX)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    imageView: " << (uint64_t)(imageView) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_full_screen_exclusive
static Napi::Value rawGetPhysicalDeviceSurfacePresentModes2EXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pSurfaceInfo = (VkPhysicalDeviceSurfaceInfo2KHR const*)GetAddress(env, info_[1]);

    decltype(auto) pPresentModeCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pPresentModes = (VkPresentModeKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceSurfacePresentModes2EXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceSurfacePresentModes2EXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pSurfaceInfo: " << (uint64_t)(pSurfaceInfo) << std::endl;
        std::cerr << "    pPresentModeCount: " << (uint64_t)(pPresentModeCount) << std::endl;
        std::cerr << "    pPresentModes: " << (uint64_t)(pPresentModes) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_full_screen_exclusive
static Napi::Value rawGetDeviceGroupSurfacePresentModes2EXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pSurfaceInfo = (VkPhysicalDeviceSurfaceInfo2KHR const*)GetAddress(env, info_[1]);

    decltype(auto) pModes = (VkDeviceGroupPresentModeFlagsKHR*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetDeviceGroupSurfacePresentModes2EXT(device, pSurfaceInfo, pModes);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeviceGroupSurfacePresentModes2EXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeviceGroupSurfacePresentModes2EXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pSurfaceInfo: " << (uint64_t)(pSurfaceInfo) << std::endl;
        std::cerr << "    pModes: " << (uint64_t)(pModes) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_full_screen_exclusive
static Napi::Value rawAcquireFullScreenExclusiveModeEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (swapchain)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) swapchain = (VkSwapchainKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkAcquireFullScreenExclusiveModeEXT(device, swapchain);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkAcquireFullScreenExclusiveModeEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkAcquireFullScreenExclusiveModeEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    swapchain: " << (uint64_t)(swapchain) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_full_screen_exclusive
static Napi::Value rawReleaseFullScreenExclusiveModeEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (swapchain)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) swapchain = (VkSwapchainKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkReleaseFullScreenExclusiveModeEXT(device, swapchain);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkReleaseFullScreenExclusiveModeEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkReleaseFullScreenExclusiveModeEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    swapchain: " << (uint64_t)(swapchain) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_performance_query
static Napi::Value rawEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (queueFamilyIndex)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queueFamilyIndex = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pCounterCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pCounters = (VkPerformanceCounterKHR*)GetAddress(env, info_[3]);

    decltype(auto) pCounterDescriptions = (VkPerformanceCounterDescriptionKHR*)GetAddress(env, info_[4]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    queueFamilyIndex: " << (uint64_t)(queueFamilyIndex) << std::endl;
        std::cerr << "    pCounterCount: " << (uint64_t)(pCounterCount) << std::endl;
        std::cerr << "    pCounters: " << (uint64_t)(pCounters) << std::endl;
        std::cerr << "    pCounterDescriptions: " << (uint64_t)(pCounterDescriptions) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_performance_query
static Napi::Value rawGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pPerformanceQueryCreateInfo = (VkQueryPoolPerformanceCreateInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pNumPasses = (uint32_t*)GetAddress(env, info_[2]);
    try {
        ::vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pPerformanceQueryCreateInfo: " << (uint64_t)(pPerformanceQueryCreateInfo) << std::endl;
        std::cerr << "    pNumPasses: " << (uint64_t)(pNumPasses) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_performance_query
static Napi::Value rawAcquireProfilingLockKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkAcquireProfilingLockInfoKHR const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkAcquireProfilingLockKHR(device, pInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkAcquireProfilingLockKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkAcquireProfilingLockKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_performance_query
static Napi::Value rawReleaseProfilingLockKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 1) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());
    try {
        ::vkReleaseProfilingLockKHR(device);
    } catch(std::exception e) {
        std::cerr << "Exception with vkReleaseProfilingLockKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkReleaseProfilingLockKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_image_drm_format_modifier
static Napi::Value rawGetImageDrmFormatModifierPropertiesEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (image)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) image = (VkImage)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pProperties = (VkImageDrmFormatModifierPropertiesEXT*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetImageDrmFormatModifierPropertiesEXT(device, image, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetImageDrmFormatModifierPropertiesEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetImageDrmFormatModifierPropertiesEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    image: " << (uint64_t)(image) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
static Napi::Value rawGetBufferOpaqueCaptureAddress(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkBufferDeviceAddressInfo const*)GetAddress(env, info_[1]);
    uint64_t returnable = 0ull; try {
        decltype(auto) result = ::vkGetBufferOpaqueCaptureAddress(device, pInfo);
        returnable = (uint64_t)(result);
        return Napi::BigInt::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetBufferOpaqueCaptureAddress command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetBufferOpaqueCaptureAddress)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::BigInt::New(env, returnable);
}
static Napi::Value rawGetBufferDeviceAddress(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkBufferDeviceAddressInfo const*)GetAddress(env, info_[1]);
    uint64_t returnable = 0ull; try {
        decltype(auto) result = ::vkGetBufferDeviceAddress(device, pInfo);
        returnable = (uint64_t)(result);
        return Napi::BigInt::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetBufferDeviceAddress command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetBufferDeviceAddress)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::BigInt::New(env, returnable);
}
#ifdef VK_EXT_headless_surface
static Napi::Value rawCreateHeadlessSurfaceEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (instance)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) instance = (VkInstance)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkHeadlessSurfaceCreateInfoEXT const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSurface = (VkSurfaceKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateHeadlessSurfaceEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateHeadlessSurfaceEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    instance: " << (uint64_t)(instance) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSurface: " << (uint64_t)(pSurface) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_coverage_reduction_mode
static Napi::Value rawGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCombinationCount = (uint32_t*)GetAddress(env, info_[1]);

    decltype(auto) pCombinations = (VkFramebufferMixedSamplesCombinationNV*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pCombinationCount: " << (uint64_t)(pCombinationCount) << std::endl;
        std::cerr << "    pCombinations: " << (uint64_t)(pCombinations) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_INTEL_performance_query
static Napi::Value rawInitializePerformanceApiINTEL(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInitializeInfo = (VkInitializePerformanceApiInfoINTEL const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkInitializePerformanceApiINTEL(device, pInitializeInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkInitializePerformanceApiINTEL command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkInitializePerformanceApiINTEL)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInitializeInfo: " << (uint64_t)(pInitializeInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_INTEL_performance_query
static Napi::Value rawUninitializePerformanceApiINTEL(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 1) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());
    try {
        ::vkUninitializePerformanceApiINTEL(device);
    } catch(std::exception e) {
        std::cerr << "Exception with vkUninitializePerformanceApiINTEL command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkUninitializePerformanceApiINTEL)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_INTEL_performance_query
static Napi::Value rawCmdSetPerformanceMarkerINTEL(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pMarkerInfo = (VkPerformanceMarkerInfoINTEL const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCmdSetPerformanceMarkerINTEL(commandBuffer, pMarkerInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetPerformanceMarkerINTEL command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetPerformanceMarkerINTEL)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pMarkerInfo: " << (uint64_t)(pMarkerInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_INTEL_performance_query
static Napi::Value rawCmdSetPerformanceStreamMarkerINTEL(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pMarkerInfo = (VkPerformanceStreamMarkerInfoINTEL const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCmdSetPerformanceStreamMarkerINTEL(commandBuffer, pMarkerInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetPerformanceStreamMarkerINTEL command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetPerformanceStreamMarkerINTEL)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pMarkerInfo: " << (uint64_t)(pMarkerInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_INTEL_performance_query
static Napi::Value rawCmdSetPerformanceOverrideINTEL(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pOverrideInfo = (VkPerformanceOverrideInfoINTEL const*)GetAddress(env, info_[1]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCmdSetPerformanceOverrideINTEL(commandBuffer, pOverrideInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetPerformanceOverrideINTEL command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetPerformanceOverrideINTEL)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pOverrideInfo: " << (uint64_t)(pOverrideInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_INTEL_performance_query
static Napi::Value rawAcquirePerformanceConfigurationINTEL(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pAcquireInfo = (VkPerformanceConfigurationAcquireInfoINTEL const*)GetAddress(env, info_[1]);

    decltype(auto) pConfiguration = (VkPerformanceConfigurationINTEL*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkAcquirePerformanceConfigurationINTEL(device, pAcquireInfo, pConfiguration);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkAcquirePerformanceConfigurationINTEL command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkAcquirePerformanceConfigurationINTEL)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pAcquireInfo: " << (uint64_t)(pAcquireInfo) << std::endl;
        std::cerr << "    pConfiguration: " << (uint64_t)(pConfiguration) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_INTEL_performance_query
static Napi::Value rawReleasePerformanceConfigurationINTEL(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (configuration)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) configuration = (VkPerformanceConfigurationINTEL)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkReleasePerformanceConfigurationINTEL(device, configuration);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkReleasePerformanceConfigurationINTEL command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkReleasePerformanceConfigurationINTEL)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    configuration: " << (uint64_t)(configuration) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_INTEL_performance_query
static Napi::Value rawQueueSetPerformanceConfigurationINTEL(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (queue)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queue = (VkQueue)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (configuration)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) configuration = (VkPerformanceConfigurationINTEL)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkQueueSetPerformanceConfigurationINTEL(queue, configuration);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkQueueSetPerformanceConfigurationINTEL command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkQueueSetPerformanceConfigurationINTEL)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    queue: " << (uint64_t)(queue) << std::endl;
        std::cerr << "    configuration: " << (uint64_t)(configuration) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_INTEL_performance_query
static Napi::Value rawGetPerformanceParameterINTEL(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (parameter)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) parameter = (VkPerformanceParameterTypeINTEL)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pValue = (VkPerformanceValueINTEL*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPerformanceParameterINTEL(device, parameter, pValue);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPerformanceParameterINTEL command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPerformanceParameterINTEL)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    parameter: " << (uint64_t)(parameter) << std::endl;
        std::cerr << "    pValue: " << (uint64_t)(pValue) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
static Napi::Value rawGetDeviceMemoryOpaqueCaptureAddress(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkDeviceMemoryOpaqueCaptureAddressInfo const*)GetAddress(env, info_[1]);
    uint64_t returnable = 0ull; try {
        decltype(auto) result = ::vkGetDeviceMemoryOpaqueCaptureAddress(device, pInfo);
        returnable = (uint64_t)(result);
        return Napi::BigInt::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeviceMemoryOpaqueCaptureAddress command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeviceMemoryOpaqueCaptureAddress)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::BigInt::New(env, returnable);
}
#ifdef VK_KHR_pipeline_executable_properties
static Napi::Value rawGetPipelineExecutablePropertiesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pPipelineInfo = (VkPipelineInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pExecutableCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pProperties = (VkPipelineExecutablePropertiesKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPipelineExecutablePropertiesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPipelineExecutablePropertiesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pPipelineInfo: " << (uint64_t)(pPipelineInfo) << std::endl;
        std::cerr << "    pExecutableCount: " << (uint64_t)(pExecutableCount) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_pipeline_executable_properties
static Napi::Value rawGetPipelineExecutableStatisticsKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pExecutableInfo = (VkPipelineExecutableInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pStatisticCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pStatistics = (VkPipelineExecutableStatisticKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount, pStatistics);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPipelineExecutableStatisticsKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPipelineExecutableStatisticsKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pExecutableInfo: " << (uint64_t)(pExecutableInfo) << std::endl;
        std::cerr << "    pStatisticCount: " << (uint64_t)(pStatisticCount) << std::endl;
        std::cerr << "    pStatistics: " << (uint64_t)(pStatistics) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_pipeline_executable_properties
static Napi::Value rawGetPipelineExecutableInternalRepresentationsKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pExecutableInfo = (VkPipelineExecutableInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pInternalRepresentationCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pInternalRepresentations = (VkPipelineExecutableInternalRepresentationKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPipelineExecutableInternalRepresentationsKHR(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPipelineExecutableInternalRepresentationsKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPipelineExecutableInternalRepresentationsKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pExecutableInfo: " << (uint64_t)(pExecutableInfo) << std::endl;
        std::cerr << "    pInternalRepresentationCount: " << (uint64_t)(pInternalRepresentationCount) << std::endl;
        std::cerr << "    pInternalRepresentations: " << (uint64_t)(pInternalRepresentations) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_line_rasterization
static Napi::Value rawCmdSetLineStippleEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (lineStippleFactor)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) lineStippleFactor = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (lineStipplePattern)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) lineStipplePattern = (uint16_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetLineStippleEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetLineStippleEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    lineStippleFactor: " << (uint64_t)(lineStippleFactor) << std::endl;
        std::cerr << "    lineStipplePattern: " << (uint64_t)(lineStipplePattern) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
static Napi::Value rawGetPhysicalDeviceToolProperties(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pToolCount = (uint32_t*)GetAddress(env, info_[1]);

    decltype(auto) pToolProperties = (VkPhysicalDeviceToolProperties*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceToolProperties(physicalDevice, pToolCount, pToolProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceToolProperties command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceToolProperties)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pToolCount: " << (uint64_t)(pToolCount) << std::endl;
        std::cerr << "    pToolProperties: " << (uint64_t)(pToolProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#ifdef VK_KHR_acceleration_structure
static Napi::Value rawCreateAccelerationStructureKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkAccelerationStructureCreateInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pAccelerationStructure = (VkAccelerationStructureKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateAccelerationStructureKHR(device, pCreateInfo, pAllocator, pAccelerationStructure);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateAccelerationStructureKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateAccelerationStructureKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pAccelerationStructure: " << (uint64_t)(pAccelerationStructure) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_acceleration_structure
static Napi::Value rawCmdBuildAccelerationStructuresKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (infoCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) infoCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pInfos = (VkAccelerationStructureBuildGeometryInfoKHR const*)GetAddress(env, info_[2]);

    decltype(auto) ppBuildRangeInfos = (VkAccelerationStructureBuildRangeInfoKHR* const*)GetAddress(env, info_[3]);
    try {
        ::vkCmdBuildAccelerationStructuresKHR(commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBuildAccelerationStructuresKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBuildAccelerationStructuresKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    infoCount: " << (uint64_t)(infoCount) << std::endl;
        std::cerr << "    pInfos: " << (uint64_t)(pInfos) << std::endl;
        std::cerr << "    ppBuildRangeInfos: " << (uint64_t)(ppBuildRangeInfos) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_acceleration_structure
static Napi::Value rawCmdBuildAccelerationStructuresIndirectKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (infoCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) infoCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pInfos = (VkAccelerationStructureBuildGeometryInfoKHR const*)GetAddress(env, info_[2]);

    decltype(auto) pIndirectDeviceAddresses = (VkDeviceAddress const*)GetAddress(env, info_[3]);

    decltype(auto) pIndirectStrides = (uint32_t const*)GetAddress(env, info_[4]);

    decltype(auto) ppMaxPrimitiveCounts = (uint32_t* const*)GetAddress(env, info_[5]);
    try {
        ::vkCmdBuildAccelerationStructuresIndirectKHR(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBuildAccelerationStructuresIndirectKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBuildAccelerationStructuresIndirectKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    infoCount: " << (uint64_t)(infoCount) << std::endl;
        std::cerr << "    pInfos: " << (uint64_t)(pInfos) << std::endl;
        std::cerr << "    pIndirectDeviceAddresses: " << (uint64_t)(pIndirectDeviceAddresses) << std::endl;
        std::cerr << "    pIndirectStrides: " << (uint64_t)(pIndirectStrides) << std::endl;
        std::cerr << "    ppMaxPrimitiveCounts: " << (uint64_t)(ppMaxPrimitiveCounts) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_acceleration_structure
static Napi::Value rawBuildAccelerationStructuresKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (deferredOperation)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) deferredOperation = (VkDeferredOperationKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (infoCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) infoCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pInfos = (VkAccelerationStructureBuildGeometryInfoKHR const*)GetAddress(env, info_[3]);

    decltype(auto) ppBuildRangeInfos = (VkAccelerationStructureBuildRangeInfoKHR* const*)GetAddress(env, info_[4]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkBuildAccelerationStructuresKHR(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkBuildAccelerationStructuresKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkBuildAccelerationStructuresKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    deferredOperation: " << (uint64_t)(deferredOperation) << std::endl;
        std::cerr << "    infoCount: " << (uint64_t)(infoCount) << std::endl;
        std::cerr << "    pInfos: " << (uint64_t)(pInfos) << std::endl;
        std::cerr << "    ppBuildRangeInfos: " << (uint64_t)(ppBuildRangeInfos) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_acceleration_structure
static Napi::Value rawGetAccelerationStructureDeviceAddressKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkAccelerationStructureDeviceAddressInfoKHR const*)GetAddress(env, info_[1]);
    uint64_t returnable = 0ull; try {
        decltype(auto) result = ::vkGetAccelerationStructureDeviceAddressKHR(device, pInfo);
        returnable = (uint64_t)(result);
        return Napi::BigInt::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetAccelerationStructureDeviceAddressKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetAccelerationStructureDeviceAddressKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::BigInt::New(env, returnable);
}
#endif
#ifdef VK_KHR_deferred_host_operations
static Napi::Value rawCreateDeferredOperationKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[1]);

    decltype(auto) pDeferredOperation = (VkDeferredOperationKHR*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateDeferredOperationKHR(device, pAllocator, pDeferredOperation);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateDeferredOperationKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateDeferredOperationKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pDeferredOperation: " << (uint64_t)(pDeferredOperation) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_deferred_host_operations
static Napi::Value rawDestroyDeferredOperationKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (operation)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) operation = (VkDeferredOperationKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyDeferredOperationKHR(device, operation, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyDeferredOperationKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyDeferredOperationKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    operation: " << (uint64_t)(operation) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_deferred_host_operations
static Napi::Value rawGetDeferredOperationMaxConcurrencyKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (operation)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) operation = (VkDeferredOperationKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetDeferredOperationMaxConcurrencyKHR(device, operation);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeferredOperationMaxConcurrencyKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeferredOperationMaxConcurrencyKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    operation: " << (uint64_t)(operation) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_deferred_host_operations
static Napi::Value rawGetDeferredOperationResultKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (operation)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) operation = (VkDeferredOperationKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetDeferredOperationResultKHR(device, operation);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeferredOperationResultKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeferredOperationResultKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    operation: " << (uint64_t)(operation) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_deferred_host_operations
static Napi::Value rawDeferredOperationJoinKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (operation)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) operation = (VkDeferredOperationKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkDeferredOperationJoinKHR(device, operation);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDeferredOperationJoinKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDeferredOperationJoinKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    operation: " << (uint64_t)(operation) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
static Napi::Value rawCmdSetCullMode(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (cullMode)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) cullMode = (VkCullModeFlags)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetCullMode(commandBuffer, cullMode);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetCullMode command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetCullMode)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    cullMode: " << (uint64_t)(cullMode) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetFrontFace(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (frontFace)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) frontFace = (VkFrontFace)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdSetFrontFace(commandBuffer, frontFace);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetFrontFace command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetFrontFace)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    frontFace: " << (uint64_t)(frontFace) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetPrimitiveTopology(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (primitiveTopology)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) primitiveTopology = (VkPrimitiveTopology)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdSetPrimitiveTopology(commandBuffer, primitiveTopology);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetPrimitiveTopology command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetPrimitiveTopology)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    primitiveTopology: " << (uint64_t)(primitiveTopology) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetViewportWithCount(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (viewportCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) viewportCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pViewports = (VkViewport const*)GetAddress(env, info_[2]);
    try {
        ::vkCmdSetViewportWithCount(commandBuffer, viewportCount, pViewports);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetViewportWithCount command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetViewportWithCount)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    viewportCount: " << (uint64_t)(viewportCount) << std::endl;
        std::cerr << "    pViewports: " << (uint64_t)(pViewports) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetScissorWithCount(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (scissorCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) scissorCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pScissors = (VkRect2D const*)GetAddress(env, info_[2]);
    try {
        ::vkCmdSetScissorWithCount(commandBuffer, scissorCount, pScissors);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetScissorWithCount command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetScissorWithCount)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    scissorCount: " << (uint64_t)(scissorCount) << std::endl;
        std::cerr << "    pScissors: " << (uint64_t)(pScissors) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdBindVertexBuffers2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 7) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (firstBinding)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstBinding = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (bindingCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) bindingCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pBuffers = (VkBuffer const*)GetAddress(env, info_[3]);

    decltype(auto) pOffsets = (VkDeviceSize const*)GetAddress(env, info_[4]);

    decltype(auto) pSizes = (VkDeviceSize const*)GetAddress(env, info_[5]);

    decltype(auto) pStrides = (VkDeviceSize const*)GetAddress(env, info_[6]);
    try {
        ::vkCmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBindVertexBuffers2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBindVertexBuffers2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    firstBinding: " << (uint64_t)(firstBinding) << std::endl;
        std::cerr << "    bindingCount: " << (uint64_t)(bindingCount) << std::endl;
        std::cerr << "    pBuffers: " << (uint64_t)(pBuffers) << std::endl;
        std::cerr << "    pOffsets: " << (uint64_t)(pOffsets) << std::endl;
        std::cerr << "    pSizes: " << (uint64_t)(pSizes) << std::endl;
        std::cerr << "    pStrides: " << (uint64_t)(pStrides) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetDepthTestEnable(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (depthTestEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) depthTestEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetDepthTestEnable(commandBuffer, depthTestEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetDepthTestEnable command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetDepthTestEnable)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    depthTestEnable: " << (uint64_t)(depthTestEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetDepthWriteEnable(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (depthWriteEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) depthWriteEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetDepthWriteEnable(commandBuffer, depthWriteEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetDepthWriteEnable command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetDepthWriteEnable)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    depthWriteEnable: " << (uint64_t)(depthWriteEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetDepthCompareOp(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (depthCompareOp)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) depthCompareOp = (VkCompareOp)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdSetDepthCompareOp(commandBuffer, depthCompareOp);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetDepthCompareOp command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetDepthCompareOp)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    depthCompareOp: " << (uint64_t)(depthCompareOp) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetDepthBoundsTestEnable(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (depthBoundsTestEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) depthBoundsTestEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetDepthBoundsTestEnable(commandBuffer, depthBoundsTestEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetDepthBoundsTestEnable command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetDepthBoundsTestEnable)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    depthBoundsTestEnable: " << (uint64_t)(depthBoundsTestEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetStencilTestEnable(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (stencilTestEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stencilTestEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetStencilTestEnable(commandBuffer, stencilTestEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetStencilTestEnable command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetStencilTestEnable)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    stencilTestEnable: " << (uint64_t)(stencilTestEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetStencilOp(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (faceMask)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) faceMask = (VkStencilFaceFlags)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (failOp)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) failOp = (VkStencilOp)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (passOp)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) passOp = (VkStencilOp)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (depthFailOp)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) depthFailOp = (VkStencilOp)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    if (!info_[5].IsBigInt() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 5 argument (compareOp)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) compareOp = (VkCompareOp)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdSetStencilOp(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetStencilOp command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetStencilOp)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    faceMask: " << (uint64_t)(faceMask) << std::endl;
        std::cerr << "    failOp: " << (uint64_t)(failOp) << std::endl;
        std::cerr << "    passOp: " << (uint64_t)(passOp) << std::endl;
        std::cerr << "    depthFailOp: " << (uint64_t)(depthFailOp) << std::endl;
        std::cerr << "    compareOp: " << (uint64_t)(compareOp) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_EXT_extended_dynamic_state2
static Napi::Value rawCmdSetPatchControlPointsEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (patchControlPoints)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) patchControlPoints = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetPatchControlPointsEXT(commandBuffer, patchControlPoints);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetPatchControlPointsEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetPatchControlPointsEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    patchControlPoints: " << (uint64_t)(patchControlPoints) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
static Napi::Value rawCmdSetRasterizerDiscardEnable(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (rasterizerDiscardEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) rasterizerDiscardEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetRasterizerDiscardEnable(commandBuffer, rasterizerDiscardEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetRasterizerDiscardEnable command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetRasterizerDiscardEnable)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    rasterizerDiscardEnable: " << (uint64_t)(rasterizerDiscardEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdSetDepthBiasEnable(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (depthBiasEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) depthBiasEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetDepthBiasEnable(commandBuffer, depthBiasEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetDepthBiasEnable command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetDepthBiasEnable)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    depthBiasEnable: " << (uint64_t)(depthBiasEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_EXT_extended_dynamic_state2
static Napi::Value rawCmdSetLogicOpEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (logicOp)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) logicOp = (VkLogicOp)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdSetLogicOpEXT(commandBuffer, logicOp);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetLogicOpEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetLogicOpEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    logicOp: " << (uint64_t)(logicOp) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
static Napi::Value rawCmdSetPrimitiveRestartEnable(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (primitiveRestartEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) primitiveRestartEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetPrimitiveRestartEnable(commandBuffer, primitiveRestartEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetPrimitiveRestartEnable command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetPrimitiveRestartEnable)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    primitiveRestartEnable: " << (uint64_t)(primitiveRestartEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetTessellationDomainOriginEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (domainOrigin)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) domainOrigin = (VkTessellationDomainOrigin)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdSetTessellationDomainOriginEXT(commandBuffer, domainOrigin);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetTessellationDomainOriginEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetTessellationDomainOriginEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    domainOrigin: " << (uint64_t)(domainOrigin) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetDepthClampEnableEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (depthClampEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) depthClampEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetDepthClampEnableEXT(commandBuffer, depthClampEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetDepthClampEnableEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetDepthClampEnableEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    depthClampEnable: " << (uint64_t)(depthClampEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetPolygonModeEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (polygonMode)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) polygonMode = (VkPolygonMode)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdSetPolygonModeEXT(commandBuffer, polygonMode);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetPolygonModeEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetPolygonModeEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    polygonMode: " << (uint64_t)(polygonMode) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetRasterizationSamplesEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (rasterizationSamples)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) rasterizationSamples = (VkSampleCountFlagBits)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetRasterizationSamplesEXT(commandBuffer, rasterizationSamples);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetRasterizationSamplesEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetRasterizationSamplesEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    rasterizationSamples: " << (uint64_t)(rasterizationSamples) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetSampleMaskEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (samples)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) samples = (VkSampleCountFlagBits)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pSampleMask = (VkSampleMask const*)GetAddress(env, info_[2]);
    try {
        ::vkCmdSetSampleMaskEXT(commandBuffer, samples, pSampleMask);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetSampleMaskEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetSampleMaskEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    samples: " << (uint64_t)(samples) << std::endl;
        std::cerr << "    pSampleMask: " << (uint64_t)(pSampleMask) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetAlphaToCoverageEnableEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (alphaToCoverageEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) alphaToCoverageEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetAlphaToCoverageEnableEXT(commandBuffer, alphaToCoverageEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetAlphaToCoverageEnableEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetAlphaToCoverageEnableEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    alphaToCoverageEnable: " << (uint64_t)(alphaToCoverageEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetAlphaToOneEnableEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (alphaToOneEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) alphaToOneEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetAlphaToOneEnableEXT(commandBuffer, alphaToOneEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetAlphaToOneEnableEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetAlphaToOneEnableEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    alphaToOneEnable: " << (uint64_t)(alphaToOneEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetLogicOpEnableEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (logicOpEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) logicOpEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetLogicOpEnableEXT(commandBuffer, logicOpEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetLogicOpEnableEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetLogicOpEnableEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    logicOpEnable: " << (uint64_t)(logicOpEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetColorBlendEnableEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (firstAttachment)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstAttachment = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (attachmentCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) attachmentCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pColorBlendEnables = (VkBool32 const*)GetAddress(env, info_[3]);
    try {
        ::vkCmdSetColorBlendEnableEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetColorBlendEnableEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetColorBlendEnableEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    firstAttachment: " << (uint64_t)(firstAttachment) << std::endl;
        std::cerr << "    attachmentCount: " << (uint64_t)(attachmentCount) << std::endl;
        std::cerr << "    pColorBlendEnables: " << (uint64_t)(pColorBlendEnables) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetColorBlendEquationEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (firstAttachment)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstAttachment = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (attachmentCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) attachmentCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pColorBlendEquations = (VkColorBlendEquationEXT const*)GetAddress(env, info_[3]);
    try {
        ::vkCmdSetColorBlendEquationEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetColorBlendEquationEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetColorBlendEquationEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    firstAttachment: " << (uint64_t)(firstAttachment) << std::endl;
        std::cerr << "    attachmentCount: " << (uint64_t)(attachmentCount) << std::endl;
        std::cerr << "    pColorBlendEquations: " << (uint64_t)(pColorBlendEquations) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetColorWriteMaskEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (firstAttachment)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstAttachment = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (attachmentCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) attachmentCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pColorWriteMasks = (VkColorComponentFlags const*)GetAddress(env, info_[3]);
    try {
        ::vkCmdSetColorWriteMaskEXT(commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetColorWriteMaskEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetColorWriteMaskEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    firstAttachment: " << (uint64_t)(firstAttachment) << std::endl;
        std::cerr << "    attachmentCount: " << (uint64_t)(attachmentCount) << std::endl;
        std::cerr << "    pColorWriteMasks: " << (uint64_t)(pColorWriteMasks) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetRasterizationStreamEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (rasterizationStream)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) rasterizationStream = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetRasterizationStreamEXT(commandBuffer, rasterizationStream);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetRasterizationStreamEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetRasterizationStreamEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    rasterizationStream: " << (uint64_t)(rasterizationStream) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetConservativeRasterizationModeEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (conservativeRasterizationMode)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) conservativeRasterizationMode = (VkConservativeRasterizationModeEXT)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdSetConservativeRasterizationModeEXT(commandBuffer, conservativeRasterizationMode);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetConservativeRasterizationModeEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetConservativeRasterizationModeEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    conservativeRasterizationMode: " << (uint64_t)(conservativeRasterizationMode) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetExtraPrimitiveOverestimationSizeEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber()) { Napi::TypeError::New(env, "Wrong type, needs Number at 1 argument (extraPrimitiveOverestimationSize)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) extraPrimitiveOverestimationSize = (float)info_[1].As<Napi::Number>().FloatValue();
    try {
        ::vkCmdSetExtraPrimitiveOverestimationSizeEXT(commandBuffer, extraPrimitiveOverestimationSize);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetExtraPrimitiveOverestimationSizeEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetExtraPrimitiveOverestimationSizeEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    extraPrimitiveOverestimationSize: " << (uint64_t)(extraPrimitiveOverestimationSize) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetDepthClipEnableEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (depthClipEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) depthClipEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetDepthClipEnableEXT(commandBuffer, depthClipEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetDepthClipEnableEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetDepthClipEnableEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    depthClipEnable: " << (uint64_t)(depthClipEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetSampleLocationsEnableEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (sampleLocationsEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) sampleLocationsEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetSampleLocationsEnableEXT(commandBuffer, sampleLocationsEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetSampleLocationsEnableEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetSampleLocationsEnableEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    sampleLocationsEnable: " << (uint64_t)(sampleLocationsEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetColorBlendAdvancedEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (firstAttachment)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstAttachment = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (attachmentCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) attachmentCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pColorBlendAdvanced = (VkColorBlendAdvancedEXT const*)GetAddress(env, info_[3]);
    try {
        ::vkCmdSetColorBlendAdvancedEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetColorBlendAdvancedEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetColorBlendAdvancedEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    firstAttachment: " << (uint64_t)(firstAttachment) << std::endl;
        std::cerr << "    attachmentCount: " << (uint64_t)(attachmentCount) << std::endl;
        std::cerr << "    pColorBlendAdvanced: " << (uint64_t)(pColorBlendAdvanced) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetProvokingVertexModeEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (provokingVertexMode)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) provokingVertexMode = (VkProvokingVertexModeEXT)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdSetProvokingVertexModeEXT(commandBuffer, provokingVertexMode);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetProvokingVertexModeEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetProvokingVertexModeEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    provokingVertexMode: " << (uint64_t)(provokingVertexMode) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetLineRasterizationModeEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (lineRasterizationMode)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) lineRasterizationMode = (VkLineRasterizationModeEXT)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdSetLineRasterizationModeEXT(commandBuffer, lineRasterizationMode);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetLineRasterizationModeEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetLineRasterizationModeEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    lineRasterizationMode: " << (uint64_t)(lineRasterizationMode) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetLineStippleEnableEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (stippledLineEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stippledLineEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetLineStippleEnableEXT(commandBuffer, stippledLineEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetLineStippleEnableEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetLineStippleEnableEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    stippledLineEnable: " << (uint64_t)(stippledLineEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetDepthClipNegativeOneToOneEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (negativeOneToOne)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) negativeOneToOne = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetDepthClipNegativeOneToOneEXT(commandBuffer, negativeOneToOne);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetDepthClipNegativeOneToOneEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetDepthClipNegativeOneToOneEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    negativeOneToOne: " << (uint64_t)(negativeOneToOne) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetViewportWScalingEnableNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (viewportWScalingEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) viewportWScalingEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetViewportWScalingEnableNV(commandBuffer, viewportWScalingEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetViewportWScalingEnableNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetViewportWScalingEnableNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    viewportWScalingEnable: " << (uint64_t)(viewportWScalingEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetViewportSwizzleNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (firstViewport)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstViewport = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (viewportCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) viewportCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pViewportSwizzles = (VkViewportSwizzleNV const*)GetAddress(env, info_[3]);
    try {
        ::vkCmdSetViewportSwizzleNV(commandBuffer, firstViewport, viewportCount, pViewportSwizzles);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetViewportSwizzleNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetViewportSwizzleNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    firstViewport: " << (uint64_t)(firstViewport) << std::endl;
        std::cerr << "    viewportCount: " << (uint64_t)(viewportCount) << std::endl;
        std::cerr << "    pViewportSwizzles: " << (uint64_t)(pViewportSwizzles) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetCoverageToColorEnableNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (coverageToColorEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) coverageToColorEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetCoverageToColorEnableNV(commandBuffer, coverageToColorEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetCoverageToColorEnableNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetCoverageToColorEnableNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    coverageToColorEnable: " << (uint64_t)(coverageToColorEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetCoverageToColorLocationNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (coverageToColorLocation)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) coverageToColorLocation = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetCoverageToColorLocationNV(commandBuffer, coverageToColorLocation);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetCoverageToColorLocationNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetCoverageToColorLocationNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    coverageToColorLocation: " << (uint64_t)(coverageToColorLocation) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetCoverageModulationModeNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (coverageModulationMode)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) coverageModulationMode = (VkCoverageModulationModeNV)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdSetCoverageModulationModeNV(commandBuffer, coverageModulationMode);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetCoverageModulationModeNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetCoverageModulationModeNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    coverageModulationMode: " << (uint64_t)(coverageModulationMode) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetCoverageModulationTableEnableNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (coverageModulationTableEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) coverageModulationTableEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetCoverageModulationTableEnableNV(commandBuffer, coverageModulationTableEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetCoverageModulationTableEnableNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetCoverageModulationTableEnableNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    coverageModulationTableEnable: " << (uint64_t)(coverageModulationTableEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetCoverageModulationTableNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (coverageModulationTableCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) coverageModulationTableCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pCoverageModulationTable = (float const*)GetAddress(env, info_[2]);
    try {
        ::vkCmdSetCoverageModulationTableNV(commandBuffer, coverageModulationTableCount, pCoverageModulationTable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetCoverageModulationTableNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetCoverageModulationTableNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    coverageModulationTableCount: " << (uint64_t)(coverageModulationTableCount) << std::endl;
        std::cerr << "    pCoverageModulationTable: " << (uint64_t)(pCoverageModulationTable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetShadingRateImageEnableNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (shadingRateImageEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) shadingRateImageEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetShadingRateImageEnableNV(commandBuffer, shadingRateImageEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetShadingRateImageEnableNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetShadingRateImageEnableNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    shadingRateImageEnable: " << (uint64_t)(shadingRateImageEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetCoverageReductionModeNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (coverageReductionMode)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) coverageReductionMode = (VkCoverageReductionModeNV)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdSetCoverageReductionModeNV(commandBuffer, coverageReductionMode);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetCoverageReductionModeNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetCoverageReductionModeNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    coverageReductionMode: " << (uint64_t)(coverageReductionMode) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_extended_dynamic_state3
static Napi::Value rawCmdSetRepresentativeFragmentTestEnableNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (representativeFragmentTestEnable)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) representativeFragmentTestEnable = (VkBool32)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdSetRepresentativeFragmentTestEnableNV(commandBuffer, representativeFragmentTestEnable);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetRepresentativeFragmentTestEnableNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetRepresentativeFragmentTestEnableNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    representativeFragmentTestEnable: " << (uint64_t)(representativeFragmentTestEnable) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
static Napi::Value rawCreatePrivateDataSlot(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkPrivateDataSlotCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pPrivateDataSlot = (VkPrivateDataSlot*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreatePrivateDataSlot(device, pCreateInfo, pAllocator, pPrivateDataSlot);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreatePrivateDataSlot command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreatePrivateDataSlot)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pPrivateDataSlot: " << (uint64_t)(pPrivateDataSlot) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawDestroyPrivateDataSlot(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (privateDataSlot)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) privateDataSlot = (VkPrivateDataSlot)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyPrivateDataSlot(device, privateDataSlot, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyPrivateDataSlot command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyPrivateDataSlot)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    privateDataSlot: " << (uint64_t)(privateDataSlot) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawSetPrivateData(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (objectType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) objectType = (VkObjectType)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (objectHandle)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) objectHandle = (uint64_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (privateDataSlot)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) privateDataSlot = (VkPrivateDataSlot)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (data)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) data = (uint64_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkSetPrivateData(device, objectType, objectHandle, privateDataSlot, data);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkSetPrivateData command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkSetPrivateData)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    objectType: " << (uint64_t)(objectType) << std::endl;
        std::cerr << "    objectHandle: " << (uint64_t)(objectHandle) << std::endl;
        std::cerr << "    privateDataSlot: " << (uint64_t)(privateDataSlot) << std::endl;
        std::cerr << "    data: " << (uint64_t)(data) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawGetPrivateData(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (objectType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) objectType = (VkObjectType)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (objectHandle)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) objectHandle = (uint64_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (privateDataSlot)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) privateDataSlot = (VkPrivateDataSlot)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    decltype(auto) pData = (uint64_t*)GetAddress(env, info_[4]);
    try {
        ::vkGetPrivateData(device, objectType, objectHandle, privateDataSlot, pData);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPrivateData command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPrivateData)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    objectType: " << (uint64_t)(objectType) << std::endl;
        std::cerr << "    objectHandle: " << (uint64_t)(objectHandle) << std::endl;
        std::cerr << "    privateDataSlot: " << (uint64_t)(privateDataSlot) << std::endl;
        std::cerr << "    pData: " << (uint64_t)(pData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdCopyBuffer2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCopyBufferInfo = (VkCopyBufferInfo2 const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdCopyBuffer2(commandBuffer, pCopyBufferInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyBuffer2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyBuffer2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pCopyBufferInfo: " << (uint64_t)(pCopyBufferInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdCopyImage2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCopyImageInfo = (VkCopyImageInfo2 const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdCopyImage2(commandBuffer, pCopyImageInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyImage2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyImage2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pCopyImageInfo: " << (uint64_t)(pCopyImageInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdBlitImage2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pBlitImageInfo = (VkBlitImageInfo2 const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdBlitImage2(commandBuffer, pBlitImageInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBlitImage2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBlitImage2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pBlitImageInfo: " << (uint64_t)(pBlitImageInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdCopyBufferToImage2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCopyBufferToImageInfo = (VkCopyBufferToImageInfo2 const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdCopyBufferToImage2(commandBuffer, pCopyBufferToImageInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyBufferToImage2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyBufferToImage2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pCopyBufferToImageInfo: " << (uint64_t)(pCopyBufferToImageInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdCopyImageToBuffer2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCopyImageToBufferInfo = (VkCopyImageToBufferInfo2 const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdCopyImageToBuffer2(commandBuffer, pCopyImageToBufferInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyImageToBuffer2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyImageToBuffer2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pCopyImageToBufferInfo: " << (uint64_t)(pCopyImageToBufferInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdResolveImage2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pResolveImageInfo = (VkResolveImageInfo2 const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdResolveImage2(commandBuffer, pResolveImageInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdResolveImage2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdResolveImage2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pResolveImageInfo: " << (uint64_t)(pResolveImageInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_KHR_fragment_shading_rate
static Napi::Value rawCmdSetFragmentShadingRateKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pFragmentSize = (VkExtent2D const*)GetAddress(env, info_[1]);

    decltype(auto) combinerOps = (VkFragmentShadingRateCombinerOpKHR const*)GetAddress(env, info_[2]);
    try {
        ::vkCmdSetFragmentShadingRateKHR(commandBuffer, pFragmentSize, combinerOps);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetFragmentShadingRateKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetFragmentShadingRateKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pFragmentSize: " << (uint64_t)(pFragmentSize) << std::endl;
        std::cerr << "    combinerOps: " << (uint64_t)(combinerOps) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_fragment_shading_rate
static Napi::Value rawGetPhysicalDeviceFragmentShadingRatesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pFragmentShadingRateCount = (uint32_t*)GetAddress(env, info_[1]);

    decltype(auto) pFragmentShadingRates = (VkPhysicalDeviceFragmentShadingRateKHR*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceFragmentShadingRatesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceFragmentShadingRatesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pFragmentShadingRateCount: " << (uint64_t)(pFragmentShadingRateCount) << std::endl;
        std::cerr << "    pFragmentShadingRates: " << (uint64_t)(pFragmentShadingRates) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_fragment_shading_rate_enums
static Napi::Value rawCmdSetFragmentShadingRateEnumNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (shadingRate)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) shadingRate = (VkFragmentShadingRateNV)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) combinerOps = (VkFragmentShadingRateCombinerOpKHR const*)GetAddress(env, info_[2]);
    try {
        ::vkCmdSetFragmentShadingRateEnumNV(commandBuffer, shadingRate, combinerOps);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetFragmentShadingRateEnumNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetFragmentShadingRateEnumNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    shadingRate: " << (uint64_t)(shadingRate) << std::endl;
        std::cerr << "    combinerOps: " << (uint64_t)(combinerOps) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_acceleration_structure
static Napi::Value rawGetAccelerationStructureBuildSizesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (buildType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) buildType = (VkAccelerationStructureBuildTypeKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pBuildInfo = (VkAccelerationStructureBuildGeometryInfoKHR const*)GetAddress(env, info_[2]);

    decltype(auto) pMaxPrimitiveCounts = (uint32_t const*)GetAddress(env, info_[3]);

    decltype(auto) pSizeInfo = (VkAccelerationStructureBuildSizesInfoKHR*)GetAddress(env, info_[4]);
    try {
        ::vkGetAccelerationStructureBuildSizesKHR(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetAccelerationStructureBuildSizesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetAccelerationStructureBuildSizesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    buildType: " << (uint64_t)(buildType) << std::endl;
        std::cerr << "    pBuildInfo: " << (uint64_t)(pBuildInfo) << std::endl;
        std::cerr << "    pMaxPrimitiveCounts: " << (uint64_t)(pMaxPrimitiveCounts) << std::endl;
        std::cerr << "    pSizeInfo: " << (uint64_t)(pSizeInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
static Napi::Value rawCmdSetVertexInputEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (vertexBindingDescriptionCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) vertexBindingDescriptionCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pVertexBindingDescriptions = (VkVertexInputBindingDescription2EXT const*)GetAddress(env, info_[2]);

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (vertexAttributeDescriptionCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) vertexAttributeDescriptionCount = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    decltype(auto) pVertexAttributeDescriptions = (VkVertexInputAttributeDescription2EXT const*)GetAddress(env, info_[4]);
    try {
        ::vkCmdSetVertexInputEXT(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetVertexInputEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetVertexInputEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    vertexBindingDescriptionCount: " << (uint64_t)(vertexBindingDescriptionCount) << std::endl;
        std::cerr << "    pVertexBindingDescriptions: " << (uint64_t)(pVertexBindingDescriptions) << std::endl;
        std::cerr << "    vertexAttributeDescriptionCount: " << (uint64_t)(vertexAttributeDescriptionCount) << std::endl;
        std::cerr << "    pVertexAttributeDescriptions: " << (uint64_t)(pVertexAttributeDescriptions) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_color_write_enable
static Napi::Value rawCmdSetColorWriteEnableEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (attachmentCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) attachmentCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pColorWriteEnables = (VkBool32 const*)GetAddress(env, info_[2]);
    try {
        ::vkCmdSetColorWriteEnableEXT(commandBuffer, attachmentCount, pColorWriteEnables);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetColorWriteEnableEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetColorWriteEnableEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    attachmentCount: " << (uint64_t)(attachmentCount) << std::endl;
        std::cerr << "    pColorWriteEnables: " << (uint64_t)(pColorWriteEnables) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
static Napi::Value rawCmdSetEvent2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (event)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) event = (VkEvent)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pDependencyInfo = (VkDependencyInfo const*)GetAddress(env, info_[2]);
    try {
        ::vkCmdSetEvent2(commandBuffer, event, pDependencyInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetEvent2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetEvent2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    event: " << (uint64_t)(event) << std::endl;
        std::cerr << "    pDependencyInfo: " << (uint64_t)(pDependencyInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdResetEvent2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (event)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) event = (VkEvent)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (stageMask)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stageMask = (VkPipelineStageFlags2)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdResetEvent2(commandBuffer, event, stageMask);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdResetEvent2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdResetEvent2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    event: " << (uint64_t)(event) << std::endl;
        std::cerr << "    stageMask: " << (uint64_t)(stageMask) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdWaitEvents2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (eventCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) eventCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pEvents = (VkEvent const*)GetAddress(env, info_[2]);

    decltype(auto) pDependencyInfos = (VkDependencyInfo const*)GetAddress(env, info_[3]);
    try {
        ::vkCmdWaitEvents2(commandBuffer, eventCount, pEvents, pDependencyInfos);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdWaitEvents2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdWaitEvents2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    eventCount: " << (uint64_t)(eventCount) << std::endl;
        std::cerr << "    pEvents: " << (uint64_t)(pEvents) << std::endl;
        std::cerr << "    pDependencyInfos: " << (uint64_t)(pDependencyInfos) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdPipelineBarrier2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pDependencyInfo = (VkDependencyInfo const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdPipelineBarrier2(commandBuffer, pDependencyInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdPipelineBarrier2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdPipelineBarrier2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pDependencyInfo: " << (uint64_t)(pDependencyInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawQueueSubmit2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (queue)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queue = (VkQueue)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (submitCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) submitCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pSubmits = (VkSubmitInfo2 const*)GetAddress(env, info_[2]);

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (fence)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) fence = (VkFence)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkQueueSubmit2(queue, submitCount, pSubmits, fence);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkQueueSubmit2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkQueueSubmit2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    queue: " << (uint64_t)(queue) << std::endl;
        std::cerr << "    submitCount: " << (uint64_t)(submitCount) << std::endl;
        std::cerr << "    pSubmits: " << (uint64_t)(pSubmits) << std::endl;
        std::cerr << "    fence: " << (uint64_t)(fence) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
static Napi::Value rawCmdWriteTimestamp2(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (stage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stage = (VkPipelineStageFlags2)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (queryPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryPool = (VkQueryPool)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (query)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) query = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdWriteTimestamp2(commandBuffer, stage, queryPool, query);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdWriteTimestamp2 command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdWriteTimestamp2)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    stage: " << (uint64_t)(stage) << std::endl;
        std::cerr << "    queryPool: " << (uint64_t)(queryPool) << std::endl;
        std::cerr << "    query: " << (uint64_t)(query) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_KHR_synchronization2
static Napi::Value rawCmdWriteBufferMarker2AMD(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (stage)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stage = (VkPipelineStageFlags2)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (dstBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstBuffer = (VkBuffer)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (dstOffset)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dstOffset = (VkDeviceSize)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (marker)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) marker = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdWriteBufferMarker2AMD(commandBuffer, stage, dstBuffer, dstOffset, marker);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdWriteBufferMarker2AMD command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdWriteBufferMarker2AMD)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    stage: " << (uint64_t)(stage) << std::endl;
        std::cerr << "    dstBuffer: " << (uint64_t)(dstBuffer) << std::endl;
        std::cerr << "    dstOffset: " << (uint64_t)(dstOffset) << std::endl;
        std::cerr << "    marker: " << (uint64_t)(marker) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_synchronization2
static Napi::Value rawGetQueueCheckpointData2NV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (queue)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queue = (VkQueue)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCheckpointDataCount = (uint32_t*)GetAddress(env, info_[1]);

    decltype(auto) pCheckpointData = (VkCheckpointData2NV*)GetAddress(env, info_[2]);
    try {
        ::vkGetQueueCheckpointData2NV(queue, pCheckpointDataCount, pCheckpointData);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetQueueCheckpointData2NV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetQueueCheckpointData2NV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    queue: " << (uint64_t)(queue) << std::endl;
        std::cerr << "    pCheckpointDataCount: " << (uint64_t)(pCheckpointDataCount) << std::endl;
        std::cerr << "    pCheckpointData: " << (uint64_t)(pCheckpointData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_video_queue
static Napi::Value rawGetPhysicalDeviceVideoCapabilitiesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pVideoProfile = (VkVideoProfileInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pCapabilities = (VkVideoCapabilitiesKHR*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice, pVideoProfile, pCapabilities);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceVideoCapabilitiesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceVideoCapabilitiesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pVideoProfile: " << (uint64_t)(pVideoProfile) << std::endl;
        std::cerr << "    pCapabilities: " << (uint64_t)(pCapabilities) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_video_queue
static Napi::Value rawGetPhysicalDeviceVideoFormatPropertiesKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pVideoFormatInfo = (VkPhysicalDeviceVideoFormatInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pVideoFormatPropertyCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pVideoFormatProperties = (VkVideoFormatPropertiesKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceVideoFormatPropertiesKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceVideoFormatPropertiesKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pVideoFormatInfo: " << (uint64_t)(pVideoFormatInfo) << std::endl;
        std::cerr << "    pVideoFormatPropertyCount: " << (uint64_t)(pVideoFormatPropertyCount) << std::endl;
        std::cerr << "    pVideoFormatProperties: " << (uint64_t)(pVideoFormatProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_video_queue
static Napi::Value rawCreateVideoSessionKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkVideoSessionCreateInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pVideoSession = (VkVideoSessionKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateVideoSessionKHR(device, pCreateInfo, pAllocator, pVideoSession);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateVideoSessionKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateVideoSessionKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pVideoSession: " << (uint64_t)(pVideoSession) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_video_queue
static Napi::Value rawDestroyVideoSessionKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (videoSession)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) videoSession = (VkVideoSessionKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyVideoSessionKHR(device, videoSession, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyVideoSessionKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyVideoSessionKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    videoSession: " << (uint64_t)(videoSession) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_video_queue
static Napi::Value rawCreateVideoSessionParametersKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkVideoSessionParametersCreateInfoKHR const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pVideoSessionParameters = (VkVideoSessionParametersKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateVideoSessionParametersKHR(device, pCreateInfo, pAllocator, pVideoSessionParameters);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateVideoSessionParametersKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateVideoSessionParametersKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pVideoSessionParameters: " << (uint64_t)(pVideoSessionParameters) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_video_queue
static Napi::Value rawUpdateVideoSessionParametersKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (videoSessionParameters)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) videoSessionParameters = (VkVideoSessionParametersKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pUpdateInfo = (VkVideoSessionParametersUpdateInfoKHR const*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkUpdateVideoSessionParametersKHR(device, videoSessionParameters, pUpdateInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkUpdateVideoSessionParametersKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkUpdateVideoSessionParametersKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    videoSessionParameters: " << (uint64_t)(videoSessionParameters) << std::endl;
        std::cerr << "    pUpdateInfo: " << (uint64_t)(pUpdateInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_video_queue
static Napi::Value rawDestroyVideoSessionParametersKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (videoSessionParameters)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) videoSessionParameters = (VkVideoSessionParametersKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyVideoSessionParametersKHR(device, videoSessionParameters, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyVideoSessionParametersKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyVideoSessionParametersKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    videoSessionParameters: " << (uint64_t)(videoSessionParameters) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_video_queue
static Napi::Value rawGetVideoSessionMemoryRequirementsKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (videoSession)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) videoSession = (VkVideoSessionKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pMemoryRequirementsCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pMemoryRequirements = (VkVideoSessionMemoryRequirementsKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetVideoSessionMemoryRequirementsKHR(device, videoSession, pMemoryRequirementsCount, pMemoryRequirements);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetVideoSessionMemoryRequirementsKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetVideoSessionMemoryRequirementsKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    videoSession: " << (uint64_t)(videoSession) << std::endl;
        std::cerr << "    pMemoryRequirementsCount: " << (uint64_t)(pMemoryRequirementsCount) << std::endl;
        std::cerr << "    pMemoryRequirements: " << (uint64_t)(pMemoryRequirements) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_video_queue
static Napi::Value rawBindVideoSessionMemoryKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (videoSession)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) videoSession = (VkVideoSessionKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (bindSessionMemoryInfoCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) bindSessionMemoryInfoCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pBindSessionMemoryInfos = (VkBindVideoSessionMemoryInfoKHR const*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkBindVideoSessionMemoryKHR(device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkBindVideoSessionMemoryKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkBindVideoSessionMemoryKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    videoSession: " << (uint64_t)(videoSession) << std::endl;
        std::cerr << "    bindSessionMemoryInfoCount: " << (uint64_t)(bindSessionMemoryInfoCount) << std::endl;
        std::cerr << "    pBindSessionMemoryInfos: " << (uint64_t)(pBindSessionMemoryInfos) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_video_decode_queue
static Napi::Value rawCmdDecodeVideoKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pDecodeInfo = (VkVideoDecodeInfoKHR const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdDecodeVideoKHR(commandBuffer, pDecodeInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDecodeVideoKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDecodeVideoKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pDecodeInfo: " << (uint64_t)(pDecodeInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_video_queue
static Napi::Value rawCmdBeginVideoCodingKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pBeginInfo = (VkVideoBeginCodingInfoKHR const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdBeginVideoCodingKHR(commandBuffer, pBeginInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBeginVideoCodingKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBeginVideoCodingKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pBeginInfo: " << (uint64_t)(pBeginInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_video_queue
static Napi::Value rawCmdControlVideoCodingKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCodingControlInfo = (VkVideoCodingControlInfoKHR const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdControlVideoCodingKHR(commandBuffer, pCodingControlInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdControlVideoCodingKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdControlVideoCodingKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pCodingControlInfo: " << (uint64_t)(pCodingControlInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_video_queue
static Napi::Value rawCmdEndVideoCodingKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pEndCodingInfo = (VkVideoEndCodingInfoKHR const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdEndVideoCodingKHR(commandBuffer, pEndCodingInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdEndVideoCodingKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdEndVideoCodingKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pEndCodingInfo: " << (uint64_t)(pEndCodingInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_KHR_video_encode_queue
static Napi::Value rawCmdEncodeVideoKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pEncodeInfo = (VkVideoEncodeInfoKHR const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdEncodeVideoKHR(commandBuffer, pEncodeInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdEncodeVideoKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdEncodeVideoKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pEncodeInfo: " << (uint64_t)(pEncodeInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_memory_decompression
static Napi::Value rawCmdDecompressMemoryNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (decompressRegionCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) decompressRegionCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pDecompressMemoryRegions = (VkDecompressMemoryRegionNV const*)GetAddress(env, info_[2]);
    try {
        ::vkCmdDecompressMemoryNV(commandBuffer, decompressRegionCount, pDecompressMemoryRegions);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDecompressMemoryNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDecompressMemoryNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    decompressRegionCount: " << (uint64_t)(decompressRegionCount) << std::endl;
        std::cerr << "    pDecompressMemoryRegions: " << (uint64_t)(pDecompressMemoryRegions) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_memory_decompression
static Napi::Value rawCmdDecompressMemoryIndirectCountNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (indirectCommandsAddress)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) indirectCommandsAddress = (VkDeviceAddress)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (indirectCommandsCountAddress)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) indirectCommandsCountAddress = (VkDeviceAddress)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (stride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stride = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdDecompressMemoryIndirectCountNV(commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdDecompressMemoryIndirectCountNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdDecompressMemoryIndirectCountNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    indirectCommandsAddress: " << (uint64_t)(indirectCommandsAddress) << std::endl;
        std::cerr << "    indirectCommandsCountAddress: " << (uint64_t)(indirectCommandsCountAddress) << std::endl;
        std::cerr << "    stride: " << (uint64_t)(stride) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NVX_binary_import
static Napi::Value rawCreateCuModuleNVX(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkCuModuleCreateInfoNVX const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pModule = (VkCuModuleNVX*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateCuModuleNVX(device, pCreateInfo, pAllocator, pModule);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateCuModuleNVX command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateCuModuleNVX)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pModule: " << (uint64_t)(pModule) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NVX_binary_import
static Napi::Value rawCreateCuFunctionNVX(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkCuFunctionCreateInfoNVX const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pFunction = (VkCuFunctionNVX*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateCuFunctionNVX(device, pCreateInfo, pAllocator, pFunction);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateCuFunctionNVX command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateCuFunctionNVX)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pFunction: " << (uint64_t)(pFunction) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NVX_binary_import
static Napi::Value rawDestroyCuModuleNVX(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (module)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) module = (VkCuModuleNVX)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyCuModuleNVX(device, module, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyCuModuleNVX command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyCuModuleNVX)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    module: " << (uint64_t)(module) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NVX_binary_import
static Napi::Value rawDestroyCuFunctionNVX(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (function)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) function = (VkCuFunctionNVX)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyCuFunctionNVX(device, function, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyCuFunctionNVX command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyCuFunctionNVX)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    function: " << (uint64_t)(function) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NVX_binary_import
static Napi::Value rawCmdCuLaunchKernelNVX(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pLaunchInfo = (VkCuLaunchInfoNVX const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdCuLaunchKernelNVX(commandBuffer, pLaunchInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCuLaunchKernelNVX command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCuLaunchKernelNVX)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pLaunchInfo: " << (uint64_t)(pLaunchInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_descriptor_buffer
static Napi::Value rawGetDescriptorSetLayoutSizeEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (layout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) layout = (VkDescriptorSetLayout)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pLayoutSizeInBytes = (VkDeviceSize*)GetAddress(env, info_[2]);
    try {
        ::vkGetDescriptorSetLayoutSizeEXT(device, layout, pLayoutSizeInBytes);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDescriptorSetLayoutSizeEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDescriptorSetLayoutSizeEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    layout: " << (uint64_t)(layout) << std::endl;
        std::cerr << "    pLayoutSizeInBytes: " << (uint64_t)(pLayoutSizeInBytes) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_descriptor_buffer
static Napi::Value rawGetDescriptorSetLayoutBindingOffsetEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (layout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) layout = (VkDescriptorSetLayout)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (binding)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) binding = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pOffset = (VkDeviceSize*)GetAddress(env, info_[3]);
    try {
        ::vkGetDescriptorSetLayoutBindingOffsetEXT(device, layout, binding, pOffset);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDescriptorSetLayoutBindingOffsetEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDescriptorSetLayoutBindingOffsetEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    layout: " << (uint64_t)(layout) << std::endl;
        std::cerr << "    binding: " << (uint64_t)(binding) << std::endl;
        std::cerr << "    pOffset: " << (uint64_t)(pOffset) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_descriptor_buffer
static Napi::Value rawGetDescriptorEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pDescriptorInfo = (VkDescriptorGetInfoEXT const*)GetAddress(env, info_[1]);

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (dataSize)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dataSize = (size_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    decltype(auto) pDescriptor = (void*)GetAddress(env, info_[3]);
    try {
        ::vkGetDescriptorEXT(device, pDescriptorInfo, dataSize, pDescriptor);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDescriptorEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDescriptorEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pDescriptorInfo: " << (uint64_t)(pDescriptorInfo) << std::endl;
        std::cerr << "    dataSize: " << (uint64_t)(dataSize) << std::endl;
        std::cerr << "    pDescriptor: " << (uint64_t)(pDescriptor) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_descriptor_buffer
static Napi::Value rawCmdBindDescriptorBuffersEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (bufferCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) bufferCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pBindingInfos = (VkDescriptorBufferBindingInfoEXT const*)GetAddress(env, info_[2]);
    try {
        ::vkCmdBindDescriptorBuffersEXT(commandBuffer, bufferCount, pBindingInfos);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBindDescriptorBuffersEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBindDescriptorBuffersEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    bufferCount: " << (uint64_t)(bufferCount) << std::endl;
        std::cerr << "    pBindingInfos: " << (uint64_t)(pBindingInfos) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_descriptor_buffer
static Napi::Value rawCmdSetDescriptorBufferOffsetsEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 7) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipelineBindPoint)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipelineBindPoint = (VkPipelineBindPoint)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (layout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) layout = (VkPipelineLayout)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (firstSet)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstSet = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());

    if (!info_[4].IsNumber() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 4 argument (setCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) setCount = (uint32_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Uint32Value());

    decltype(auto) pBufferIndices = (uint32_t const*)GetAddress(env, info_[5]);

    decltype(auto) pOffsets = (VkDeviceSize const*)GetAddress(env, info_[6]);
    try {
        ::vkCmdSetDescriptorBufferOffsetsEXT(commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdSetDescriptorBufferOffsetsEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdSetDescriptorBufferOffsetsEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pipelineBindPoint: " << (uint64_t)(pipelineBindPoint) << std::endl;
        std::cerr << "    layout: " << (uint64_t)(layout) << std::endl;
        std::cerr << "    firstSet: " << (uint64_t)(firstSet) << std::endl;
        std::cerr << "    setCount: " << (uint64_t)(setCount) << std::endl;
        std::cerr << "    pBufferIndices: " << (uint64_t)(pBufferIndices) << std::endl;
        std::cerr << "    pOffsets: " << (uint64_t)(pOffsets) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_descriptor_buffer
static Napi::Value rawCmdBindDescriptorBufferEmbeddedSamplersEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (pipelineBindPoint)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) pipelineBindPoint = (VkPipelineBindPoint)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (layout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) layout = (VkPipelineLayout)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsNumber() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 3 argument (set)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) set = (uint32_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdBindDescriptorBufferEmbeddedSamplersEXT(commandBuffer, pipelineBindPoint, layout, set);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBindDescriptorBufferEmbeddedSamplersEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBindDescriptorBufferEmbeddedSamplersEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pipelineBindPoint: " << (uint64_t)(pipelineBindPoint) << std::endl;
        std::cerr << "    layout: " << (uint64_t)(layout) << std::endl;
        std::cerr << "    set: " << (uint64_t)(set) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_descriptor_buffer
static Napi::Value rawGetBufferOpaqueCaptureDescriptorDataEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkBufferCaptureDescriptorDataInfoEXT const*)GetAddress(env, info_[1]);

    decltype(auto) pData = (void*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetBufferOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetBufferOpaqueCaptureDescriptorDataEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetBufferOpaqueCaptureDescriptorDataEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        std::cerr << "    pData: " << (uint64_t)(pData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_descriptor_buffer
static Napi::Value rawGetImageOpaqueCaptureDescriptorDataEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkImageCaptureDescriptorDataInfoEXT const*)GetAddress(env, info_[1]);

    decltype(auto) pData = (void*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetImageOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetImageOpaqueCaptureDescriptorDataEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetImageOpaqueCaptureDescriptorDataEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        std::cerr << "    pData: " << (uint64_t)(pData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_descriptor_buffer
static Napi::Value rawGetImageViewOpaqueCaptureDescriptorDataEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkImageViewCaptureDescriptorDataInfoEXT const*)GetAddress(env, info_[1]);

    decltype(auto) pData = (void*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetImageViewOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetImageViewOpaqueCaptureDescriptorDataEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetImageViewOpaqueCaptureDescriptorDataEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        std::cerr << "    pData: " << (uint64_t)(pData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_descriptor_buffer
static Napi::Value rawGetSamplerOpaqueCaptureDescriptorDataEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkSamplerCaptureDescriptorDataInfoEXT const*)GetAddress(env, info_[1]);

    decltype(auto) pData = (void*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetSamplerOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetSamplerOpaqueCaptureDescriptorDataEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetSamplerOpaqueCaptureDescriptorDataEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        std::cerr << "    pData: " << (uint64_t)(pData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_descriptor_buffer
static Napi::Value rawGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkAccelerationStructureCaptureDescriptorDataInfoEXT const*)GetAddress(env, info_[1]);

    decltype(auto) pData = (void*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        std::cerr << "    pData: " << (uint64_t)(pData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_pageable_device_local_memory
static Napi::Value rawSetDeviceMemoryPriorityEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (memory)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) memory = (VkDeviceMemory)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber()) { Napi::TypeError::New(env, "Wrong type, needs Number at 2 argument (priority)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) priority = (float)info_[2].As<Napi::Number>().FloatValue();
    try {
        ::vkSetDeviceMemoryPriorityEXT(device, memory, priority);
    } catch(std::exception e) {
        std::cerr << "Exception with vkSetDeviceMemoryPriorityEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkSetDeviceMemoryPriorityEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    memory: " << (uint64_t)(memory) << std::endl;
        std::cerr << "    priority: " << (uint64_t)(priority) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_acquire_drm_display
static Napi::Value rawAcquireDrmDisplayEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (drmFd)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) drmFd = (int32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Int64Value(&lossless) : info_[1].As<Napi::Number>().Int32Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (display)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) display = (VkDisplayKHR)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkAcquireDrmDisplayEXT(physicalDevice, drmFd, display);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkAcquireDrmDisplayEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkAcquireDrmDisplayEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    drmFd: " << (uint64_t)(drmFd) << std::endl;
        std::cerr << "    display: " << (uint64_t)(display) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_acquire_drm_display
static Napi::Value rawGetDrmDisplayEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (drmFd)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) drmFd = (int32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Int64Value(&lossless) : info_[1].As<Napi::Number>().Int32Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (connectorId)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) connectorId = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) display = (VkDisplayKHR*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetDrmDisplayEXT(physicalDevice, drmFd, connectorId, display);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDrmDisplayEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDrmDisplayEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    drmFd: " << (uint64_t)(drmFd) << std::endl;
        std::cerr << "    connectorId: " << (uint64_t)(connectorId) << std::endl;
        std::cerr << "    display: " << (uint64_t)(display) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_KHR_present_wait
static Napi::Value rawWaitForPresentKHR(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (swapchain)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) swapchain = (VkSwapchainKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (presentId)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) presentId = (uint64_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (timeout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) timeout = (uint64_t)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkWaitForPresentKHR(device, swapchain, presentId, timeout);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkWaitForPresentKHR command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkWaitForPresentKHR)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    swapchain: " << (uint64_t)(swapchain) << std::endl;
        std::cerr << "    presentId: " << (uint64_t)(presentId) << std::endl;
        std::cerr << "    timeout: " << (uint64_t)(timeout) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_FUCHSIA_buffer_collection
static Napi::Value rawCreateBufferCollectionFUCHSIA(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkBufferCollectionCreateInfoFUCHSIA const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pCollection = (VkBufferCollectionFUCHSIA*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateBufferCollectionFUCHSIA(device, pCreateInfo, pAllocator, pCollection);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateBufferCollectionFUCHSIA command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateBufferCollectionFUCHSIA)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pCollection: " << (uint64_t)(pCollection) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_FUCHSIA_buffer_collection
static Napi::Value rawSetBufferCollectionBufferConstraintsFUCHSIA(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (collection)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) collection = (VkBufferCollectionFUCHSIA)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pBufferConstraintsInfo = (VkBufferConstraintsInfoFUCHSIA const*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkSetBufferCollectionBufferConstraintsFUCHSIA(device, collection, pBufferConstraintsInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkSetBufferCollectionBufferConstraintsFUCHSIA command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkSetBufferCollectionBufferConstraintsFUCHSIA)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    collection: " << (uint64_t)(collection) << std::endl;
        std::cerr << "    pBufferConstraintsInfo: " << (uint64_t)(pBufferConstraintsInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_FUCHSIA_buffer_collection
static Napi::Value rawSetBufferCollectionImageConstraintsFUCHSIA(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (collection)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) collection = (VkBufferCollectionFUCHSIA)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pImageConstraintsInfo = (VkImageConstraintsInfoFUCHSIA const*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkSetBufferCollectionImageConstraintsFUCHSIA(device, collection, pImageConstraintsInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkSetBufferCollectionImageConstraintsFUCHSIA command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkSetBufferCollectionImageConstraintsFUCHSIA)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    collection: " << (uint64_t)(collection) << std::endl;
        std::cerr << "    pImageConstraintsInfo: " << (uint64_t)(pImageConstraintsInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_FUCHSIA_buffer_collection
static Napi::Value rawDestroyBufferCollectionFUCHSIA(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (collection)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) collection = (VkBufferCollectionFUCHSIA)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyBufferCollectionFUCHSIA(device, collection, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyBufferCollectionFUCHSIA command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyBufferCollectionFUCHSIA)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    collection: " << (uint64_t)(collection) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_FUCHSIA_buffer_collection
static Napi::Value rawGetBufferCollectionPropertiesFUCHSIA(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (collection)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) collection = (VkBufferCollectionFUCHSIA)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pProperties = (VkBufferCollectionPropertiesFUCHSIA*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetBufferCollectionPropertiesFUCHSIA(device, collection, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetBufferCollectionPropertiesFUCHSIA command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetBufferCollectionPropertiesFUCHSIA)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    collection: " << (uint64_t)(collection) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
static Napi::Value rawCmdBeginRendering(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pRenderingInfo = (VkRenderingInfo const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdBeginRendering(commandBuffer, pRenderingInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBeginRendering command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBeginRendering)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pRenderingInfo: " << (uint64_t)(pRenderingInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
static Napi::Value rawCmdEndRendering(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 1) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());
    try {
        ::vkCmdEndRendering(commandBuffer);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdEndRendering command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdEndRendering)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#ifdef VK_VALVE_descriptor_set_host_mapping
static Napi::Value rawGetDescriptorSetLayoutHostMappingInfoVALVE(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pBindingReference = (VkDescriptorSetBindingReferenceVALVE const*)GetAddress(env, info_[1]);

    decltype(auto) pHostMapping = (VkDescriptorSetLayoutHostMappingInfoVALVE*)GetAddress(env, info_[2]);
    try {
        ::vkGetDescriptorSetLayoutHostMappingInfoVALVE(device, pBindingReference, pHostMapping);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDescriptorSetLayoutHostMappingInfoVALVE command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDescriptorSetLayoutHostMappingInfoVALVE)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pBindingReference: " << (uint64_t)(pBindingReference) << std::endl;
        std::cerr << "    pHostMapping: " << (uint64_t)(pHostMapping) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
static Napi::Value rawGetDescriptorSetHostMappingVALVE(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (descriptorSet)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) descriptorSet = (VkDescriptorSet)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) ppData = (void**)GetAddress(env, info_[2]);
    try {
        ::vkGetDescriptorSetHostMappingVALVE(device, descriptorSet, ppData);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDescriptorSetHostMappingVALVE command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDescriptorSetHostMappingVALVE)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    descriptorSet: " << (uint64_t)(descriptorSet) << std::endl;
        std::cerr << "    ppData: " << (uint64_t)(ppData) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_opacity_micromap
static Napi::Value rawCreateMicromapEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkMicromapCreateInfoEXT const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pMicromap = (VkMicromapEXT*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateMicromapEXT(device, pCreateInfo, pAllocator, pMicromap);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateMicromapEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateMicromapEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pMicromap: " << (uint64_t)(pMicromap) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_opacity_micromap
static Napi::Value rawCmdBuildMicromapsEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (infoCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) infoCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pInfos = (VkMicromapBuildInfoEXT const*)GetAddress(env, info_[2]);
    try {
        ::vkCmdBuildMicromapsEXT(commandBuffer, infoCount, pInfos);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdBuildMicromapsEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdBuildMicromapsEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    infoCount: " << (uint64_t)(infoCount) << std::endl;
        std::cerr << "    pInfos: " << (uint64_t)(pInfos) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_opacity_micromap
static Napi::Value rawBuildMicromapsEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (deferredOperation)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) deferredOperation = (VkDeferredOperationKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsNumber() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 2 argument (infoCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) infoCount = (uint32_t)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Uint32Value());

    decltype(auto) pInfos = (VkMicromapBuildInfoEXT const*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkBuildMicromapsEXT(device, deferredOperation, infoCount, pInfos);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkBuildMicromapsEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkBuildMicromapsEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    deferredOperation: " << (uint64_t)(deferredOperation) << std::endl;
        std::cerr << "    infoCount: " << (uint64_t)(infoCount) << std::endl;
        std::cerr << "    pInfos: " << (uint64_t)(pInfos) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_opacity_micromap
static Napi::Value rawDestroyMicromapEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (micromap)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) micromap = (VkMicromapEXT)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyMicromapEXT(device, micromap, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyMicromapEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyMicromapEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    micromap: " << (uint64_t)(micromap) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_opacity_micromap
static Napi::Value rawCmdCopyMicromapEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkCopyMicromapInfoEXT const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdCopyMicromapEXT(commandBuffer, pInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyMicromapEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyMicromapEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_opacity_micromap
static Napi::Value rawCopyMicromapEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (deferredOperation)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) deferredOperation = (VkDeferredOperationKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkCopyMicromapInfoEXT const*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCopyMicromapEXT(device, deferredOperation, pInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCopyMicromapEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCopyMicromapEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    deferredOperation: " << (uint64_t)(deferredOperation) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_opacity_micromap
static Napi::Value rawCmdCopyMicromapToMemoryEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkCopyMicromapToMemoryInfoEXT const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdCopyMicromapToMemoryEXT(commandBuffer, pInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyMicromapToMemoryEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyMicromapToMemoryEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_opacity_micromap
static Napi::Value rawCopyMicromapToMemoryEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (deferredOperation)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) deferredOperation = (VkDeferredOperationKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkCopyMicromapToMemoryInfoEXT const*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCopyMicromapToMemoryEXT(device, deferredOperation, pInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCopyMicromapToMemoryEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCopyMicromapToMemoryEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    deferredOperation: " << (uint64_t)(deferredOperation) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_opacity_micromap
static Napi::Value rawCmdCopyMemoryToMicromapEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkCopyMemoryToMicromapInfoEXT const*)GetAddress(env, info_[1]);
    try {
        ::vkCmdCopyMemoryToMicromapEXT(commandBuffer, pInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdCopyMemoryToMicromapEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdCopyMemoryToMicromapEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_opacity_micromap
static Napi::Value rawCopyMemoryToMicromapEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (deferredOperation)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) deferredOperation = (VkDeferredOperationKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pInfo = (VkCopyMemoryToMicromapInfoEXT const*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCopyMemoryToMicromapEXT(device, deferredOperation, pInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCopyMemoryToMicromapEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCopyMemoryToMicromapEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    deferredOperation: " << (uint64_t)(deferredOperation) << std::endl;
        std::cerr << "    pInfo: " << (uint64_t)(pInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_opacity_micromap
static Napi::Value rawCmdWriteMicromapsPropertiesEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 6) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (micromapCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) micromapCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pMicromaps = (VkMicromapEXT const*)GetAddress(env, info_[2]);

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (queryType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryType = (VkQueryType)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (queryPool)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryPool = (VkQueryPool)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    if (!info_[5].IsNumber() && !info_[5].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 5 argument (firstQuery)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) firstQuery = (uint32_t)(info_[5].IsBigInt() ? info_[5].As<Napi::BigInt>().Uint64Value(&lossless) : info_[5].As<Napi::Number>().Uint32Value());
    try {
        ::vkCmdWriteMicromapsPropertiesEXT(commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdWriteMicromapsPropertiesEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdWriteMicromapsPropertiesEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    micromapCount: " << (uint64_t)(micromapCount) << std::endl;
        std::cerr << "    pMicromaps: " << (uint64_t)(pMicromaps) << std::endl;
        std::cerr << "    queryType: " << (uint64_t)(queryType) << std::endl;
        std::cerr << "    queryPool: " << (uint64_t)(queryPool) << std::endl;
        std::cerr << "    firstQuery: " << (uint64_t)(firstQuery) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_opacity_micromap
static Napi::Value rawWriteMicromapsPropertiesEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 7) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsNumber() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt at 1 argument (micromapCount)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) micromapCount = (uint32_t)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Uint32Value());

    decltype(auto) pMicromaps = (VkMicromapEXT const*)GetAddress(env, info_[2]);

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (queryType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) queryType = (VkQueryType)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (dataSize)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) dataSize = (size_t)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());

    decltype(auto) pData = (void*)GetAddress(env, info_[5]);

    if (!info_[6].IsBigInt() && !info_[6].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 6 argument (stride)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) stride = (size_t)(info_[6].IsBigInt() ? info_[6].As<Napi::BigInt>().Uint64Value(&lossless) : info_[6].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkWriteMicromapsPropertiesEXT(device, micromapCount, pMicromaps, queryType, dataSize, pData, stride);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkWriteMicromapsPropertiesEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkWriteMicromapsPropertiesEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    micromapCount: " << (uint64_t)(micromapCount) << std::endl;
        std::cerr << "    pMicromaps: " << (uint64_t)(pMicromaps) << std::endl;
        std::cerr << "    queryType: " << (uint64_t)(queryType) << std::endl;
        std::cerr << "    dataSize: " << (uint64_t)(dataSize) << std::endl;
        std::cerr << "    pData: " << (uint64_t)(pData) << std::endl;
        std::cerr << "    stride: " << (uint64_t)(stride) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_opacity_micromap
static Napi::Value rawGetDeviceMicromapCompatibilityEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pVersionInfo = (VkMicromapVersionInfoEXT const*)GetAddress(env, info_[1]);

    decltype(auto) pCompatibility = (VkAccelerationStructureCompatibilityKHR*)GetAddress(env, info_[2]);
    try {
        ::vkGetDeviceMicromapCompatibilityEXT(device, pVersionInfo, pCompatibility);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeviceMicromapCompatibilityEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeviceMicromapCompatibilityEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pVersionInfo: " << (uint64_t)(pVersionInfo) << std::endl;
        std::cerr << "    pCompatibility: " << (uint64_t)(pCompatibility) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_opacity_micromap
static Napi::Value rawGetMicromapBuildSizesEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (buildType)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) buildType = (VkAccelerationStructureBuildTypeKHR)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pBuildInfo = (VkMicromapBuildInfoEXT const*)GetAddress(env, info_[2]);

    decltype(auto) pSizeInfo = (VkMicromapBuildSizesInfoEXT*)GetAddress(env, info_[3]);
    try {
        ::vkGetMicromapBuildSizesEXT(device, buildType, pBuildInfo, pSizeInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetMicromapBuildSizesEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetMicromapBuildSizesEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    buildType: " << (uint64_t)(buildType) << std::endl;
        std::cerr << "    pBuildInfo: " << (uint64_t)(pBuildInfo) << std::endl;
        std::cerr << "    pSizeInfo: " << (uint64_t)(pSizeInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_shader_module_identifier
static Napi::Value rawGetShaderModuleIdentifierEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (shaderModule)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) shaderModule = (VkShaderModule)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pIdentifier = (VkShaderModuleIdentifierEXT*)GetAddress(env, info_[2]);
    try {
        ::vkGetShaderModuleIdentifierEXT(device, shaderModule, pIdentifier);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetShaderModuleIdentifierEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetShaderModuleIdentifierEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    shaderModule: " << (uint64_t)(shaderModule) << std::endl;
        std::cerr << "    pIdentifier: " << (uint64_t)(pIdentifier) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_shader_module_identifier
static Napi::Value rawGetShaderModuleCreateInfoIdentifierEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkShaderModuleCreateInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pIdentifier = (VkShaderModuleIdentifierEXT*)GetAddress(env, info_[2]);
    try {
        ::vkGetShaderModuleCreateInfoIdentifierEXT(device, pCreateInfo, pIdentifier);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetShaderModuleCreateInfoIdentifierEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetShaderModuleCreateInfoIdentifierEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pIdentifier: " << (uint64_t)(pIdentifier) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_image_compression_control
static Napi::Value rawGetImageSubresourceLayout2EXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (image)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) image = (VkImage)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pSubresource = (VkImageSubresource2EXT const*)GetAddress(env, info_[2]);

    decltype(auto) pLayout = (VkSubresourceLayout2EXT*)GetAddress(env, info_[3]);
    try {
        ::vkGetImageSubresourceLayout2EXT(device, image, pSubresource, pLayout);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetImageSubresourceLayout2EXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetImageSubresourceLayout2EXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    image: " << (uint64_t)(image) << std::endl;
        std::cerr << "    pSubresource: " << (uint64_t)(pSubresource) << std::endl;
        std::cerr << "    pLayout: " << (uint64_t)(pLayout) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_pipeline_properties
static Napi::Value rawGetPipelinePropertiesEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pPipelineInfo = (VkPipelineInfoEXT const*)GetAddress(env, info_[1]);

    decltype(auto) pPipelineProperties = (VkBaseOutStructure*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPipelinePropertiesEXT(device, pPipelineInfo, pPipelineProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPipelinePropertiesEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPipelinePropertiesEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pPipelineInfo: " << (uint64_t)(pPipelineInfo) << std::endl;
        std::cerr << "    pPipelineProperties: " << (uint64_t)(pPipelineProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_EXT_metal_objects
static Napi::Value rawExportMetalObjectsEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 2) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pMetalObjectsInfo = (VkExportMetalObjectsInfoEXT*)GetAddress(env, info_[1]);
    try {
        ::vkExportMetalObjectsEXT(device, pMetalObjectsInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkExportMetalObjectsEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkExportMetalObjectsEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pMetalObjectsInfo: " << (uint64_t)(pMetalObjectsInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_QCOM_tile_properties
static Napi::Value rawGetFramebufferTilePropertiesQCOM(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (framebuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) framebuffer = (VkFramebuffer)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pPropertiesCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pProperties = (VkTilePropertiesQCOM*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetFramebufferTilePropertiesQCOM(device, framebuffer, pPropertiesCount, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetFramebufferTilePropertiesQCOM command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetFramebufferTilePropertiesQCOM)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    framebuffer: " << (uint64_t)(framebuffer) << std::endl;
        std::cerr << "    pPropertiesCount: " << (uint64_t)(pPropertiesCount) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_QCOM_tile_properties
static Napi::Value rawGetDynamicRenderingTilePropertiesQCOM(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pRenderingInfo = (VkRenderingInfo const*)GetAddress(env, info_[1]);

    decltype(auto) pProperties = (VkTilePropertiesQCOM*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetDynamicRenderingTilePropertiesQCOM(device, pRenderingInfo, pProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDynamicRenderingTilePropertiesQCOM command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDynamicRenderingTilePropertiesQCOM)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pRenderingInfo: " << (uint64_t)(pRenderingInfo) << std::endl;
        std::cerr << "    pProperties: " << (uint64_t)(pProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_optical_flow
static Napi::Value rawGetPhysicalDeviceOpticalFlowImageFormatsNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (physicalDevice)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) physicalDevice = (VkPhysicalDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pOpticalFlowImageFormatInfo = (VkOpticalFlowImageFormatInfoNV const*)GetAddress(env, info_[1]);

    decltype(auto) pFormatCount = (uint32_t*)GetAddress(env, info_[2]);

    decltype(auto) pImageFormatProperties = (VkOpticalFlowImageFormatPropertiesNV*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetPhysicalDeviceOpticalFlowImageFormatsNV(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetPhysicalDeviceOpticalFlowImageFormatsNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetPhysicalDeviceOpticalFlowImageFormatsNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    physicalDevice: " << (uint64_t)(physicalDevice) << std::endl;
        std::cerr << "    pOpticalFlowImageFormatInfo: " << (uint64_t)(pOpticalFlowImageFormatInfo) << std::endl;
        std::cerr << "    pFormatCount: " << (uint64_t)(pFormatCount) << std::endl;
        std::cerr << "    pImageFormatProperties: " << (uint64_t)(pImageFormatProperties) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_optical_flow
static Napi::Value rawCreateOpticalFlowSessionNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 4) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pCreateInfo = (VkOpticalFlowSessionCreateInfoNV const*)GetAddress(env, info_[1]);

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);

    decltype(auto) pSession = (VkOpticalFlowSessionNV*)GetAddress(env, info_[3]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkCreateOpticalFlowSessionNV(device, pCreateInfo, pAllocator, pSession);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCreateOpticalFlowSessionNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCreateOpticalFlowSessionNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pCreateInfo: " << (uint64_t)(pCreateInfo) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        std::cerr << "    pSession: " << (uint64_t)(pSession) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_optical_flow
static Napi::Value rawDestroyOpticalFlowSessionNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (session)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) session = (VkOpticalFlowSessionNV)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pAllocator = (VkAllocationCallbacks const*)GetAddress(env, info_[2]);
    try {
        ::vkDestroyOpticalFlowSessionNV(device, session, pAllocator);
    } catch(std::exception e) {
        std::cerr << "Exception with vkDestroyOpticalFlowSessionNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkDestroyOpticalFlowSessionNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    session: " << (uint64_t)(session) << std::endl;
        std::cerr << "    pAllocator: " << (uint64_t)(pAllocator) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_NV_optical_flow
static Napi::Value rawBindOpticalFlowSessionImageNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 5) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (session)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) session = (VkOpticalFlowSessionNV)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    if (!info_[2].IsBigInt() && !info_[2].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 2 argument (bindingPoint)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) bindingPoint = (VkOpticalFlowSessionBindingPointNV)(info_[2].IsBigInt() ? info_[2].As<Napi::BigInt>().Uint64Value(&lossless) : info_[2].As<Napi::Number>().Int64Value());

    if (!info_[3].IsBigInt() && !info_[3].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 3 argument (view)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) view = (VkImageView)(info_[3].IsBigInt() ? info_[3].As<Napi::BigInt>().Uint64Value(&lossless) : info_[3].As<Napi::Number>().Int64Value());

    if (!info_[4].IsBigInt() && !info_[4].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 4 argument (layout)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) layout = (VkImageLayout)(info_[4].IsBigInt() ? info_[4].As<Napi::BigInt>().Uint64Value(&lossless) : info_[4].As<Napi::Number>().Int64Value());
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkBindOpticalFlowSessionImageNV(device, session, bindingPoint, view, layout);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkBindOpticalFlowSessionImageNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkBindOpticalFlowSessionImageNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    session: " << (uint64_t)(session) << std::endl;
        std::cerr << "    bindingPoint: " << (uint64_t)(bindingPoint) << std::endl;
        std::cerr << "    view: " << (uint64_t)(view) << std::endl;
        std::cerr << "    layout: " << (uint64_t)(layout) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif
#ifdef VK_NV_optical_flow
static Napi::Value rawCmdOpticalFlowExecuteNV(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (commandBuffer)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) commandBuffer = (VkCommandBuffer)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    if (!info_[1].IsBigInt() && !info_[1].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 1 argument (session)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) session = (VkOpticalFlowSessionNV)(info_[1].IsBigInt() ? info_[1].As<Napi::BigInt>().Uint64Value(&lossless) : info_[1].As<Napi::Number>().Int64Value());

    decltype(auto) pExecuteInfo = (VkOpticalFlowExecuteInfoNV const*)GetAddress(env, info_[2]);
    try {
        ::vkCmdOpticalFlowExecuteNV(commandBuffer, session, pExecuteInfo);
    } catch(std::exception e) {
        std::cerr << "Exception with vkCmdOpticalFlowExecuteNV command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkCmdOpticalFlowExecuteNV)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    commandBuffer: " << (uint64_t)(commandBuffer) << std::endl;
        std::cerr << "    session: " << (uint64_t)(session) << std::endl;
        std::cerr << "    pExecuteInfo: " << (uint64_t)(pExecuteInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return env.Null();
}
#endif
#ifdef VK_EXT_device_fault
static Napi::Value rawGetDeviceFaultInfoEXT(const Napi::CallbackInfo& info_) {
    Napi::Env env = info_.Env();
    bool lossless = true;
    if (info_.Length() < 3) {
        Napi::TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException(); return env.Null();
    }
    
    if (!info_[0].IsBigInt() && !info_[0].IsBigInt()) { Napi::TypeError::New(env, "Wrong type, needs Number or BigInt (handle) at 0 argument (device)").ThrowAsJavaScriptException(); return env.Null(); }
    decltype(auto) device = (VkDevice)(info_[0].IsBigInt() ? info_[0].As<Napi::BigInt>().Uint64Value(&lossless) : info_[0].As<Napi::Number>().Int64Value());

    decltype(auto) pFaultCounts = (VkDeviceFaultCountsEXT*)GetAddress(env, info_[1]);

    decltype(auto) pFaultInfo = (VkDeviceFaultInfoEXT*)GetAddress(env, info_[2]);
    int32_t returnable = 0; try {
        decltype(auto) result = ::vkGetDeviceFaultInfoEXT(device, pFaultCounts, pFaultInfo);
        returnable = (int32_t)(result);
        if (typeid(decltype(result)) == typeid(VkResult) && result < 0) {
            std::string errorMsg = "Vulkan API Exception: " + std::to_string(result);
            std::cerr << errorMsg << std::endl;
            //Napi::Error::New(env, errorMsg).ThrowAsJavaScriptException();
            throw std::exception(errorMsg.c_str());
        }
        
        
        return Napi::Number::New(env, result);
    } catch(std::exception e) {
        std::cerr << "Exception with vkGetDeviceFaultInfoEXT command." << std::endl;
        std::cerr << "Caller pointer: " << ((uint64_t)(::vkGetDeviceFaultInfoEXT)) << std::endl;
        std::cerr << "Argument list: " << std::endl;
                std::cerr << "    device: " << (uint64_t)(device) << std::endl;
        std::cerr << "    pFaultCounts: " << (uint64_t)(pFaultCounts) << std::endl;
        std::cerr << "    pFaultInfo: " << (uint64_t)(pFaultInfo) << std::endl;
        Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
        throw e;
    }
    return Napi::Number::New(env, returnable);
}
#endif

static std::vector<std::function<void(unsigned int u, EXCEPTION_POINTERS* pExp)>> EXC_HANDLERS = {};

static Napi::Object Init(Napi::Env env, Napi::Object exports) {
#ifdef _WIN32
    EXC_HANDLERS.push_back([env](unsigned int u, EXCEPTION_POINTERS* pExp) {
        std::string error = "SE Exception: ";
        char result[11]; sprintf_s(result, 11, "0x%08X", u);
        error += "Unexpected Error (" + std::string(result) + ")";
        Napi::Error::New(env, error).ThrowAsJavaScriptException();
        std::cerr << error << std::endl;
        throw std::exception(error.c_str());
    });

    _set_se_translator([](unsigned int u, EXCEPTION_POINTERS* pExp) {
        for (auto fx : EXC_HANDLERS) { fx(u, pExp); }
    });
#endif

    //
#ifdef ENABLE_GLFW_SUPPORT
    glfwInit();
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
    glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
#endif

    volkInitialize();

#ifdef ENABLE_GLFW_SUPPORT
    glfwInitVulkanLoader(vkGetInstanceProcAddr);
#endif

    exports["VkBaseOutStructure_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBaseOutStructure, sType));
    exports["VkBaseOutStructure_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBaseOutStructure, pNext));
    exports["VkBaseOutStructure_sizeof"] = Napi::Number::New(env, sizeof(VkBaseOutStructure));
    exports["VkBaseInStructure_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBaseInStructure, sType));
    exports["VkBaseInStructure_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBaseInStructure, pNext));
    exports["VkBaseInStructure_sizeof"] = Napi::Number::New(env, sizeof(VkBaseInStructure));
    exports["VkOffset2D_x_offsetof"] = Napi::Number::New(env, offsetof(VkOffset2D, x));
    exports["VkOffset2D_y_offsetof"] = Napi::Number::New(env, offsetof(VkOffset2D, y));
    exports["VkOffset2D_sizeof"] = Napi::Number::New(env, sizeof(VkOffset2D));
    exports["VkOffset3D_x_offsetof"] = Napi::Number::New(env, offsetof(VkOffset3D, x));
    exports["VkOffset3D_y_offsetof"] = Napi::Number::New(env, offsetof(VkOffset3D, y));
    exports["VkOffset3D_z_offsetof"] = Napi::Number::New(env, offsetof(VkOffset3D, z));
    exports["VkOffset3D_sizeof"] = Napi::Number::New(env, sizeof(VkOffset3D));
    exports["VkExtent2D_width_offsetof"] = Napi::Number::New(env, offsetof(VkExtent2D, width));
    exports["VkExtent2D_height_offsetof"] = Napi::Number::New(env, offsetof(VkExtent2D, height));
    exports["VkExtent2D_sizeof"] = Napi::Number::New(env, sizeof(VkExtent2D));
    exports["VkExtent3D_width_offsetof"] = Napi::Number::New(env, offsetof(VkExtent3D, width));
    exports["VkExtent3D_height_offsetof"] = Napi::Number::New(env, offsetof(VkExtent3D, height));
    exports["VkExtent3D_depth_offsetof"] = Napi::Number::New(env, offsetof(VkExtent3D, depth));
    exports["VkExtent3D_sizeof"] = Napi::Number::New(env, sizeof(VkExtent3D));
    exports["VkViewport_x_offsetof"] = Napi::Number::New(env, offsetof(VkViewport, x));
    exports["VkViewport_y_offsetof"] = Napi::Number::New(env, offsetof(VkViewport, y));
    exports["VkViewport_width_offsetof"] = Napi::Number::New(env, offsetof(VkViewport, width));
    exports["VkViewport_height_offsetof"] = Napi::Number::New(env, offsetof(VkViewport, height));
    exports["VkViewport_minDepth_offsetof"] = Napi::Number::New(env, offsetof(VkViewport, minDepth));
    exports["VkViewport_maxDepth_offsetof"] = Napi::Number::New(env, offsetof(VkViewport, maxDepth));
    exports["VkViewport_sizeof"] = Napi::Number::New(env, sizeof(VkViewport));
    exports["VkRect2D_offset_offsetof"] = Napi::Number::New(env, offsetof(VkRect2D, offset));
    exports["VkRect2D_extent_offsetof"] = Napi::Number::New(env, offsetof(VkRect2D, extent));
    exports["VkRect2D_sizeof"] = Napi::Number::New(env, sizeof(VkRect2D));
    exports["VkClearRect_rect_offsetof"] = Napi::Number::New(env, offsetof(VkClearRect, rect));
    exports["VkClearRect_baseArrayLayer_offsetof"] = Napi::Number::New(env, offsetof(VkClearRect, baseArrayLayer));
    exports["VkClearRect_layerCount_offsetof"] = Napi::Number::New(env, offsetof(VkClearRect, layerCount));
    exports["VkClearRect_sizeof"] = Napi::Number::New(env, sizeof(VkClearRect));
    exports["VkComponentMapping_r_offsetof"] = Napi::Number::New(env, offsetof(VkComponentMapping, r));
    exports["VkComponentMapping_g_offsetof"] = Napi::Number::New(env, offsetof(VkComponentMapping, g));
    exports["VkComponentMapping_b_offsetof"] = Napi::Number::New(env, offsetof(VkComponentMapping, b));
    exports["VkComponentMapping_a_offsetof"] = Napi::Number::New(env, offsetof(VkComponentMapping, a));
    exports["VkComponentMapping_sizeof"] = Napi::Number::New(env, sizeof(VkComponentMapping));
    exports["VkPhysicalDeviceProperties_apiVersion_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProperties, apiVersion));
    exports["VkPhysicalDeviceProperties_driverVersion_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProperties, driverVersion));
    exports["VkPhysicalDeviceProperties_vendorID_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProperties, vendorID));
    exports["VkPhysicalDeviceProperties_deviceID_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProperties, deviceID));
    exports["VkPhysicalDeviceProperties_deviceType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProperties, deviceType));
    exports["VkPhysicalDeviceProperties_deviceName_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProperties, deviceName));
    exports["VkPhysicalDeviceProperties_pipelineCacheUUID_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProperties, pipelineCacheUUID));
    exports["VkPhysicalDeviceProperties_limits_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProperties, limits));
    exports["VkPhysicalDeviceProperties_sparseProperties_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProperties, sparseProperties));
    exports["VkPhysicalDeviceProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceProperties));
    exports["VkExtensionProperties_extensionName_offsetof"] = Napi::Number::New(env, offsetof(VkExtensionProperties, extensionName));
    exports["VkExtensionProperties_specVersion_offsetof"] = Napi::Number::New(env, offsetof(VkExtensionProperties, specVersion));
    exports["VkExtensionProperties_sizeof"] = Napi::Number::New(env, sizeof(VkExtensionProperties));
    exports["VkLayerProperties_layerName_offsetof"] = Napi::Number::New(env, offsetof(VkLayerProperties, layerName));
    exports["VkLayerProperties_specVersion_offsetof"] = Napi::Number::New(env, offsetof(VkLayerProperties, specVersion));
    exports["VkLayerProperties_implementationVersion_offsetof"] = Napi::Number::New(env, offsetof(VkLayerProperties, implementationVersion));
    exports["VkLayerProperties_description_offsetof"] = Napi::Number::New(env, offsetof(VkLayerProperties, description));
    exports["VkLayerProperties_sizeof"] = Napi::Number::New(env, sizeof(VkLayerProperties));
    exports["VkApplicationInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkApplicationInfo, sType));
    exports["VkApplicationInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkApplicationInfo, pNext));
    exports["VkApplicationInfo_pApplicationName_offsetof"] = Napi::Number::New(env, offsetof(VkApplicationInfo, pApplicationName));
    exports["VkApplicationInfo_applicationVersion_offsetof"] = Napi::Number::New(env, offsetof(VkApplicationInfo, applicationVersion));
    exports["VkApplicationInfo_pEngineName_offsetof"] = Napi::Number::New(env, offsetof(VkApplicationInfo, pEngineName));
    exports["VkApplicationInfo_engineVersion_offsetof"] = Napi::Number::New(env, offsetof(VkApplicationInfo, engineVersion));
    exports["VkApplicationInfo_apiVersion_offsetof"] = Napi::Number::New(env, offsetof(VkApplicationInfo, apiVersion));
    exports["VkApplicationInfo_sizeof"] = Napi::Number::New(env, sizeof(VkApplicationInfo));
    exports["VkAllocationCallbacks_pUserData_offsetof"] = Napi::Number::New(env, offsetof(VkAllocationCallbacks, pUserData));
    exports["VkAllocationCallbacks_pfnAllocation_offsetof"] = Napi::Number::New(env, offsetof(VkAllocationCallbacks, pfnAllocation));
    exports["VkAllocationCallbacks_pfnReallocation_offsetof"] = Napi::Number::New(env, offsetof(VkAllocationCallbacks, pfnReallocation));
    exports["VkAllocationCallbacks_pfnFree_offsetof"] = Napi::Number::New(env, offsetof(VkAllocationCallbacks, pfnFree));
    exports["VkAllocationCallbacks_pfnInternalAllocation_offsetof"] = Napi::Number::New(env, offsetof(VkAllocationCallbacks, pfnInternalAllocation));
    exports["VkAllocationCallbacks_pfnInternalFree_offsetof"] = Napi::Number::New(env, offsetof(VkAllocationCallbacks, pfnInternalFree));
    exports["VkAllocationCallbacks_sizeof"] = Napi::Number::New(env, sizeof(VkAllocationCallbacks));
    exports["VkDeviceQueueCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceQueueCreateInfo, sType));
    exports["VkDeviceQueueCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceQueueCreateInfo, pNext));
    exports["VkDeviceQueueCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceQueueCreateInfo, flags));
    exports["VkDeviceQueueCreateInfo_queueFamilyIndex_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceQueueCreateInfo, queueFamilyIndex));
    exports["VkDeviceQueueCreateInfo_queueCount_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceQueueCreateInfo, queueCount));
    exports["VkDeviceQueueCreateInfo_pQueuePriorities_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceQueueCreateInfo, pQueuePriorities));
    exports["VkDeviceQueueCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceQueueCreateInfo));
    exports["VkDeviceCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceCreateInfo, sType));
    exports["VkDeviceCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceCreateInfo, pNext));
    exports["VkDeviceCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceCreateInfo, flags));
    exports["VkDeviceCreateInfo_queueCreateInfoCount_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceCreateInfo, queueCreateInfoCount));
    exports["VkDeviceCreateInfo_pQueueCreateInfos_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceCreateInfo, pQueueCreateInfos));
    exports["VkDeviceCreateInfo_enabledLayerCount_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceCreateInfo, enabledLayerCount));
    exports["VkDeviceCreateInfo_ppEnabledLayerNames_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceCreateInfo, ppEnabledLayerNames));
    exports["VkDeviceCreateInfo_enabledExtensionCount_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceCreateInfo, enabledExtensionCount));
    exports["VkDeviceCreateInfo_ppEnabledExtensionNames_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceCreateInfo, ppEnabledExtensionNames));
    exports["VkDeviceCreateInfo_pEnabledFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceCreateInfo, pEnabledFeatures));
    exports["VkDeviceCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceCreateInfo));
    exports["VkInstanceCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkInstanceCreateInfo, sType));
    exports["VkInstanceCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkInstanceCreateInfo, pNext));
    exports["VkInstanceCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkInstanceCreateInfo, flags));
    exports["VkInstanceCreateInfo_pApplicationInfo_offsetof"] = Napi::Number::New(env, offsetof(VkInstanceCreateInfo, pApplicationInfo));
    exports["VkInstanceCreateInfo_enabledLayerCount_offsetof"] = Napi::Number::New(env, offsetof(VkInstanceCreateInfo, enabledLayerCount));
    exports["VkInstanceCreateInfo_ppEnabledLayerNames_offsetof"] = Napi::Number::New(env, offsetof(VkInstanceCreateInfo, ppEnabledLayerNames));
    exports["VkInstanceCreateInfo_enabledExtensionCount_offsetof"] = Napi::Number::New(env, offsetof(VkInstanceCreateInfo, enabledExtensionCount));
    exports["VkInstanceCreateInfo_ppEnabledExtensionNames_offsetof"] = Napi::Number::New(env, offsetof(VkInstanceCreateInfo, ppEnabledExtensionNames));
    exports["VkInstanceCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkInstanceCreateInfo));
    exports["VkQueueFamilyProperties_queueFlags_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyProperties, queueFlags));
    exports["VkQueueFamilyProperties_queueCount_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyProperties, queueCount));
    exports["VkQueueFamilyProperties_timestampValidBits_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyProperties, timestampValidBits));
    exports["VkQueueFamilyProperties_minImageTransferGranularity_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyProperties, minImageTransferGranularity));
    exports["VkQueueFamilyProperties_sizeof"] = Napi::Number::New(env, sizeof(VkQueueFamilyProperties));
    exports["VkPhysicalDeviceMemoryProperties_memoryTypeCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryProperties, memoryTypeCount));
    exports["VkPhysicalDeviceMemoryProperties_memoryTypes_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryProperties, memoryTypes));
    exports["VkPhysicalDeviceMemoryProperties_memoryHeapCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryProperties, memoryHeapCount));
    exports["VkPhysicalDeviceMemoryProperties_memoryHeaps_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryProperties, memoryHeaps));
    exports["VkPhysicalDeviceMemoryProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMemoryProperties));
    exports["VkMemoryAllocateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryAllocateInfo, sType));
    exports["VkMemoryAllocateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryAllocateInfo, pNext));
    exports["VkMemoryAllocateInfo_allocationSize_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryAllocateInfo, allocationSize));
    exports["VkMemoryAllocateInfo_memoryTypeIndex_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryAllocateInfo, memoryTypeIndex));
    exports["VkMemoryAllocateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryAllocateInfo));
    exports["VkMemoryRequirements_size_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryRequirements, size));
    exports["VkMemoryRequirements_alignment_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryRequirements, alignment));
    exports["VkMemoryRequirements_memoryTypeBits_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryRequirements, memoryTypeBits));
    exports["VkMemoryRequirements_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryRequirements));
    exports["VkSparseImageFormatProperties_aspectMask_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageFormatProperties, aspectMask));
    exports["VkSparseImageFormatProperties_imageGranularity_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageFormatProperties, imageGranularity));
    exports["VkSparseImageFormatProperties_flags_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageFormatProperties, flags));
    exports["VkSparseImageFormatProperties_sizeof"] = Napi::Number::New(env, sizeof(VkSparseImageFormatProperties));
    exports["VkSparseImageMemoryRequirements_formatProperties_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageMemoryRequirements, formatProperties));
    exports["VkSparseImageMemoryRequirements_imageMipTailFirstLod_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageMemoryRequirements, imageMipTailFirstLod));
    exports["VkSparseImageMemoryRequirements_imageMipTailSize_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageMemoryRequirements, imageMipTailSize));
    exports["VkSparseImageMemoryRequirements_imageMipTailOffset_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageMemoryRequirements, imageMipTailOffset));
    exports["VkSparseImageMemoryRequirements_imageMipTailStride_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageMemoryRequirements, imageMipTailStride));
    exports["VkSparseImageMemoryRequirements_sizeof"] = Napi::Number::New(env, sizeof(VkSparseImageMemoryRequirements));
    exports["VkMemoryType_propertyFlags_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryType, propertyFlags));
    exports["VkMemoryType_heapIndex_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryType, heapIndex));
    exports["VkMemoryType_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryType));
    exports["VkMemoryHeap_size_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryHeap, size));
    exports["VkMemoryHeap_flags_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryHeap, flags));
    exports["VkMemoryHeap_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryHeap));
    exports["VkMappedMemoryRange_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMappedMemoryRange, sType));
    exports["VkMappedMemoryRange_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMappedMemoryRange, pNext));
    exports["VkMappedMemoryRange_memory_offsetof"] = Napi::Number::New(env, offsetof(VkMappedMemoryRange, memory));
    exports["VkMappedMemoryRange_offset_offsetof"] = Napi::Number::New(env, offsetof(VkMappedMemoryRange, offset));
    exports["VkMappedMemoryRange_size_offsetof"] = Napi::Number::New(env, offsetof(VkMappedMemoryRange, size));
    exports["VkMappedMemoryRange_sizeof"] = Napi::Number::New(env, sizeof(VkMappedMemoryRange));
    exports["VkFormatProperties_linearTilingFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkFormatProperties, linearTilingFeatures));
    exports["VkFormatProperties_optimalTilingFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkFormatProperties, optimalTilingFeatures));
    exports["VkFormatProperties_bufferFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkFormatProperties, bufferFeatures));
    exports["VkFormatProperties_sizeof"] = Napi::Number::New(env, sizeof(VkFormatProperties));
    exports["VkImageFormatProperties_maxExtent_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatProperties, maxExtent));
    exports["VkImageFormatProperties_maxMipLevels_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatProperties, maxMipLevels));
    exports["VkImageFormatProperties_maxArrayLayers_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatProperties, maxArrayLayers));
    exports["VkImageFormatProperties_sampleCounts_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatProperties, sampleCounts));
    exports["VkImageFormatProperties_maxResourceSize_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatProperties, maxResourceSize));
    exports["VkImageFormatProperties_sizeof"] = Napi::Number::New(env, sizeof(VkImageFormatProperties));
    exports["VkDescriptorBufferInfo_buffer_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorBufferInfo, buffer));
    exports["VkDescriptorBufferInfo_offset_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorBufferInfo, offset));
    exports["VkDescriptorBufferInfo_range_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorBufferInfo, range));
    exports["VkDescriptorBufferInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorBufferInfo));
    exports["VkDescriptorImageInfo_sampler_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorImageInfo, sampler));
    exports["VkDescriptorImageInfo_imageView_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorImageInfo, imageView));
    exports["VkDescriptorImageInfo_imageLayout_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorImageInfo, imageLayout));
    exports["VkDescriptorImageInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorImageInfo));
    exports["VkWriteDescriptorSet_sType_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSet, sType));
    exports["VkWriteDescriptorSet_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSet, pNext));
    exports["VkWriteDescriptorSet_dstSet_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSet, dstSet));
    exports["VkWriteDescriptorSet_dstBinding_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSet, dstBinding));
    exports["VkWriteDescriptorSet_dstArrayElement_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSet, dstArrayElement));
    exports["VkWriteDescriptorSet_descriptorCount_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSet, descriptorCount));
    exports["VkWriteDescriptorSet_descriptorType_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSet, descriptorType));
    exports["VkWriteDescriptorSet_pImageInfo_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSet, pImageInfo));
    exports["VkWriteDescriptorSet_pBufferInfo_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSet, pBufferInfo));
    exports["VkWriteDescriptorSet_pTexelBufferView_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSet, pTexelBufferView));
    exports["VkWriteDescriptorSet_sizeof"] = Napi::Number::New(env, sizeof(VkWriteDescriptorSet));
    exports["VkCopyDescriptorSet_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCopyDescriptorSet, sType));
    exports["VkCopyDescriptorSet_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCopyDescriptorSet, pNext));
    exports["VkCopyDescriptorSet_srcSet_offsetof"] = Napi::Number::New(env, offsetof(VkCopyDescriptorSet, srcSet));
    exports["VkCopyDescriptorSet_srcBinding_offsetof"] = Napi::Number::New(env, offsetof(VkCopyDescriptorSet, srcBinding));
    exports["VkCopyDescriptorSet_srcArrayElement_offsetof"] = Napi::Number::New(env, offsetof(VkCopyDescriptorSet, srcArrayElement));
    exports["VkCopyDescriptorSet_dstSet_offsetof"] = Napi::Number::New(env, offsetof(VkCopyDescriptorSet, dstSet));
    exports["VkCopyDescriptorSet_dstBinding_offsetof"] = Napi::Number::New(env, offsetof(VkCopyDescriptorSet, dstBinding));
    exports["VkCopyDescriptorSet_dstArrayElement_offsetof"] = Napi::Number::New(env, offsetof(VkCopyDescriptorSet, dstArrayElement));
    exports["VkCopyDescriptorSet_descriptorCount_offsetof"] = Napi::Number::New(env, offsetof(VkCopyDescriptorSet, descriptorCount));
    exports["VkCopyDescriptorSet_sizeof"] = Napi::Number::New(env, sizeof(VkCopyDescriptorSet));
    exports["VkBufferCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCreateInfo, sType));
    exports["VkBufferCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCreateInfo, pNext));
    exports["VkBufferCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCreateInfo, flags));
    exports["VkBufferCreateInfo_size_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCreateInfo, size));
    exports["VkBufferCreateInfo_usage_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCreateInfo, usage));
    exports["VkBufferCreateInfo_sharingMode_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCreateInfo, sharingMode));
    exports["VkBufferCreateInfo_queueFamilyIndexCount_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCreateInfo, queueFamilyIndexCount));
    exports["VkBufferCreateInfo_pQueueFamilyIndices_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCreateInfo, pQueueFamilyIndices));
    exports["VkBufferCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkBufferCreateInfo));
    exports["VkBufferViewCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBufferViewCreateInfo, sType));
    exports["VkBufferViewCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBufferViewCreateInfo, pNext));
    exports["VkBufferViewCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkBufferViewCreateInfo, flags));
    exports["VkBufferViewCreateInfo_buffer_offsetof"] = Napi::Number::New(env, offsetof(VkBufferViewCreateInfo, buffer));
    exports["VkBufferViewCreateInfo_format_offsetof"] = Napi::Number::New(env, offsetof(VkBufferViewCreateInfo, format));
    exports["VkBufferViewCreateInfo_offset_offsetof"] = Napi::Number::New(env, offsetof(VkBufferViewCreateInfo, offset));
    exports["VkBufferViewCreateInfo_range_offsetof"] = Napi::Number::New(env, offsetof(VkBufferViewCreateInfo, range));
    exports["VkBufferViewCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkBufferViewCreateInfo));
    exports["VkImageSubresource_aspectMask_offsetof"] = Napi::Number::New(env, offsetof(VkImageSubresource, aspectMask));
    exports["VkImageSubresource_mipLevel_offsetof"] = Napi::Number::New(env, offsetof(VkImageSubresource, mipLevel));
    exports["VkImageSubresource_arrayLayer_offsetof"] = Napi::Number::New(env, offsetof(VkImageSubresource, arrayLayer));
    exports["VkImageSubresource_sizeof"] = Napi::Number::New(env, sizeof(VkImageSubresource));
    exports["VkImageSubresourceLayers_aspectMask_offsetof"] = Napi::Number::New(env, offsetof(VkImageSubresourceLayers, aspectMask));
    exports["VkImageSubresourceLayers_mipLevel_offsetof"] = Napi::Number::New(env, offsetof(VkImageSubresourceLayers, mipLevel));
    exports["VkImageSubresourceLayers_baseArrayLayer_offsetof"] = Napi::Number::New(env, offsetof(VkImageSubresourceLayers, baseArrayLayer));
    exports["VkImageSubresourceLayers_layerCount_offsetof"] = Napi::Number::New(env, offsetof(VkImageSubresourceLayers, layerCount));
    exports["VkImageSubresourceLayers_sizeof"] = Napi::Number::New(env, sizeof(VkImageSubresourceLayers));
    exports["VkImageSubresourceRange_aspectMask_offsetof"] = Napi::Number::New(env, offsetof(VkImageSubresourceRange, aspectMask));
    exports["VkImageSubresourceRange_baseMipLevel_offsetof"] = Napi::Number::New(env, offsetof(VkImageSubresourceRange, baseMipLevel));
    exports["VkImageSubresourceRange_levelCount_offsetof"] = Napi::Number::New(env, offsetof(VkImageSubresourceRange, levelCount));
    exports["VkImageSubresourceRange_baseArrayLayer_offsetof"] = Napi::Number::New(env, offsetof(VkImageSubresourceRange, baseArrayLayer));
    exports["VkImageSubresourceRange_layerCount_offsetof"] = Napi::Number::New(env, offsetof(VkImageSubresourceRange, layerCount));
    exports["VkImageSubresourceRange_sizeof"] = Napi::Number::New(env, sizeof(VkImageSubresourceRange));
    exports["VkMemoryBarrier_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryBarrier, sType));
    exports["VkMemoryBarrier_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryBarrier, pNext));
    exports["VkMemoryBarrier_srcAccessMask_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryBarrier, srcAccessMask));
    exports["VkMemoryBarrier_dstAccessMask_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryBarrier, dstAccessMask));
    exports["VkMemoryBarrier_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryBarrier));
    exports["VkBufferMemoryBarrier_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier, sType));
    exports["VkBufferMemoryBarrier_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier, pNext));
    exports["VkBufferMemoryBarrier_srcAccessMask_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier, srcAccessMask));
    exports["VkBufferMemoryBarrier_dstAccessMask_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier, dstAccessMask));
    exports["VkBufferMemoryBarrier_srcQueueFamilyIndex_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier, srcQueueFamilyIndex));
    exports["VkBufferMemoryBarrier_dstQueueFamilyIndex_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier, dstQueueFamilyIndex));
    exports["VkBufferMemoryBarrier_buffer_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier, buffer));
    exports["VkBufferMemoryBarrier_offset_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier, offset));
    exports["VkBufferMemoryBarrier_size_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier, size));
    exports["VkBufferMemoryBarrier_sizeof"] = Napi::Number::New(env, sizeof(VkBufferMemoryBarrier));
    exports["VkImageMemoryBarrier_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier, sType));
    exports["VkImageMemoryBarrier_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier, pNext));
    exports["VkImageMemoryBarrier_srcAccessMask_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier, srcAccessMask));
    exports["VkImageMemoryBarrier_dstAccessMask_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier, dstAccessMask));
    exports["VkImageMemoryBarrier_oldLayout_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier, oldLayout));
    exports["VkImageMemoryBarrier_newLayout_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier, newLayout));
    exports["VkImageMemoryBarrier_srcQueueFamilyIndex_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier, srcQueueFamilyIndex));
    exports["VkImageMemoryBarrier_dstQueueFamilyIndex_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier, dstQueueFamilyIndex));
    exports["VkImageMemoryBarrier_image_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier, image));
    exports["VkImageMemoryBarrier_subresourceRange_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier, subresourceRange));
    exports["VkImageMemoryBarrier_sizeof"] = Napi::Number::New(env, sizeof(VkImageMemoryBarrier));
    exports["VkImageCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageCreateInfo, sType));
    exports["VkImageCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageCreateInfo, pNext));
    exports["VkImageCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkImageCreateInfo, flags));
    exports["VkImageCreateInfo_imageType_offsetof"] = Napi::Number::New(env, offsetof(VkImageCreateInfo, imageType));
    exports["VkImageCreateInfo_format_offsetof"] = Napi::Number::New(env, offsetof(VkImageCreateInfo, format));
    exports["VkImageCreateInfo_extent_offsetof"] = Napi::Number::New(env, offsetof(VkImageCreateInfo, extent));
    exports["VkImageCreateInfo_mipLevels_offsetof"] = Napi::Number::New(env, offsetof(VkImageCreateInfo, mipLevels));
    exports["VkImageCreateInfo_arrayLayers_offsetof"] = Napi::Number::New(env, offsetof(VkImageCreateInfo, arrayLayers));
    exports["VkImageCreateInfo_samples_offsetof"] = Napi::Number::New(env, offsetof(VkImageCreateInfo, samples));
    exports["VkImageCreateInfo_tiling_offsetof"] = Napi::Number::New(env, offsetof(VkImageCreateInfo, tiling));
    exports["VkImageCreateInfo_usage_offsetof"] = Napi::Number::New(env, offsetof(VkImageCreateInfo, usage));
    exports["VkImageCreateInfo_sharingMode_offsetof"] = Napi::Number::New(env, offsetof(VkImageCreateInfo, sharingMode));
    exports["VkImageCreateInfo_queueFamilyIndexCount_offsetof"] = Napi::Number::New(env, offsetof(VkImageCreateInfo, queueFamilyIndexCount));
    exports["VkImageCreateInfo_pQueueFamilyIndices_offsetof"] = Napi::Number::New(env, offsetof(VkImageCreateInfo, pQueueFamilyIndices));
    exports["VkImageCreateInfo_initialLayout_offsetof"] = Napi::Number::New(env, offsetof(VkImageCreateInfo, initialLayout));
    exports["VkImageCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkImageCreateInfo));
    exports["VkSubresourceLayout_offset_offsetof"] = Napi::Number::New(env, offsetof(VkSubresourceLayout, offset));
    exports["VkSubresourceLayout_size_offsetof"] = Napi::Number::New(env, offsetof(VkSubresourceLayout, size));
    exports["VkSubresourceLayout_rowPitch_offsetof"] = Napi::Number::New(env, offsetof(VkSubresourceLayout, rowPitch));
    exports["VkSubresourceLayout_arrayPitch_offsetof"] = Napi::Number::New(env, offsetof(VkSubresourceLayout, arrayPitch));
    exports["VkSubresourceLayout_depthPitch_offsetof"] = Napi::Number::New(env, offsetof(VkSubresourceLayout, depthPitch));
    exports["VkSubresourceLayout_sizeof"] = Napi::Number::New(env, sizeof(VkSubresourceLayout));
    exports["VkImageViewCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewCreateInfo, sType));
    exports["VkImageViewCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewCreateInfo, pNext));
    exports["VkImageViewCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewCreateInfo, flags));
    exports["VkImageViewCreateInfo_image_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewCreateInfo, image));
    exports["VkImageViewCreateInfo_viewType_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewCreateInfo, viewType));
    exports["VkImageViewCreateInfo_format_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewCreateInfo, format));
    exports["VkImageViewCreateInfo_components_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewCreateInfo, components));
    exports["VkImageViewCreateInfo_subresourceRange_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewCreateInfo, subresourceRange));
    exports["VkImageViewCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkImageViewCreateInfo));
    exports["VkBufferCopy_srcOffset_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCopy, srcOffset));
    exports["VkBufferCopy_dstOffset_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCopy, dstOffset));
    exports["VkBufferCopy_size_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCopy, size));
    exports["VkBufferCopy_sizeof"] = Napi::Number::New(env, sizeof(VkBufferCopy));
    exports["VkSparseMemoryBind_resourceOffset_offsetof"] = Napi::Number::New(env, offsetof(VkSparseMemoryBind, resourceOffset));
    exports["VkSparseMemoryBind_size_offsetof"] = Napi::Number::New(env, offsetof(VkSparseMemoryBind, size));
    exports["VkSparseMemoryBind_memory_offsetof"] = Napi::Number::New(env, offsetof(VkSparseMemoryBind, memory));
    exports["VkSparseMemoryBind_memoryOffset_offsetof"] = Napi::Number::New(env, offsetof(VkSparseMemoryBind, memoryOffset));
    exports["VkSparseMemoryBind_flags_offsetof"] = Napi::Number::New(env, offsetof(VkSparseMemoryBind, flags));
    exports["VkSparseMemoryBind_sizeof"] = Napi::Number::New(env, sizeof(VkSparseMemoryBind));
    exports["VkSparseImageMemoryBind_subresource_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageMemoryBind, subresource));
    exports["VkSparseImageMemoryBind_offset_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageMemoryBind, offset));
    exports["VkSparseImageMemoryBind_extent_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageMemoryBind, extent));
    exports["VkSparseImageMemoryBind_memory_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageMemoryBind, memory));
    exports["VkSparseImageMemoryBind_memoryOffset_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageMemoryBind, memoryOffset));
    exports["VkSparseImageMemoryBind_flags_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageMemoryBind, flags));
    exports["VkSparseImageMemoryBind_sizeof"] = Napi::Number::New(env, sizeof(VkSparseImageMemoryBind));
    exports["VkSparseBufferMemoryBindInfo_buffer_offsetof"] = Napi::Number::New(env, offsetof(VkSparseBufferMemoryBindInfo, buffer));
    exports["VkSparseBufferMemoryBindInfo_bindCount_offsetof"] = Napi::Number::New(env, offsetof(VkSparseBufferMemoryBindInfo, bindCount));
    exports["VkSparseBufferMemoryBindInfo_pBinds_offsetof"] = Napi::Number::New(env, offsetof(VkSparseBufferMemoryBindInfo, pBinds));
    exports["VkSparseBufferMemoryBindInfo_sizeof"] = Napi::Number::New(env, sizeof(VkSparseBufferMemoryBindInfo));
    exports["VkSparseImageOpaqueMemoryBindInfo_image_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageOpaqueMemoryBindInfo, image));
    exports["VkSparseImageOpaqueMemoryBindInfo_bindCount_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageOpaqueMemoryBindInfo, bindCount));
    exports["VkSparseImageOpaqueMemoryBindInfo_pBinds_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageOpaqueMemoryBindInfo, pBinds));
    exports["VkSparseImageOpaqueMemoryBindInfo_sizeof"] = Napi::Number::New(env, sizeof(VkSparseImageOpaqueMemoryBindInfo));
    exports["VkSparseImageMemoryBindInfo_image_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageMemoryBindInfo, image));
    exports["VkSparseImageMemoryBindInfo_bindCount_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageMemoryBindInfo, bindCount));
    exports["VkSparseImageMemoryBindInfo_pBinds_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageMemoryBindInfo, pBinds));
    exports["VkSparseImageMemoryBindInfo_sizeof"] = Napi::Number::New(env, sizeof(VkSparseImageMemoryBindInfo));
    exports["VkBindSparseInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBindSparseInfo, sType));
    exports["VkBindSparseInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBindSparseInfo, pNext));
    exports["VkBindSparseInfo_waitSemaphoreCount_offsetof"] = Napi::Number::New(env, offsetof(VkBindSparseInfo, waitSemaphoreCount));
    exports["VkBindSparseInfo_pWaitSemaphores_offsetof"] = Napi::Number::New(env, offsetof(VkBindSparseInfo, pWaitSemaphores));
    exports["VkBindSparseInfo_bufferBindCount_offsetof"] = Napi::Number::New(env, offsetof(VkBindSparseInfo, bufferBindCount));
    exports["VkBindSparseInfo_pBufferBinds_offsetof"] = Napi::Number::New(env, offsetof(VkBindSparseInfo, pBufferBinds));
    exports["VkBindSparseInfo_imageOpaqueBindCount_offsetof"] = Napi::Number::New(env, offsetof(VkBindSparseInfo, imageOpaqueBindCount));
    exports["VkBindSparseInfo_pImageOpaqueBinds_offsetof"] = Napi::Number::New(env, offsetof(VkBindSparseInfo, pImageOpaqueBinds));
    exports["VkBindSparseInfo_imageBindCount_offsetof"] = Napi::Number::New(env, offsetof(VkBindSparseInfo, imageBindCount));
    exports["VkBindSparseInfo_pImageBinds_offsetof"] = Napi::Number::New(env, offsetof(VkBindSparseInfo, pImageBinds));
    exports["VkBindSparseInfo_signalSemaphoreCount_offsetof"] = Napi::Number::New(env, offsetof(VkBindSparseInfo, signalSemaphoreCount));
    exports["VkBindSparseInfo_pSignalSemaphores_offsetof"] = Napi::Number::New(env, offsetof(VkBindSparseInfo, pSignalSemaphores));
    exports["VkBindSparseInfo_sizeof"] = Napi::Number::New(env, sizeof(VkBindSparseInfo));
    exports["VkImageCopy_srcSubresource_offsetof"] = Napi::Number::New(env, offsetof(VkImageCopy, srcSubresource));
    exports["VkImageCopy_srcOffset_offsetof"] = Napi::Number::New(env, offsetof(VkImageCopy, srcOffset));
    exports["VkImageCopy_dstSubresource_offsetof"] = Napi::Number::New(env, offsetof(VkImageCopy, dstSubresource));
    exports["VkImageCopy_dstOffset_offsetof"] = Napi::Number::New(env, offsetof(VkImageCopy, dstOffset));
    exports["VkImageCopy_extent_offsetof"] = Napi::Number::New(env, offsetof(VkImageCopy, extent));
    exports["VkImageCopy_sizeof"] = Napi::Number::New(env, sizeof(VkImageCopy));
    exports["VkImageBlit_srcSubresource_offsetof"] = Napi::Number::New(env, offsetof(VkImageBlit, srcSubresource));
    exports["VkImageBlit_srcOffsets_offsetof"] = Napi::Number::New(env, offsetof(VkImageBlit, srcOffsets));
    exports["VkImageBlit_dstSubresource_offsetof"] = Napi::Number::New(env, offsetof(VkImageBlit, dstSubresource));
    exports["VkImageBlit_dstOffsets_offsetof"] = Napi::Number::New(env, offsetof(VkImageBlit, dstOffsets));
    exports["VkImageBlit_sizeof"] = Napi::Number::New(env, sizeof(VkImageBlit));
    exports["VkBufferImageCopy_bufferOffset_offsetof"] = Napi::Number::New(env, offsetof(VkBufferImageCopy, bufferOffset));
    exports["VkBufferImageCopy_bufferRowLength_offsetof"] = Napi::Number::New(env, offsetof(VkBufferImageCopy, bufferRowLength));
    exports["VkBufferImageCopy_bufferImageHeight_offsetof"] = Napi::Number::New(env, offsetof(VkBufferImageCopy, bufferImageHeight));
    exports["VkBufferImageCopy_imageSubresource_offsetof"] = Napi::Number::New(env, offsetof(VkBufferImageCopy, imageSubresource));
    exports["VkBufferImageCopy_imageOffset_offsetof"] = Napi::Number::New(env, offsetof(VkBufferImageCopy, imageOffset));
    exports["VkBufferImageCopy_imageExtent_offsetof"] = Napi::Number::New(env, offsetof(VkBufferImageCopy, imageExtent));
    exports["VkBufferImageCopy_sizeof"] = Napi::Number::New(env, sizeof(VkBufferImageCopy));
#ifdef VK_NV_copy_memory_indirect
    exports["VkCopyMemoryIndirectCommandNV_srcAddress_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryIndirectCommandNV, srcAddress));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkCopyMemoryIndirectCommandNV_dstAddress_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryIndirectCommandNV, dstAddress));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkCopyMemoryIndirectCommandNV_size_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryIndirectCommandNV, size));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkCopyMemoryIndirectCommandNV_sizeof"] = Napi::Number::New(env, sizeof(VkCopyMemoryIndirectCommandNV));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkCopyMemoryToImageIndirectCommandNV_srcAddress_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryToImageIndirectCommandNV, srcAddress));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkCopyMemoryToImageIndirectCommandNV_bufferRowLength_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryToImageIndirectCommandNV, bufferRowLength));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkCopyMemoryToImageIndirectCommandNV_bufferImageHeight_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryToImageIndirectCommandNV, bufferImageHeight));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkCopyMemoryToImageIndirectCommandNV_imageSubresource_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryToImageIndirectCommandNV, imageSubresource));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkCopyMemoryToImageIndirectCommandNV_imageOffset_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryToImageIndirectCommandNV, imageOffset));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkCopyMemoryToImageIndirectCommandNV_imageExtent_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryToImageIndirectCommandNV, imageExtent));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkCopyMemoryToImageIndirectCommandNV_sizeof"] = Napi::Number::New(env, sizeof(VkCopyMemoryToImageIndirectCommandNV));
#endif
    exports["VkImageResolve_srcSubresource_offsetof"] = Napi::Number::New(env, offsetof(VkImageResolve, srcSubresource));
    exports["VkImageResolve_srcOffset_offsetof"] = Napi::Number::New(env, offsetof(VkImageResolve, srcOffset));
    exports["VkImageResolve_dstSubresource_offsetof"] = Napi::Number::New(env, offsetof(VkImageResolve, dstSubresource));
    exports["VkImageResolve_dstOffset_offsetof"] = Napi::Number::New(env, offsetof(VkImageResolve, dstOffset));
    exports["VkImageResolve_extent_offsetof"] = Napi::Number::New(env, offsetof(VkImageResolve, extent));
    exports["VkImageResolve_sizeof"] = Napi::Number::New(env, sizeof(VkImageResolve));
    exports["VkShaderModuleCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkShaderModuleCreateInfo, sType));
    exports["VkShaderModuleCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkShaderModuleCreateInfo, pNext));
    exports["VkShaderModuleCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkShaderModuleCreateInfo, flags));
    exports["VkShaderModuleCreateInfo_codeSize_offsetof"] = Napi::Number::New(env, offsetof(VkShaderModuleCreateInfo, codeSize));
    exports["VkShaderModuleCreateInfo_pCode_offsetof"] = Napi::Number::New(env, offsetof(VkShaderModuleCreateInfo, pCode));
    exports["VkShaderModuleCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkShaderModuleCreateInfo));
    exports["VkDescriptorSetLayoutBinding_binding_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutBinding, binding));
    exports["VkDescriptorSetLayoutBinding_descriptorType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutBinding, descriptorType));
    exports["VkDescriptorSetLayoutBinding_descriptorCount_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutBinding, descriptorCount));
    exports["VkDescriptorSetLayoutBinding_stageFlags_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutBinding, stageFlags));
    exports["VkDescriptorSetLayoutBinding_pImmutableSamplers_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutBinding, pImmutableSamplers));
    exports["VkDescriptorSetLayoutBinding_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorSetLayoutBinding));
    exports["VkDescriptorSetLayoutCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutCreateInfo, sType));
    exports["VkDescriptorSetLayoutCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutCreateInfo, pNext));
    exports["VkDescriptorSetLayoutCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutCreateInfo, flags));
    exports["VkDescriptorSetLayoutCreateInfo_bindingCount_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutCreateInfo, bindingCount));
    exports["VkDescriptorSetLayoutCreateInfo_pBindings_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutCreateInfo, pBindings));
    exports["VkDescriptorSetLayoutCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorSetLayoutCreateInfo));
    exports["VkDescriptorPoolSize_type_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorPoolSize, type));
    exports["VkDescriptorPoolSize_descriptorCount_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorPoolSize, descriptorCount));
    exports["VkDescriptorPoolSize_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorPoolSize));
    exports["VkDescriptorPoolCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorPoolCreateInfo, sType));
    exports["VkDescriptorPoolCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorPoolCreateInfo, pNext));
    exports["VkDescriptorPoolCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorPoolCreateInfo, flags));
    exports["VkDescriptorPoolCreateInfo_maxSets_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorPoolCreateInfo, maxSets));
    exports["VkDescriptorPoolCreateInfo_poolSizeCount_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorPoolCreateInfo, poolSizeCount));
    exports["VkDescriptorPoolCreateInfo_pPoolSizes_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorPoolCreateInfo, pPoolSizes));
    exports["VkDescriptorPoolCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorPoolCreateInfo));
    exports["VkDescriptorSetAllocateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetAllocateInfo, sType));
    exports["VkDescriptorSetAllocateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetAllocateInfo, pNext));
    exports["VkDescriptorSetAllocateInfo_descriptorPool_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetAllocateInfo, descriptorPool));
    exports["VkDescriptorSetAllocateInfo_descriptorSetCount_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetAllocateInfo, descriptorSetCount));
    exports["VkDescriptorSetAllocateInfo_pSetLayouts_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetAllocateInfo, pSetLayouts));
    exports["VkDescriptorSetAllocateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorSetAllocateInfo));
    exports["VkSpecializationMapEntry_constantID_offsetof"] = Napi::Number::New(env, offsetof(VkSpecializationMapEntry, constantID));
    exports["VkSpecializationMapEntry_offset_offsetof"] = Napi::Number::New(env, offsetof(VkSpecializationMapEntry, offset));
    exports["VkSpecializationMapEntry_size_offsetof"] = Napi::Number::New(env, offsetof(VkSpecializationMapEntry, size));
    exports["VkSpecializationMapEntry_sizeof"] = Napi::Number::New(env, sizeof(VkSpecializationMapEntry));
    exports["VkSpecializationInfo_mapEntryCount_offsetof"] = Napi::Number::New(env, offsetof(VkSpecializationInfo, mapEntryCount));
    exports["VkSpecializationInfo_pMapEntries_offsetof"] = Napi::Number::New(env, offsetof(VkSpecializationInfo, pMapEntries));
    exports["VkSpecializationInfo_dataSize_offsetof"] = Napi::Number::New(env, offsetof(VkSpecializationInfo, dataSize));
    exports["VkSpecializationInfo_pData_offsetof"] = Napi::Number::New(env, offsetof(VkSpecializationInfo, pData));
    exports["VkSpecializationInfo_sizeof"] = Napi::Number::New(env, sizeof(VkSpecializationInfo));
    exports["VkPipelineShaderStageCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineShaderStageCreateInfo, sType));
    exports["VkPipelineShaderStageCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineShaderStageCreateInfo, pNext));
    exports["VkPipelineShaderStageCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineShaderStageCreateInfo, flags));
    exports["VkPipelineShaderStageCreateInfo_stage_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineShaderStageCreateInfo, stage));
    exports["VkPipelineShaderStageCreateInfo_module_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineShaderStageCreateInfo, module));
    exports["VkPipelineShaderStageCreateInfo_pName_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineShaderStageCreateInfo, pName));
    exports["VkPipelineShaderStageCreateInfo_pSpecializationInfo_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineShaderStageCreateInfo, pSpecializationInfo));
    exports["VkPipelineShaderStageCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineShaderStageCreateInfo));
    exports["VkComputePipelineCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkComputePipelineCreateInfo, sType));
    exports["VkComputePipelineCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkComputePipelineCreateInfo, pNext));
    exports["VkComputePipelineCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkComputePipelineCreateInfo, flags));
    exports["VkComputePipelineCreateInfo_stage_offsetof"] = Napi::Number::New(env, offsetof(VkComputePipelineCreateInfo, stage));
    exports["VkComputePipelineCreateInfo_layout_offsetof"] = Napi::Number::New(env, offsetof(VkComputePipelineCreateInfo, layout));
    exports["VkComputePipelineCreateInfo_basePipelineHandle_offsetof"] = Napi::Number::New(env, offsetof(VkComputePipelineCreateInfo, basePipelineHandle));
    exports["VkComputePipelineCreateInfo_basePipelineIndex_offsetof"] = Napi::Number::New(env, offsetof(VkComputePipelineCreateInfo, basePipelineIndex));
    exports["VkComputePipelineCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkComputePipelineCreateInfo));
    exports["VkVertexInputBindingDescription_binding_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputBindingDescription, binding));
    exports["VkVertexInputBindingDescription_stride_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputBindingDescription, stride));
    exports["VkVertexInputBindingDescription_inputRate_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputBindingDescription, inputRate));
    exports["VkVertexInputBindingDescription_sizeof"] = Napi::Number::New(env, sizeof(VkVertexInputBindingDescription));
    exports["VkVertexInputAttributeDescription_location_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputAttributeDescription, location));
    exports["VkVertexInputAttributeDescription_binding_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputAttributeDescription, binding));
    exports["VkVertexInputAttributeDescription_format_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputAttributeDescription, format));
    exports["VkVertexInputAttributeDescription_offset_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputAttributeDescription, offset));
    exports["VkVertexInputAttributeDescription_sizeof"] = Napi::Number::New(env, sizeof(VkVertexInputAttributeDescription));
    exports["VkPipelineVertexInputStateCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineVertexInputStateCreateInfo, sType));
    exports["VkPipelineVertexInputStateCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineVertexInputStateCreateInfo, pNext));
    exports["VkPipelineVertexInputStateCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineVertexInputStateCreateInfo, flags));
    exports["VkPipelineVertexInputStateCreateInfo_vertexBindingDescriptionCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineVertexInputStateCreateInfo, vertexBindingDescriptionCount));
    exports["VkPipelineVertexInputStateCreateInfo_pVertexBindingDescriptions_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineVertexInputStateCreateInfo, pVertexBindingDescriptions));
    exports["VkPipelineVertexInputStateCreateInfo_vertexAttributeDescriptionCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineVertexInputStateCreateInfo, vertexAttributeDescriptionCount));
    exports["VkPipelineVertexInputStateCreateInfo_pVertexAttributeDescriptions_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineVertexInputStateCreateInfo, pVertexAttributeDescriptions));
    exports["VkPipelineVertexInputStateCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineVertexInputStateCreateInfo));
    exports["VkPipelineInputAssemblyStateCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineInputAssemblyStateCreateInfo, sType));
    exports["VkPipelineInputAssemblyStateCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineInputAssemblyStateCreateInfo, pNext));
    exports["VkPipelineInputAssemblyStateCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineInputAssemblyStateCreateInfo, flags));
    exports["VkPipelineInputAssemblyStateCreateInfo_topology_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineInputAssemblyStateCreateInfo, topology));
    exports["VkPipelineInputAssemblyStateCreateInfo_primitiveRestartEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineInputAssemblyStateCreateInfo, primitiveRestartEnable));
    exports["VkPipelineInputAssemblyStateCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineInputAssemblyStateCreateInfo));
    exports["VkPipelineTessellationStateCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineTessellationStateCreateInfo, sType));
    exports["VkPipelineTessellationStateCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineTessellationStateCreateInfo, pNext));
    exports["VkPipelineTessellationStateCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineTessellationStateCreateInfo, flags));
    exports["VkPipelineTessellationStateCreateInfo_patchControlPoints_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineTessellationStateCreateInfo, patchControlPoints));
    exports["VkPipelineTessellationStateCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineTessellationStateCreateInfo));
    exports["VkPipelineViewportStateCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportStateCreateInfo, sType));
    exports["VkPipelineViewportStateCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportStateCreateInfo, pNext));
    exports["VkPipelineViewportStateCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportStateCreateInfo, flags));
    exports["VkPipelineViewportStateCreateInfo_viewportCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportStateCreateInfo, viewportCount));
    exports["VkPipelineViewportStateCreateInfo_pViewports_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportStateCreateInfo, pViewports));
    exports["VkPipelineViewportStateCreateInfo_scissorCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportStateCreateInfo, scissorCount));
    exports["VkPipelineViewportStateCreateInfo_pScissors_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportStateCreateInfo, pScissors));
    exports["VkPipelineViewportStateCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineViewportStateCreateInfo));
    exports["VkPipelineRasterizationStateCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateCreateInfo, sType));
    exports["VkPipelineRasterizationStateCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateCreateInfo, pNext));
    exports["VkPipelineRasterizationStateCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateCreateInfo, flags));
    exports["VkPipelineRasterizationStateCreateInfo_depthClampEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateCreateInfo, depthClampEnable));
    exports["VkPipelineRasterizationStateCreateInfo_rasterizerDiscardEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateCreateInfo, rasterizerDiscardEnable));
    exports["VkPipelineRasterizationStateCreateInfo_polygonMode_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateCreateInfo, polygonMode));
    exports["VkPipelineRasterizationStateCreateInfo_cullMode_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateCreateInfo, cullMode));
    exports["VkPipelineRasterizationStateCreateInfo_frontFace_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateCreateInfo, frontFace));
    exports["VkPipelineRasterizationStateCreateInfo_depthBiasEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateCreateInfo, depthBiasEnable));
    exports["VkPipelineRasterizationStateCreateInfo_depthBiasConstantFactor_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateCreateInfo, depthBiasConstantFactor));
    exports["VkPipelineRasterizationStateCreateInfo_depthBiasClamp_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateCreateInfo, depthBiasClamp));
    exports["VkPipelineRasterizationStateCreateInfo_depthBiasSlopeFactor_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateCreateInfo, depthBiasSlopeFactor));
    exports["VkPipelineRasterizationStateCreateInfo_lineWidth_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateCreateInfo, lineWidth));
    exports["VkPipelineRasterizationStateCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineRasterizationStateCreateInfo));
    exports["VkPipelineMultisampleStateCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineMultisampleStateCreateInfo, sType));
    exports["VkPipelineMultisampleStateCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineMultisampleStateCreateInfo, pNext));
    exports["VkPipelineMultisampleStateCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineMultisampleStateCreateInfo, flags));
    exports["VkPipelineMultisampleStateCreateInfo_rasterizationSamples_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineMultisampleStateCreateInfo, rasterizationSamples));
    exports["VkPipelineMultisampleStateCreateInfo_sampleShadingEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineMultisampleStateCreateInfo, sampleShadingEnable));
    exports["VkPipelineMultisampleStateCreateInfo_minSampleShading_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineMultisampleStateCreateInfo, minSampleShading));
    exports["VkPipelineMultisampleStateCreateInfo_pSampleMask_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineMultisampleStateCreateInfo, pSampleMask));
    exports["VkPipelineMultisampleStateCreateInfo_alphaToCoverageEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineMultisampleStateCreateInfo, alphaToCoverageEnable));
    exports["VkPipelineMultisampleStateCreateInfo_alphaToOneEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineMultisampleStateCreateInfo, alphaToOneEnable));
    exports["VkPipelineMultisampleStateCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineMultisampleStateCreateInfo));
    exports["VkPipelineColorBlendAttachmentState_blendEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendAttachmentState, blendEnable));
    exports["VkPipelineColorBlendAttachmentState_srcColorBlendFactor_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendAttachmentState, srcColorBlendFactor));
    exports["VkPipelineColorBlendAttachmentState_dstColorBlendFactor_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendAttachmentState, dstColorBlendFactor));
    exports["VkPipelineColorBlendAttachmentState_colorBlendOp_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendAttachmentState, colorBlendOp));
    exports["VkPipelineColorBlendAttachmentState_srcAlphaBlendFactor_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendAttachmentState, srcAlphaBlendFactor));
    exports["VkPipelineColorBlendAttachmentState_dstAlphaBlendFactor_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendAttachmentState, dstAlphaBlendFactor));
    exports["VkPipelineColorBlendAttachmentState_alphaBlendOp_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendAttachmentState, alphaBlendOp));
    exports["VkPipelineColorBlendAttachmentState_colorWriteMask_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendAttachmentState, colorWriteMask));
    exports["VkPipelineColorBlendAttachmentState_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineColorBlendAttachmentState));
    exports["VkPipelineColorBlendStateCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendStateCreateInfo, sType));
    exports["VkPipelineColorBlendStateCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendStateCreateInfo, pNext));
    exports["VkPipelineColorBlendStateCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendStateCreateInfo, flags));
    exports["VkPipelineColorBlendStateCreateInfo_logicOpEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendStateCreateInfo, logicOpEnable));
    exports["VkPipelineColorBlendStateCreateInfo_logicOp_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendStateCreateInfo, logicOp));
    exports["VkPipelineColorBlendStateCreateInfo_attachmentCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendStateCreateInfo, attachmentCount));
    exports["VkPipelineColorBlendStateCreateInfo_pAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendStateCreateInfo, pAttachments));
    exports["VkPipelineColorBlendStateCreateInfo_blendConstants_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendStateCreateInfo, blendConstants));
    exports["VkPipelineColorBlendStateCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineColorBlendStateCreateInfo));
    exports["VkPipelineDynamicStateCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDynamicStateCreateInfo, sType));
    exports["VkPipelineDynamicStateCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDynamicStateCreateInfo, pNext));
    exports["VkPipelineDynamicStateCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDynamicStateCreateInfo, flags));
    exports["VkPipelineDynamicStateCreateInfo_dynamicStateCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDynamicStateCreateInfo, dynamicStateCount));
    exports["VkPipelineDynamicStateCreateInfo_pDynamicStates_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDynamicStateCreateInfo, pDynamicStates));
    exports["VkPipelineDynamicStateCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineDynamicStateCreateInfo));
    exports["VkStencilOpState_failOp_offsetof"] = Napi::Number::New(env, offsetof(VkStencilOpState, failOp));
    exports["VkStencilOpState_passOp_offsetof"] = Napi::Number::New(env, offsetof(VkStencilOpState, passOp));
    exports["VkStencilOpState_depthFailOp_offsetof"] = Napi::Number::New(env, offsetof(VkStencilOpState, depthFailOp));
    exports["VkStencilOpState_compareOp_offsetof"] = Napi::Number::New(env, offsetof(VkStencilOpState, compareOp));
    exports["VkStencilOpState_compareMask_offsetof"] = Napi::Number::New(env, offsetof(VkStencilOpState, compareMask));
    exports["VkStencilOpState_writeMask_offsetof"] = Napi::Number::New(env, offsetof(VkStencilOpState, writeMask));
    exports["VkStencilOpState_reference_offsetof"] = Napi::Number::New(env, offsetof(VkStencilOpState, reference));
    exports["VkStencilOpState_sizeof"] = Napi::Number::New(env, sizeof(VkStencilOpState));
    exports["VkPipelineDepthStencilStateCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDepthStencilStateCreateInfo, sType));
    exports["VkPipelineDepthStencilStateCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDepthStencilStateCreateInfo, pNext));
    exports["VkPipelineDepthStencilStateCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDepthStencilStateCreateInfo, flags));
    exports["VkPipelineDepthStencilStateCreateInfo_depthTestEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDepthStencilStateCreateInfo, depthTestEnable));
    exports["VkPipelineDepthStencilStateCreateInfo_depthWriteEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDepthStencilStateCreateInfo, depthWriteEnable));
    exports["VkPipelineDepthStencilStateCreateInfo_depthCompareOp_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDepthStencilStateCreateInfo, depthCompareOp));
    exports["VkPipelineDepthStencilStateCreateInfo_depthBoundsTestEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDepthStencilStateCreateInfo, depthBoundsTestEnable));
    exports["VkPipelineDepthStencilStateCreateInfo_stencilTestEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDepthStencilStateCreateInfo, stencilTestEnable));
    exports["VkPipelineDepthStencilStateCreateInfo_front_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDepthStencilStateCreateInfo, front));
    exports["VkPipelineDepthStencilStateCreateInfo_back_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDepthStencilStateCreateInfo, back));
    exports["VkPipelineDepthStencilStateCreateInfo_minDepthBounds_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDepthStencilStateCreateInfo, minDepthBounds));
    exports["VkPipelineDepthStencilStateCreateInfo_maxDepthBounds_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDepthStencilStateCreateInfo, maxDepthBounds));
    exports["VkPipelineDepthStencilStateCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineDepthStencilStateCreateInfo));
    exports["VkGraphicsPipelineCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, sType));
    exports["VkGraphicsPipelineCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, pNext));
    exports["VkGraphicsPipelineCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, flags));
    exports["VkGraphicsPipelineCreateInfo_stageCount_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, stageCount));
    exports["VkGraphicsPipelineCreateInfo_pStages_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, pStages));
    exports["VkGraphicsPipelineCreateInfo_pVertexInputState_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, pVertexInputState));
    exports["VkGraphicsPipelineCreateInfo_pInputAssemblyState_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, pInputAssemblyState));
    exports["VkGraphicsPipelineCreateInfo_pTessellationState_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, pTessellationState));
    exports["VkGraphicsPipelineCreateInfo_pViewportState_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, pViewportState));
    exports["VkGraphicsPipelineCreateInfo_pRasterizationState_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, pRasterizationState));
    exports["VkGraphicsPipelineCreateInfo_pMultisampleState_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, pMultisampleState));
    exports["VkGraphicsPipelineCreateInfo_pDepthStencilState_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, pDepthStencilState));
    exports["VkGraphicsPipelineCreateInfo_pColorBlendState_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, pColorBlendState));
    exports["VkGraphicsPipelineCreateInfo_pDynamicState_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, pDynamicState));
    exports["VkGraphicsPipelineCreateInfo_layout_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, layout));
    exports["VkGraphicsPipelineCreateInfo_renderPass_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, renderPass));
    exports["VkGraphicsPipelineCreateInfo_subpass_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, subpass));
    exports["VkGraphicsPipelineCreateInfo_basePipelineHandle_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, basePipelineHandle));
    exports["VkGraphicsPipelineCreateInfo_basePipelineIndex_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineCreateInfo, basePipelineIndex));
    exports["VkGraphicsPipelineCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkGraphicsPipelineCreateInfo));
    exports["VkPipelineCacheCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCacheCreateInfo, sType));
    exports["VkPipelineCacheCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCacheCreateInfo, pNext));
    exports["VkPipelineCacheCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCacheCreateInfo, flags));
    exports["VkPipelineCacheCreateInfo_initialDataSize_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCacheCreateInfo, initialDataSize));
    exports["VkPipelineCacheCreateInfo_pInitialData_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCacheCreateInfo, pInitialData));
    exports["VkPipelineCacheCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineCacheCreateInfo));
    exports["VkPipelineCacheHeaderVersionOne_headerSize_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCacheHeaderVersionOne, headerSize));
    exports["VkPipelineCacheHeaderVersionOne_headerVersion_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCacheHeaderVersionOne, headerVersion));
    exports["VkPipelineCacheHeaderVersionOne_vendorID_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCacheHeaderVersionOne, vendorID));
    exports["VkPipelineCacheHeaderVersionOne_deviceID_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCacheHeaderVersionOne, deviceID));
    exports["VkPipelineCacheHeaderVersionOne_pipelineCacheUUID_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCacheHeaderVersionOne, pipelineCacheUUID));
    exports["VkPipelineCacheHeaderVersionOne_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineCacheHeaderVersionOne));
    exports["VkPushConstantRange_stageFlags_offsetof"] = Napi::Number::New(env, offsetof(VkPushConstantRange, stageFlags));
    exports["VkPushConstantRange_offset_offsetof"] = Napi::Number::New(env, offsetof(VkPushConstantRange, offset));
    exports["VkPushConstantRange_size_offsetof"] = Napi::Number::New(env, offsetof(VkPushConstantRange, size));
    exports["VkPushConstantRange_sizeof"] = Napi::Number::New(env, sizeof(VkPushConstantRange));
    exports["VkPipelineLayoutCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineLayoutCreateInfo, sType));
    exports["VkPipelineLayoutCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineLayoutCreateInfo, pNext));
    exports["VkPipelineLayoutCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineLayoutCreateInfo, flags));
    exports["VkPipelineLayoutCreateInfo_setLayoutCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineLayoutCreateInfo, setLayoutCount));
    exports["VkPipelineLayoutCreateInfo_pSetLayouts_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineLayoutCreateInfo, pSetLayouts));
    exports["VkPipelineLayoutCreateInfo_pushConstantRangeCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineLayoutCreateInfo, pushConstantRangeCount));
    exports["VkPipelineLayoutCreateInfo_pPushConstantRanges_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineLayoutCreateInfo, pPushConstantRanges));
    exports["VkPipelineLayoutCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineLayoutCreateInfo));
    exports["VkSamplerCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, sType));
    exports["VkSamplerCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, pNext));
    exports["VkSamplerCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, flags));
    exports["VkSamplerCreateInfo_magFilter_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, magFilter));
    exports["VkSamplerCreateInfo_minFilter_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, minFilter));
    exports["VkSamplerCreateInfo_mipmapMode_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, mipmapMode));
    exports["VkSamplerCreateInfo_addressModeU_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, addressModeU));
    exports["VkSamplerCreateInfo_addressModeV_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, addressModeV));
    exports["VkSamplerCreateInfo_addressModeW_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, addressModeW));
    exports["VkSamplerCreateInfo_mipLodBias_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, mipLodBias));
    exports["VkSamplerCreateInfo_anisotropyEnable_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, anisotropyEnable));
    exports["VkSamplerCreateInfo_maxAnisotropy_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, maxAnisotropy));
    exports["VkSamplerCreateInfo_compareEnable_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, compareEnable));
    exports["VkSamplerCreateInfo_compareOp_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, compareOp));
    exports["VkSamplerCreateInfo_minLod_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, minLod));
    exports["VkSamplerCreateInfo_maxLod_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, maxLod));
    exports["VkSamplerCreateInfo_borderColor_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, borderColor));
    exports["VkSamplerCreateInfo_unnormalizedCoordinates_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCreateInfo, unnormalizedCoordinates));
    exports["VkSamplerCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkSamplerCreateInfo));
    exports["VkCommandPoolCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCommandPoolCreateInfo, sType));
    exports["VkCommandPoolCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCommandPoolCreateInfo, pNext));
    exports["VkCommandPoolCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkCommandPoolCreateInfo, flags));
    exports["VkCommandPoolCreateInfo_queueFamilyIndex_offsetof"] = Napi::Number::New(env, offsetof(VkCommandPoolCreateInfo, queueFamilyIndex));
    exports["VkCommandPoolCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkCommandPoolCreateInfo));
    exports["VkCommandBufferAllocateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferAllocateInfo, sType));
    exports["VkCommandBufferAllocateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferAllocateInfo, pNext));
    exports["VkCommandBufferAllocateInfo_commandPool_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferAllocateInfo, commandPool));
    exports["VkCommandBufferAllocateInfo_level_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferAllocateInfo, level));
    exports["VkCommandBufferAllocateInfo_commandBufferCount_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferAllocateInfo, commandBufferCount));
    exports["VkCommandBufferAllocateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkCommandBufferAllocateInfo));
    exports["VkCommandBufferInheritanceInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceInfo, sType));
    exports["VkCommandBufferInheritanceInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceInfo, pNext));
    exports["VkCommandBufferInheritanceInfo_renderPass_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceInfo, renderPass));
    exports["VkCommandBufferInheritanceInfo_subpass_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceInfo, subpass));
    exports["VkCommandBufferInheritanceInfo_framebuffer_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceInfo, framebuffer));
    exports["VkCommandBufferInheritanceInfo_occlusionQueryEnable_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceInfo, occlusionQueryEnable));
    exports["VkCommandBufferInheritanceInfo_queryFlags_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceInfo, queryFlags));
    exports["VkCommandBufferInheritanceInfo_pipelineStatistics_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceInfo, pipelineStatistics));
    exports["VkCommandBufferInheritanceInfo_sizeof"] = Napi::Number::New(env, sizeof(VkCommandBufferInheritanceInfo));
    exports["VkCommandBufferBeginInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferBeginInfo, sType));
    exports["VkCommandBufferBeginInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferBeginInfo, pNext));
    exports["VkCommandBufferBeginInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferBeginInfo, flags));
    exports["VkCommandBufferBeginInfo_pInheritanceInfo_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferBeginInfo, pInheritanceInfo));
    exports["VkCommandBufferBeginInfo_sizeof"] = Napi::Number::New(env, sizeof(VkCommandBufferBeginInfo));
    exports["VkRenderPassBeginInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassBeginInfo, sType));
    exports["VkRenderPassBeginInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassBeginInfo, pNext));
    exports["VkRenderPassBeginInfo_renderPass_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassBeginInfo, renderPass));
    exports["VkRenderPassBeginInfo_framebuffer_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassBeginInfo, framebuffer));
    exports["VkRenderPassBeginInfo_renderArea_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassBeginInfo, renderArea));
    exports["VkRenderPassBeginInfo_clearValueCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassBeginInfo, clearValueCount));
    exports["VkRenderPassBeginInfo_pClearValues_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassBeginInfo, pClearValues));
    exports["VkRenderPassBeginInfo_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassBeginInfo));
    exports["VkClearDepthStencilValue_depth_offsetof"] = Napi::Number::New(env, offsetof(VkClearDepthStencilValue, depth));
    exports["VkClearDepthStencilValue_stencil_offsetof"] = Napi::Number::New(env, offsetof(VkClearDepthStencilValue, stencil));
    exports["VkClearDepthStencilValue_sizeof"] = Napi::Number::New(env, sizeof(VkClearDepthStencilValue));
    exports["VkClearAttachment_aspectMask_offsetof"] = Napi::Number::New(env, offsetof(VkClearAttachment, aspectMask));
    exports["VkClearAttachment_colorAttachment_offsetof"] = Napi::Number::New(env, offsetof(VkClearAttachment, colorAttachment));
    exports["VkClearAttachment_clearValue_offsetof"] = Napi::Number::New(env, offsetof(VkClearAttachment, clearValue));
    exports["VkClearAttachment_sizeof"] = Napi::Number::New(env, sizeof(VkClearAttachment));
    exports["VkAttachmentDescription_flags_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription, flags));
    exports["VkAttachmentDescription_format_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription, format));
    exports["VkAttachmentDescription_samples_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription, samples));
    exports["VkAttachmentDescription_loadOp_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription, loadOp));
    exports["VkAttachmentDescription_storeOp_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription, storeOp));
    exports["VkAttachmentDescription_stencilLoadOp_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription, stencilLoadOp));
    exports["VkAttachmentDescription_stencilStoreOp_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription, stencilStoreOp));
    exports["VkAttachmentDescription_initialLayout_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription, initialLayout));
    exports["VkAttachmentDescription_finalLayout_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription, finalLayout));
    exports["VkAttachmentDescription_sizeof"] = Napi::Number::New(env, sizeof(VkAttachmentDescription));
    exports["VkAttachmentReference_attachment_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentReference, attachment));
    exports["VkAttachmentReference_layout_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentReference, layout));
    exports["VkAttachmentReference_sizeof"] = Napi::Number::New(env, sizeof(VkAttachmentReference));
    exports["VkSubpassDescription_flags_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription, flags));
    exports["VkSubpassDescription_pipelineBindPoint_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription, pipelineBindPoint));
    exports["VkSubpassDescription_inputAttachmentCount_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription, inputAttachmentCount));
    exports["VkSubpassDescription_pInputAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription, pInputAttachments));
    exports["VkSubpassDescription_colorAttachmentCount_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription, colorAttachmentCount));
    exports["VkSubpassDescription_pColorAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription, pColorAttachments));
    exports["VkSubpassDescription_pResolveAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription, pResolveAttachments));
    exports["VkSubpassDescription_pDepthStencilAttachment_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription, pDepthStencilAttachment));
    exports["VkSubpassDescription_preserveAttachmentCount_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription, preserveAttachmentCount));
    exports["VkSubpassDescription_pPreserveAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription, pPreserveAttachments));
    exports["VkSubpassDescription_sizeof"] = Napi::Number::New(env, sizeof(VkSubpassDescription));
    exports["VkSubpassDependency_srcSubpass_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDependency, srcSubpass));
    exports["VkSubpassDependency_dstSubpass_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDependency, dstSubpass));
    exports["VkSubpassDependency_srcStageMask_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDependency, srcStageMask));
    exports["VkSubpassDependency_dstStageMask_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDependency, dstStageMask));
    exports["VkSubpassDependency_srcAccessMask_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDependency, srcAccessMask));
    exports["VkSubpassDependency_dstAccessMask_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDependency, dstAccessMask));
    exports["VkSubpassDependency_dependencyFlags_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDependency, dependencyFlags));
    exports["VkSubpassDependency_sizeof"] = Napi::Number::New(env, sizeof(VkSubpassDependency));
    exports["VkRenderPassCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo, sType));
    exports["VkRenderPassCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo, pNext));
    exports["VkRenderPassCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo, flags));
    exports["VkRenderPassCreateInfo_attachmentCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo, attachmentCount));
    exports["VkRenderPassCreateInfo_pAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo, pAttachments));
    exports["VkRenderPassCreateInfo_subpassCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo, subpassCount));
    exports["VkRenderPassCreateInfo_pSubpasses_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo, pSubpasses));
    exports["VkRenderPassCreateInfo_dependencyCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo, dependencyCount));
    exports["VkRenderPassCreateInfo_pDependencies_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo, pDependencies));
    exports["VkRenderPassCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassCreateInfo));
    exports["VkEventCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkEventCreateInfo, sType));
    exports["VkEventCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkEventCreateInfo, pNext));
    exports["VkEventCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkEventCreateInfo, flags));
    exports["VkEventCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkEventCreateInfo));
    exports["VkFenceCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkFenceCreateInfo, sType));
    exports["VkFenceCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkFenceCreateInfo, pNext));
    exports["VkFenceCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkFenceCreateInfo, flags));
    exports["VkFenceCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkFenceCreateInfo));
    exports["VkPhysicalDeviceFeatures_robustBufferAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, robustBufferAccess));
    exports["VkPhysicalDeviceFeatures_fullDrawIndexUint32_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, fullDrawIndexUint32));
    exports["VkPhysicalDeviceFeatures_imageCubeArray_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, imageCubeArray));
    exports["VkPhysicalDeviceFeatures_independentBlend_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, independentBlend));
    exports["VkPhysicalDeviceFeatures_geometryShader_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, geometryShader));
    exports["VkPhysicalDeviceFeatures_tessellationShader_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, tessellationShader));
    exports["VkPhysicalDeviceFeatures_sampleRateShading_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, sampleRateShading));
    exports["VkPhysicalDeviceFeatures_dualSrcBlend_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, dualSrcBlend));
    exports["VkPhysicalDeviceFeatures_logicOp_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, logicOp));
    exports["VkPhysicalDeviceFeatures_multiDrawIndirect_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, multiDrawIndirect));
    exports["VkPhysicalDeviceFeatures_drawIndirectFirstInstance_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, drawIndirectFirstInstance));
    exports["VkPhysicalDeviceFeatures_depthClamp_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, depthClamp));
    exports["VkPhysicalDeviceFeatures_depthBiasClamp_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, depthBiasClamp));
    exports["VkPhysicalDeviceFeatures_fillModeNonSolid_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, fillModeNonSolid));
    exports["VkPhysicalDeviceFeatures_depthBounds_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, depthBounds));
    exports["VkPhysicalDeviceFeatures_wideLines_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, wideLines));
    exports["VkPhysicalDeviceFeatures_largePoints_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, largePoints));
    exports["VkPhysicalDeviceFeatures_alphaToOne_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, alphaToOne));
    exports["VkPhysicalDeviceFeatures_multiViewport_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, multiViewport));
    exports["VkPhysicalDeviceFeatures_samplerAnisotropy_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, samplerAnisotropy));
    exports["VkPhysicalDeviceFeatures_textureCompressionETC2_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, textureCompressionETC2));
    exports["VkPhysicalDeviceFeatures_textureCompressionASTC_LDR_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, textureCompressionASTC_LDR));
    exports["VkPhysicalDeviceFeatures_textureCompressionBC_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, textureCompressionBC));
    exports["VkPhysicalDeviceFeatures_occlusionQueryPrecise_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, occlusionQueryPrecise));
    exports["VkPhysicalDeviceFeatures_pipelineStatisticsQuery_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, pipelineStatisticsQuery));
    exports["VkPhysicalDeviceFeatures_vertexPipelineStoresAndAtomics_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, vertexPipelineStoresAndAtomics));
    exports["VkPhysicalDeviceFeatures_fragmentStoresAndAtomics_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, fragmentStoresAndAtomics));
    exports["VkPhysicalDeviceFeatures_shaderTessellationAndGeometryPointSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, shaderTessellationAndGeometryPointSize));
    exports["VkPhysicalDeviceFeatures_shaderImageGatherExtended_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, shaderImageGatherExtended));
    exports["VkPhysicalDeviceFeatures_shaderStorageImageExtendedFormats_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, shaderStorageImageExtendedFormats));
    exports["VkPhysicalDeviceFeatures_shaderStorageImageMultisample_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, shaderStorageImageMultisample));
    exports["VkPhysicalDeviceFeatures_shaderStorageImageReadWithoutFormat_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, shaderStorageImageReadWithoutFormat));
    exports["VkPhysicalDeviceFeatures_shaderStorageImageWriteWithoutFormat_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, shaderStorageImageWriteWithoutFormat));
    exports["VkPhysicalDeviceFeatures_shaderUniformBufferArrayDynamicIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, shaderUniformBufferArrayDynamicIndexing));
    exports["VkPhysicalDeviceFeatures_shaderSampledImageArrayDynamicIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, shaderSampledImageArrayDynamicIndexing));
    exports["VkPhysicalDeviceFeatures_shaderStorageBufferArrayDynamicIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, shaderStorageBufferArrayDynamicIndexing));
    exports["VkPhysicalDeviceFeatures_shaderStorageImageArrayDynamicIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, shaderStorageImageArrayDynamicIndexing));
    exports["VkPhysicalDeviceFeatures_shaderClipDistance_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, shaderClipDistance));
    exports["VkPhysicalDeviceFeatures_shaderCullDistance_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, shaderCullDistance));
    exports["VkPhysicalDeviceFeatures_shaderFloat64_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, shaderFloat64));
    exports["VkPhysicalDeviceFeatures_shaderInt64_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, shaderInt64));
    exports["VkPhysicalDeviceFeatures_shaderInt16_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, shaderInt16));
    exports["VkPhysicalDeviceFeatures_shaderResourceResidency_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, shaderResourceResidency));
    exports["VkPhysicalDeviceFeatures_shaderResourceMinLod_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, shaderResourceMinLod));
    exports["VkPhysicalDeviceFeatures_sparseBinding_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, sparseBinding));
    exports["VkPhysicalDeviceFeatures_sparseResidencyBuffer_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, sparseResidencyBuffer));
    exports["VkPhysicalDeviceFeatures_sparseResidencyImage2D_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, sparseResidencyImage2D));
    exports["VkPhysicalDeviceFeatures_sparseResidencyImage3D_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, sparseResidencyImage3D));
    exports["VkPhysicalDeviceFeatures_sparseResidency2Samples_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, sparseResidency2Samples));
    exports["VkPhysicalDeviceFeatures_sparseResidency4Samples_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, sparseResidency4Samples));
    exports["VkPhysicalDeviceFeatures_sparseResidency8Samples_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, sparseResidency8Samples));
    exports["VkPhysicalDeviceFeatures_sparseResidency16Samples_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, sparseResidency16Samples));
    exports["VkPhysicalDeviceFeatures_sparseResidencyAliased_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, sparseResidencyAliased));
    exports["VkPhysicalDeviceFeatures_variableMultisampleRate_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, variableMultisampleRate));
    exports["VkPhysicalDeviceFeatures_inheritedQueries_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures, inheritedQueries));
    exports["VkPhysicalDeviceFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFeatures));
    exports["VkPhysicalDeviceSparseProperties_residencyStandard2DBlockShape_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSparseProperties, residencyStandard2DBlockShape));
    exports["VkPhysicalDeviceSparseProperties_residencyStandard2DMultisampleBlockShape_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSparseProperties, residencyStandard2DMultisampleBlockShape));
    exports["VkPhysicalDeviceSparseProperties_residencyStandard3DBlockShape_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSparseProperties, residencyStandard3DBlockShape));
    exports["VkPhysicalDeviceSparseProperties_residencyAlignedMipSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSparseProperties, residencyAlignedMipSize));
    exports["VkPhysicalDeviceSparseProperties_residencyNonResidentStrict_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSparseProperties, residencyNonResidentStrict));
    exports["VkPhysicalDeviceSparseProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSparseProperties));
    exports["VkPhysicalDeviceLimits_maxImageDimension1D_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxImageDimension1D));
    exports["VkPhysicalDeviceLimits_maxImageDimension2D_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxImageDimension2D));
    exports["VkPhysicalDeviceLimits_maxImageDimension3D_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxImageDimension3D));
    exports["VkPhysicalDeviceLimits_maxImageDimensionCube_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxImageDimensionCube));
    exports["VkPhysicalDeviceLimits_maxImageArrayLayers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxImageArrayLayers));
    exports["VkPhysicalDeviceLimits_maxTexelBufferElements_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxTexelBufferElements));
    exports["VkPhysicalDeviceLimits_maxUniformBufferRange_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxUniformBufferRange));
    exports["VkPhysicalDeviceLimits_maxStorageBufferRange_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxStorageBufferRange));
    exports["VkPhysicalDeviceLimits_maxPushConstantsSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxPushConstantsSize));
    exports["VkPhysicalDeviceLimits_maxMemoryAllocationCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxMemoryAllocationCount));
    exports["VkPhysicalDeviceLimits_maxSamplerAllocationCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxSamplerAllocationCount));
    exports["VkPhysicalDeviceLimits_bufferImageGranularity_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, bufferImageGranularity));
    exports["VkPhysicalDeviceLimits_sparseAddressSpaceSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, sparseAddressSpaceSize));
    exports["VkPhysicalDeviceLimits_maxBoundDescriptorSets_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxBoundDescriptorSets));
    exports["VkPhysicalDeviceLimits_maxPerStageDescriptorSamplers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxPerStageDescriptorSamplers));
    exports["VkPhysicalDeviceLimits_maxPerStageDescriptorUniformBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxPerStageDescriptorUniformBuffers));
    exports["VkPhysicalDeviceLimits_maxPerStageDescriptorStorageBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxPerStageDescriptorStorageBuffers));
    exports["VkPhysicalDeviceLimits_maxPerStageDescriptorSampledImages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxPerStageDescriptorSampledImages));
    exports["VkPhysicalDeviceLimits_maxPerStageDescriptorStorageImages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxPerStageDescriptorStorageImages));
    exports["VkPhysicalDeviceLimits_maxPerStageDescriptorInputAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxPerStageDescriptorInputAttachments));
    exports["VkPhysicalDeviceLimits_maxPerStageResources_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxPerStageResources));
    exports["VkPhysicalDeviceLimits_maxDescriptorSetSamplers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxDescriptorSetSamplers));
    exports["VkPhysicalDeviceLimits_maxDescriptorSetUniformBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxDescriptorSetUniformBuffers));
    exports["VkPhysicalDeviceLimits_maxDescriptorSetUniformBuffersDynamic_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxDescriptorSetUniformBuffersDynamic));
    exports["VkPhysicalDeviceLimits_maxDescriptorSetStorageBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxDescriptorSetStorageBuffers));
    exports["VkPhysicalDeviceLimits_maxDescriptorSetStorageBuffersDynamic_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxDescriptorSetStorageBuffersDynamic));
    exports["VkPhysicalDeviceLimits_maxDescriptorSetSampledImages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxDescriptorSetSampledImages));
    exports["VkPhysicalDeviceLimits_maxDescriptorSetStorageImages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxDescriptorSetStorageImages));
    exports["VkPhysicalDeviceLimits_maxDescriptorSetInputAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxDescriptorSetInputAttachments));
    exports["VkPhysicalDeviceLimits_maxVertexInputAttributes_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxVertexInputAttributes));
    exports["VkPhysicalDeviceLimits_maxVertexInputBindings_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxVertexInputBindings));
    exports["VkPhysicalDeviceLimits_maxVertexInputAttributeOffset_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxVertexInputAttributeOffset));
    exports["VkPhysicalDeviceLimits_maxVertexInputBindingStride_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxVertexInputBindingStride));
    exports["VkPhysicalDeviceLimits_maxVertexOutputComponents_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxVertexOutputComponents));
    exports["VkPhysicalDeviceLimits_maxTessellationGenerationLevel_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxTessellationGenerationLevel));
    exports["VkPhysicalDeviceLimits_maxTessellationPatchSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxTessellationPatchSize));
    exports["VkPhysicalDeviceLimits_maxTessellationControlPerVertexInputComponents_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxTessellationControlPerVertexInputComponents));
    exports["VkPhysicalDeviceLimits_maxTessellationControlPerVertexOutputComponents_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxTessellationControlPerVertexOutputComponents));
    exports["VkPhysicalDeviceLimits_maxTessellationControlPerPatchOutputComponents_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxTessellationControlPerPatchOutputComponents));
    exports["VkPhysicalDeviceLimits_maxTessellationControlTotalOutputComponents_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxTessellationControlTotalOutputComponents));
    exports["VkPhysicalDeviceLimits_maxTessellationEvaluationInputComponents_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxTessellationEvaluationInputComponents));
    exports["VkPhysicalDeviceLimits_maxTessellationEvaluationOutputComponents_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxTessellationEvaluationOutputComponents));
    exports["VkPhysicalDeviceLimits_maxGeometryShaderInvocations_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxGeometryShaderInvocations));
    exports["VkPhysicalDeviceLimits_maxGeometryInputComponents_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxGeometryInputComponents));
    exports["VkPhysicalDeviceLimits_maxGeometryOutputComponents_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxGeometryOutputComponents));
    exports["VkPhysicalDeviceLimits_maxGeometryOutputVertices_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxGeometryOutputVertices));
    exports["VkPhysicalDeviceLimits_maxGeometryTotalOutputComponents_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxGeometryTotalOutputComponents));
    exports["VkPhysicalDeviceLimits_maxFragmentInputComponents_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxFragmentInputComponents));
    exports["VkPhysicalDeviceLimits_maxFragmentOutputAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxFragmentOutputAttachments));
    exports["VkPhysicalDeviceLimits_maxFragmentDualSrcAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxFragmentDualSrcAttachments));
    exports["VkPhysicalDeviceLimits_maxFragmentCombinedOutputResources_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxFragmentCombinedOutputResources));
    exports["VkPhysicalDeviceLimits_maxComputeSharedMemorySize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxComputeSharedMemorySize));
    exports["VkPhysicalDeviceLimits_maxComputeWorkGroupCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxComputeWorkGroupCount));
    exports["VkPhysicalDeviceLimits_maxComputeWorkGroupInvocations_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxComputeWorkGroupInvocations));
    exports["VkPhysicalDeviceLimits_maxComputeWorkGroupSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxComputeWorkGroupSize));
    exports["VkPhysicalDeviceLimits_subPixelPrecisionBits_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, subPixelPrecisionBits));
    exports["VkPhysicalDeviceLimits_subTexelPrecisionBits_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, subTexelPrecisionBits));
    exports["VkPhysicalDeviceLimits_mipmapPrecisionBits_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, mipmapPrecisionBits));
    exports["VkPhysicalDeviceLimits_maxDrawIndexedIndexValue_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxDrawIndexedIndexValue));
    exports["VkPhysicalDeviceLimits_maxDrawIndirectCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxDrawIndirectCount));
    exports["VkPhysicalDeviceLimits_maxSamplerLodBias_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxSamplerLodBias));
    exports["VkPhysicalDeviceLimits_maxSamplerAnisotropy_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxSamplerAnisotropy));
    exports["VkPhysicalDeviceLimits_maxViewports_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxViewports));
    exports["VkPhysicalDeviceLimits_maxViewportDimensions_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxViewportDimensions));
    exports["VkPhysicalDeviceLimits_viewportBoundsRange_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, viewportBoundsRange));
    exports["VkPhysicalDeviceLimits_viewportSubPixelBits_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, viewportSubPixelBits));
    exports["VkPhysicalDeviceLimits_minMemoryMapAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, minMemoryMapAlignment));
    exports["VkPhysicalDeviceLimits_minTexelBufferOffsetAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, minTexelBufferOffsetAlignment));
    exports["VkPhysicalDeviceLimits_minUniformBufferOffsetAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, minUniformBufferOffsetAlignment));
    exports["VkPhysicalDeviceLimits_minStorageBufferOffsetAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, minStorageBufferOffsetAlignment));
    exports["VkPhysicalDeviceLimits_minTexelOffset_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, minTexelOffset));
    exports["VkPhysicalDeviceLimits_maxTexelOffset_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxTexelOffset));
    exports["VkPhysicalDeviceLimits_minTexelGatherOffset_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, minTexelGatherOffset));
    exports["VkPhysicalDeviceLimits_maxTexelGatherOffset_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxTexelGatherOffset));
    exports["VkPhysicalDeviceLimits_minInterpolationOffset_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, minInterpolationOffset));
    exports["VkPhysicalDeviceLimits_maxInterpolationOffset_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxInterpolationOffset));
    exports["VkPhysicalDeviceLimits_subPixelInterpolationOffsetBits_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, subPixelInterpolationOffsetBits));
    exports["VkPhysicalDeviceLimits_maxFramebufferWidth_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxFramebufferWidth));
    exports["VkPhysicalDeviceLimits_maxFramebufferHeight_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxFramebufferHeight));
    exports["VkPhysicalDeviceLimits_maxFramebufferLayers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxFramebufferLayers));
    exports["VkPhysicalDeviceLimits_framebufferColorSampleCounts_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, framebufferColorSampleCounts));
    exports["VkPhysicalDeviceLimits_framebufferDepthSampleCounts_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, framebufferDepthSampleCounts));
    exports["VkPhysicalDeviceLimits_framebufferStencilSampleCounts_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, framebufferStencilSampleCounts));
    exports["VkPhysicalDeviceLimits_framebufferNoAttachmentsSampleCounts_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, framebufferNoAttachmentsSampleCounts));
    exports["VkPhysicalDeviceLimits_maxColorAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxColorAttachments));
    exports["VkPhysicalDeviceLimits_sampledImageColorSampleCounts_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, sampledImageColorSampleCounts));
    exports["VkPhysicalDeviceLimits_sampledImageIntegerSampleCounts_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, sampledImageIntegerSampleCounts));
    exports["VkPhysicalDeviceLimits_sampledImageDepthSampleCounts_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, sampledImageDepthSampleCounts));
    exports["VkPhysicalDeviceLimits_sampledImageStencilSampleCounts_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, sampledImageStencilSampleCounts));
    exports["VkPhysicalDeviceLimits_storageImageSampleCounts_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, storageImageSampleCounts));
    exports["VkPhysicalDeviceLimits_maxSampleMaskWords_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxSampleMaskWords));
    exports["VkPhysicalDeviceLimits_timestampComputeAndGraphics_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, timestampComputeAndGraphics));
    exports["VkPhysicalDeviceLimits_timestampPeriod_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, timestampPeriod));
    exports["VkPhysicalDeviceLimits_maxClipDistances_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxClipDistances));
    exports["VkPhysicalDeviceLimits_maxCullDistances_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxCullDistances));
    exports["VkPhysicalDeviceLimits_maxCombinedClipAndCullDistances_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, maxCombinedClipAndCullDistances));
    exports["VkPhysicalDeviceLimits_discreteQueuePriorities_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, discreteQueuePriorities));
    exports["VkPhysicalDeviceLimits_pointSizeRange_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, pointSizeRange));
    exports["VkPhysicalDeviceLimits_lineWidthRange_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, lineWidthRange));
    exports["VkPhysicalDeviceLimits_pointSizeGranularity_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, pointSizeGranularity));
    exports["VkPhysicalDeviceLimits_lineWidthGranularity_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, lineWidthGranularity));
    exports["VkPhysicalDeviceLimits_strictLines_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, strictLines));
    exports["VkPhysicalDeviceLimits_standardSampleLocations_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, standardSampleLocations));
    exports["VkPhysicalDeviceLimits_optimalBufferCopyOffsetAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, optimalBufferCopyOffsetAlignment));
    exports["VkPhysicalDeviceLimits_optimalBufferCopyRowPitchAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, optimalBufferCopyRowPitchAlignment));
    exports["VkPhysicalDeviceLimits_nonCoherentAtomSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLimits, nonCoherentAtomSize));
    exports["VkPhysicalDeviceLimits_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceLimits));
    exports["VkSemaphoreCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreCreateInfo, sType));
    exports["VkSemaphoreCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreCreateInfo, pNext));
    exports["VkSemaphoreCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreCreateInfo, flags));
    exports["VkSemaphoreCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkSemaphoreCreateInfo));
    exports["VkQueryPoolCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkQueryPoolCreateInfo, sType));
    exports["VkQueryPoolCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkQueryPoolCreateInfo, pNext));
    exports["VkQueryPoolCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkQueryPoolCreateInfo, flags));
    exports["VkQueryPoolCreateInfo_queryType_offsetof"] = Napi::Number::New(env, offsetof(VkQueryPoolCreateInfo, queryType));
    exports["VkQueryPoolCreateInfo_queryCount_offsetof"] = Napi::Number::New(env, offsetof(VkQueryPoolCreateInfo, queryCount));
    exports["VkQueryPoolCreateInfo_pipelineStatistics_offsetof"] = Napi::Number::New(env, offsetof(VkQueryPoolCreateInfo, pipelineStatistics));
    exports["VkQueryPoolCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkQueryPoolCreateInfo));
    exports["VkFramebufferCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferCreateInfo, sType));
    exports["VkFramebufferCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferCreateInfo, pNext));
    exports["VkFramebufferCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferCreateInfo, flags));
    exports["VkFramebufferCreateInfo_renderPass_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferCreateInfo, renderPass));
    exports["VkFramebufferCreateInfo_attachmentCount_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferCreateInfo, attachmentCount));
    exports["VkFramebufferCreateInfo_pAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferCreateInfo, pAttachments));
    exports["VkFramebufferCreateInfo_width_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferCreateInfo, width));
    exports["VkFramebufferCreateInfo_height_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferCreateInfo, height));
    exports["VkFramebufferCreateInfo_layers_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferCreateInfo, layers));
    exports["VkFramebufferCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkFramebufferCreateInfo));
    exports["VkDrawIndirectCommand_vertexCount_offsetof"] = Napi::Number::New(env, offsetof(VkDrawIndirectCommand, vertexCount));
    exports["VkDrawIndirectCommand_instanceCount_offsetof"] = Napi::Number::New(env, offsetof(VkDrawIndirectCommand, instanceCount));
    exports["VkDrawIndirectCommand_firstVertex_offsetof"] = Napi::Number::New(env, offsetof(VkDrawIndirectCommand, firstVertex));
    exports["VkDrawIndirectCommand_firstInstance_offsetof"] = Napi::Number::New(env, offsetof(VkDrawIndirectCommand, firstInstance));
    exports["VkDrawIndirectCommand_sizeof"] = Napi::Number::New(env, sizeof(VkDrawIndirectCommand));
    exports["VkDrawIndexedIndirectCommand_indexCount_offsetof"] = Napi::Number::New(env, offsetof(VkDrawIndexedIndirectCommand, indexCount));
    exports["VkDrawIndexedIndirectCommand_instanceCount_offsetof"] = Napi::Number::New(env, offsetof(VkDrawIndexedIndirectCommand, instanceCount));
    exports["VkDrawIndexedIndirectCommand_firstIndex_offsetof"] = Napi::Number::New(env, offsetof(VkDrawIndexedIndirectCommand, firstIndex));
    exports["VkDrawIndexedIndirectCommand_vertexOffset_offsetof"] = Napi::Number::New(env, offsetof(VkDrawIndexedIndirectCommand, vertexOffset));
    exports["VkDrawIndexedIndirectCommand_firstInstance_offsetof"] = Napi::Number::New(env, offsetof(VkDrawIndexedIndirectCommand, firstInstance));
    exports["VkDrawIndexedIndirectCommand_sizeof"] = Napi::Number::New(env, sizeof(VkDrawIndexedIndirectCommand));
    exports["VkDispatchIndirectCommand_x_offsetof"] = Napi::Number::New(env, offsetof(VkDispatchIndirectCommand, x));
    exports["VkDispatchIndirectCommand_y_offsetof"] = Napi::Number::New(env, offsetof(VkDispatchIndirectCommand, y));
    exports["VkDispatchIndirectCommand_z_offsetof"] = Napi::Number::New(env, offsetof(VkDispatchIndirectCommand, z));
    exports["VkDispatchIndirectCommand_sizeof"] = Napi::Number::New(env, sizeof(VkDispatchIndirectCommand));
#ifdef VK_EXT_multi_draw
    exports["VkMultiDrawInfoEXT_firstVertex_offsetof"] = Napi::Number::New(env, offsetof(VkMultiDrawInfoEXT, firstVertex));
#endif
#ifdef VK_EXT_multi_draw
    exports["VkMultiDrawInfoEXT_vertexCount_offsetof"] = Napi::Number::New(env, offsetof(VkMultiDrawInfoEXT, vertexCount));
#endif
#ifdef VK_EXT_multi_draw
    exports["VkMultiDrawInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkMultiDrawInfoEXT));
#endif
#ifdef VK_EXT_multi_draw
    exports["VkMultiDrawIndexedInfoEXT_firstIndex_offsetof"] = Napi::Number::New(env, offsetof(VkMultiDrawIndexedInfoEXT, firstIndex));
#endif
#ifdef VK_EXT_multi_draw
    exports["VkMultiDrawIndexedInfoEXT_indexCount_offsetof"] = Napi::Number::New(env, offsetof(VkMultiDrawIndexedInfoEXT, indexCount));
#endif
#ifdef VK_EXT_multi_draw
    exports["VkMultiDrawIndexedInfoEXT_vertexOffset_offsetof"] = Napi::Number::New(env, offsetof(VkMultiDrawIndexedInfoEXT, vertexOffset));
#endif
#ifdef VK_EXT_multi_draw
    exports["VkMultiDrawIndexedInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkMultiDrawIndexedInfoEXT));
#endif
    exports["VkSubmitInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo, sType));
    exports["VkSubmitInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo, pNext));
    exports["VkSubmitInfo_waitSemaphoreCount_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo, waitSemaphoreCount));
    exports["VkSubmitInfo_pWaitSemaphores_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo, pWaitSemaphores));
    exports["VkSubmitInfo_pWaitDstStageMask_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo, pWaitDstStageMask));
    exports["VkSubmitInfo_commandBufferCount_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo, commandBufferCount));
    exports["VkSubmitInfo_pCommandBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo, pCommandBuffers));
    exports["VkSubmitInfo_signalSemaphoreCount_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo, signalSemaphoreCount));
    exports["VkSubmitInfo_pSignalSemaphores_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo, pSignalSemaphores));
    exports["VkSubmitInfo_sizeof"] = Napi::Number::New(env, sizeof(VkSubmitInfo));
#ifdef VK_KHR_display
    exports["VkDisplayPropertiesKHR_display_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPropertiesKHR, display));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPropertiesKHR_displayName_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPropertiesKHR, displayName));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPropertiesKHR_physicalDimensions_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPropertiesKHR, physicalDimensions));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPropertiesKHR_physicalResolution_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPropertiesKHR, physicalResolution));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPropertiesKHR_supportedTransforms_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPropertiesKHR, supportedTransforms));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPropertiesKHR_planeReorderPossible_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPropertiesKHR, planeReorderPossible));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPropertiesKHR_persistentContent_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPropertiesKHR, persistentContent));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDisplayPropertiesKHR));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPlanePropertiesKHR_currentDisplay_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlanePropertiesKHR, currentDisplay));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPlanePropertiesKHR_currentStackIndex_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlanePropertiesKHR, currentStackIndex));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPlanePropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDisplayPlanePropertiesKHR));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayModeParametersKHR_visibleRegion_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayModeParametersKHR, visibleRegion));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayModeParametersKHR_refreshRate_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayModeParametersKHR, refreshRate));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayModeParametersKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDisplayModeParametersKHR));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayModePropertiesKHR_displayMode_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayModePropertiesKHR, displayMode));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayModePropertiesKHR_parameters_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayModePropertiesKHR, parameters));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayModePropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDisplayModePropertiesKHR));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayModeCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayModeCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayModeCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayModeCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayModeCreateInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayModeCreateInfoKHR, flags));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayModeCreateInfoKHR_parameters_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayModeCreateInfoKHR, parameters));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayModeCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDisplayModeCreateInfoKHR));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPlaneCapabilitiesKHR_supportedAlpha_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneCapabilitiesKHR, supportedAlpha));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPlaneCapabilitiesKHR_minSrcPosition_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneCapabilitiesKHR, minSrcPosition));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPlaneCapabilitiesKHR_maxSrcPosition_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneCapabilitiesKHR, maxSrcPosition));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPlaneCapabilitiesKHR_minSrcExtent_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneCapabilitiesKHR, minSrcExtent));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPlaneCapabilitiesKHR_maxSrcExtent_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneCapabilitiesKHR, maxSrcExtent));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPlaneCapabilitiesKHR_minDstPosition_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneCapabilitiesKHR, minDstPosition));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPlaneCapabilitiesKHR_maxDstPosition_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneCapabilitiesKHR, maxDstPosition));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPlaneCapabilitiesKHR_minDstExtent_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneCapabilitiesKHR, minDstExtent));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPlaneCapabilitiesKHR_maxDstExtent_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneCapabilitiesKHR, maxDstExtent));
#endif
#ifdef VK_KHR_display
    exports["VkDisplayPlaneCapabilitiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDisplayPlaneCapabilitiesKHR));
#endif
#ifdef VK_KHR_display
    exports["VkDisplaySurfaceCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDisplaySurfaceCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_display
    exports["VkDisplaySurfaceCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDisplaySurfaceCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_display
    exports["VkDisplaySurfaceCreateInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkDisplaySurfaceCreateInfoKHR, flags));
#endif
#ifdef VK_KHR_display
    exports["VkDisplaySurfaceCreateInfoKHR_displayMode_offsetof"] = Napi::Number::New(env, offsetof(VkDisplaySurfaceCreateInfoKHR, displayMode));
#endif
#ifdef VK_KHR_display
    exports["VkDisplaySurfaceCreateInfoKHR_planeIndex_offsetof"] = Napi::Number::New(env, offsetof(VkDisplaySurfaceCreateInfoKHR, planeIndex));
#endif
#ifdef VK_KHR_display
    exports["VkDisplaySurfaceCreateInfoKHR_planeStackIndex_offsetof"] = Napi::Number::New(env, offsetof(VkDisplaySurfaceCreateInfoKHR, planeStackIndex));
#endif
#ifdef VK_KHR_display
    exports["VkDisplaySurfaceCreateInfoKHR_transform_offsetof"] = Napi::Number::New(env, offsetof(VkDisplaySurfaceCreateInfoKHR, transform));
#endif
#ifdef VK_KHR_display
    exports["VkDisplaySurfaceCreateInfoKHR_globalAlpha_offsetof"] = Napi::Number::New(env, offsetof(VkDisplaySurfaceCreateInfoKHR, globalAlpha));
#endif
#ifdef VK_KHR_display
    exports["VkDisplaySurfaceCreateInfoKHR_alphaMode_offsetof"] = Napi::Number::New(env, offsetof(VkDisplaySurfaceCreateInfoKHR, alphaMode));
#endif
#ifdef VK_KHR_display
    exports["VkDisplaySurfaceCreateInfoKHR_imageExtent_offsetof"] = Napi::Number::New(env, offsetof(VkDisplaySurfaceCreateInfoKHR, imageExtent));
#endif
#ifdef VK_KHR_display
    exports["VkDisplaySurfaceCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDisplaySurfaceCreateInfoKHR));
#endif
#ifdef VK_KHR_display_swapchain
    exports["VkDisplayPresentInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPresentInfoKHR, sType));
#endif
#ifdef VK_KHR_display_swapchain
    exports["VkDisplayPresentInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPresentInfoKHR, pNext));
#endif
#ifdef VK_KHR_display_swapchain
    exports["VkDisplayPresentInfoKHR_srcRect_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPresentInfoKHR, srcRect));
#endif
#ifdef VK_KHR_display_swapchain
    exports["VkDisplayPresentInfoKHR_dstRect_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPresentInfoKHR, dstRect));
#endif
#ifdef VK_KHR_display_swapchain
    exports["VkDisplayPresentInfoKHR_persistent_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPresentInfoKHR, persistent));
#endif
#ifdef VK_KHR_display_swapchain
    exports["VkDisplayPresentInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDisplayPresentInfoKHR));
#endif
#ifdef VK_KHR_surface
    exports["VkSurfaceCapabilitiesKHR_minImageCount_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilitiesKHR, minImageCount));
#endif
#ifdef VK_KHR_surface
    exports["VkSurfaceCapabilitiesKHR_maxImageCount_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilitiesKHR, maxImageCount));
#endif
#ifdef VK_KHR_surface
    exports["VkSurfaceCapabilitiesKHR_currentExtent_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilitiesKHR, currentExtent));
#endif
#ifdef VK_KHR_surface
    exports["VkSurfaceCapabilitiesKHR_minImageExtent_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilitiesKHR, minImageExtent));
#endif
#ifdef VK_KHR_surface
    exports["VkSurfaceCapabilitiesKHR_maxImageExtent_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilitiesKHR, maxImageExtent));
#endif
#ifdef VK_KHR_surface
    exports["VkSurfaceCapabilitiesKHR_maxImageArrayLayers_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilitiesKHR, maxImageArrayLayers));
#endif
#ifdef VK_KHR_surface
    exports["VkSurfaceCapabilitiesKHR_supportedTransforms_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilitiesKHR, supportedTransforms));
#endif
#ifdef VK_KHR_surface
    exports["VkSurfaceCapabilitiesKHR_currentTransform_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilitiesKHR, currentTransform));
#endif
#ifdef VK_KHR_surface
    exports["VkSurfaceCapabilitiesKHR_supportedCompositeAlpha_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilitiesKHR, supportedCompositeAlpha));
#endif
#ifdef VK_KHR_surface
    exports["VkSurfaceCapabilitiesKHR_supportedUsageFlags_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilitiesKHR, supportedUsageFlags));
#endif
#ifdef VK_KHR_surface
    exports["VkSurfaceCapabilitiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkSurfaceCapabilitiesKHR));
#endif
#ifdef VK_KHR_android_surface
    exports["VkAndroidSurfaceCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidSurfaceCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_android_surface
    exports["VkAndroidSurfaceCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidSurfaceCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_android_surface
    exports["VkAndroidSurfaceCreateInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidSurfaceCreateInfoKHR, flags));
#endif
#ifdef VK_KHR_android_surface
    exports["VkAndroidSurfaceCreateInfoKHR_window_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidSurfaceCreateInfoKHR, window));
#endif
#ifdef VK_KHR_android_surface
    exports["VkAndroidSurfaceCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkAndroidSurfaceCreateInfoKHR));
#endif
#ifdef VK_NN_vi_surface
    exports["VkViSurfaceCreateInfoNN_sType_offsetof"] = Napi::Number::New(env, offsetof(VkViSurfaceCreateInfoNN, sType));
#endif
#ifdef VK_NN_vi_surface
    exports["VkViSurfaceCreateInfoNN_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkViSurfaceCreateInfoNN, pNext));
#endif
#ifdef VK_NN_vi_surface
    exports["VkViSurfaceCreateInfoNN_flags_offsetof"] = Napi::Number::New(env, offsetof(VkViSurfaceCreateInfoNN, flags));
#endif
#ifdef VK_NN_vi_surface
    exports["VkViSurfaceCreateInfoNN_window_offsetof"] = Napi::Number::New(env, offsetof(VkViSurfaceCreateInfoNN, window));
#endif
#ifdef VK_NN_vi_surface
    exports["VkViSurfaceCreateInfoNN_sizeof"] = Napi::Number::New(env, sizeof(VkViSurfaceCreateInfoNN));
#endif
#ifdef VK_KHR_wayland_surface
    exports["VkWaylandSurfaceCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkWaylandSurfaceCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_wayland_surface
    exports["VkWaylandSurfaceCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkWaylandSurfaceCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_wayland_surface
    exports["VkWaylandSurfaceCreateInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkWaylandSurfaceCreateInfoKHR, flags));
#endif
#ifdef VK_KHR_wayland_surface
    exports["VkWaylandSurfaceCreateInfoKHR_display_offsetof"] = Napi::Number::New(env, offsetof(VkWaylandSurfaceCreateInfoKHR, display));
#endif
#ifdef VK_KHR_wayland_surface
    exports["VkWaylandSurfaceCreateInfoKHR_surface_offsetof"] = Napi::Number::New(env, offsetof(VkWaylandSurfaceCreateInfoKHR, surface));
#endif
#ifdef VK_KHR_wayland_surface
    exports["VkWaylandSurfaceCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkWaylandSurfaceCreateInfoKHR));
#endif
#ifdef VK_KHR_win32_surface
    exports["VkWin32SurfaceCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkWin32SurfaceCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_win32_surface
    exports["VkWin32SurfaceCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkWin32SurfaceCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_win32_surface
    exports["VkWin32SurfaceCreateInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkWin32SurfaceCreateInfoKHR, flags));
#endif
#ifdef VK_KHR_win32_surface
    exports["VkWin32SurfaceCreateInfoKHR_hinstance_offsetof"] = Napi::Number::New(env, offsetof(VkWin32SurfaceCreateInfoKHR, hinstance));
#endif
#ifdef VK_KHR_win32_surface
    exports["VkWin32SurfaceCreateInfoKHR_hwnd_offsetof"] = Napi::Number::New(env, offsetof(VkWin32SurfaceCreateInfoKHR, hwnd));
#endif
#ifdef VK_KHR_win32_surface
    exports["VkWin32SurfaceCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkWin32SurfaceCreateInfoKHR));
#endif
#ifdef VK_KHR_xlib_surface
    exports["VkXlibSurfaceCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkXlibSurfaceCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_xlib_surface
    exports["VkXlibSurfaceCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkXlibSurfaceCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_xlib_surface
    exports["VkXlibSurfaceCreateInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkXlibSurfaceCreateInfoKHR, flags));
#endif
#ifdef VK_KHR_xlib_surface
    exports["VkXlibSurfaceCreateInfoKHR_dpy_offsetof"] = Napi::Number::New(env, offsetof(VkXlibSurfaceCreateInfoKHR, dpy));
#endif
#ifdef VK_KHR_xlib_surface
    exports["VkXlibSurfaceCreateInfoKHR_window_offsetof"] = Napi::Number::New(env, offsetof(VkXlibSurfaceCreateInfoKHR, window));
#endif
#ifdef VK_KHR_xlib_surface
    exports["VkXlibSurfaceCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkXlibSurfaceCreateInfoKHR));
#endif
#ifdef VK_KHR_xcb_surface
    exports["VkXcbSurfaceCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkXcbSurfaceCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_xcb_surface
    exports["VkXcbSurfaceCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkXcbSurfaceCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_xcb_surface
    exports["VkXcbSurfaceCreateInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkXcbSurfaceCreateInfoKHR, flags));
#endif
#ifdef VK_KHR_xcb_surface
    exports["VkXcbSurfaceCreateInfoKHR_connection_offsetof"] = Napi::Number::New(env, offsetof(VkXcbSurfaceCreateInfoKHR, connection));
#endif
#ifdef VK_KHR_xcb_surface
    exports["VkXcbSurfaceCreateInfoKHR_window_offsetof"] = Napi::Number::New(env, offsetof(VkXcbSurfaceCreateInfoKHR, window));
#endif
#ifdef VK_KHR_xcb_surface
    exports["VkXcbSurfaceCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkXcbSurfaceCreateInfoKHR));
#endif
#ifdef VK_EXT_directfb_surface
    exports["VkDirectFBSurfaceCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDirectFBSurfaceCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_directfb_surface
    exports["VkDirectFBSurfaceCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDirectFBSurfaceCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_directfb_surface
    exports["VkDirectFBSurfaceCreateInfoEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkDirectFBSurfaceCreateInfoEXT, flags));
#endif
#ifdef VK_EXT_directfb_surface
    exports["VkDirectFBSurfaceCreateInfoEXT_dfb_offsetof"] = Napi::Number::New(env, offsetof(VkDirectFBSurfaceCreateInfoEXT, dfb));
#endif
#ifdef VK_EXT_directfb_surface
    exports["VkDirectFBSurfaceCreateInfoEXT_surface_offsetof"] = Napi::Number::New(env, offsetof(VkDirectFBSurfaceCreateInfoEXT, surface));
#endif
#ifdef VK_EXT_directfb_surface
    exports["VkDirectFBSurfaceCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDirectFBSurfaceCreateInfoEXT));
#endif
#ifdef VK_FUCHSIA_imagepipe_surface
    exports["VkImagePipeSurfaceCreateInfoFUCHSIA_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImagePipeSurfaceCreateInfoFUCHSIA, sType));
#endif
#ifdef VK_FUCHSIA_imagepipe_surface
    exports["VkImagePipeSurfaceCreateInfoFUCHSIA_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImagePipeSurfaceCreateInfoFUCHSIA, pNext));
#endif
#ifdef VK_FUCHSIA_imagepipe_surface
    exports["VkImagePipeSurfaceCreateInfoFUCHSIA_flags_offsetof"] = Napi::Number::New(env, offsetof(VkImagePipeSurfaceCreateInfoFUCHSIA, flags));
#endif
#ifdef VK_FUCHSIA_imagepipe_surface
    exports["VkImagePipeSurfaceCreateInfoFUCHSIA_imagePipeHandle_offsetof"] = Napi::Number::New(env, offsetof(VkImagePipeSurfaceCreateInfoFUCHSIA, imagePipeHandle));
#endif
#ifdef VK_FUCHSIA_imagepipe_surface
    exports["VkImagePipeSurfaceCreateInfoFUCHSIA_sizeof"] = Napi::Number::New(env, sizeof(VkImagePipeSurfaceCreateInfoFUCHSIA));
#endif
#ifdef VK_GGP_stream_descriptor_surface
    exports["VkStreamDescriptorSurfaceCreateInfoGGP_sType_offsetof"] = Napi::Number::New(env, offsetof(VkStreamDescriptorSurfaceCreateInfoGGP, sType));
#endif
#ifdef VK_GGP_stream_descriptor_surface
    exports["VkStreamDescriptorSurfaceCreateInfoGGP_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkStreamDescriptorSurfaceCreateInfoGGP, pNext));
#endif
#ifdef VK_GGP_stream_descriptor_surface
    exports["VkStreamDescriptorSurfaceCreateInfoGGP_flags_offsetof"] = Napi::Number::New(env, offsetof(VkStreamDescriptorSurfaceCreateInfoGGP, flags));
#endif
#ifdef VK_GGP_stream_descriptor_surface
    exports["VkStreamDescriptorSurfaceCreateInfoGGP_streamDescriptor_offsetof"] = Napi::Number::New(env, offsetof(VkStreamDescriptorSurfaceCreateInfoGGP, streamDescriptor));
#endif
#ifdef VK_GGP_stream_descriptor_surface
    exports["VkStreamDescriptorSurfaceCreateInfoGGP_sizeof"] = Napi::Number::New(env, sizeof(VkStreamDescriptorSurfaceCreateInfoGGP));
#endif
#ifdef VK_QNX_screen_surface
    exports["VkScreenSurfaceCreateInfoQNX_sType_offsetof"] = Napi::Number::New(env, offsetof(VkScreenSurfaceCreateInfoQNX, sType));
#endif
#ifdef VK_QNX_screen_surface
    exports["VkScreenSurfaceCreateInfoQNX_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkScreenSurfaceCreateInfoQNX, pNext));
#endif
#ifdef VK_QNX_screen_surface
    exports["VkScreenSurfaceCreateInfoQNX_flags_offsetof"] = Napi::Number::New(env, offsetof(VkScreenSurfaceCreateInfoQNX, flags));
#endif
#ifdef VK_QNX_screen_surface
    exports["VkScreenSurfaceCreateInfoQNX_context_offsetof"] = Napi::Number::New(env, offsetof(VkScreenSurfaceCreateInfoQNX, context));
#endif
#ifdef VK_QNX_screen_surface
    exports["VkScreenSurfaceCreateInfoQNX_window_offsetof"] = Napi::Number::New(env, offsetof(VkScreenSurfaceCreateInfoQNX, window));
#endif
#ifdef VK_QNX_screen_surface
    exports["VkScreenSurfaceCreateInfoQNX_sizeof"] = Napi::Number::New(env, sizeof(VkScreenSurfaceCreateInfoQNX));
#endif
#ifdef VK_KHR_surface
    exports["VkSurfaceFormatKHR_format_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceFormatKHR, format));
#endif
#ifdef VK_KHR_surface
    exports["VkSurfaceFormatKHR_colorSpace_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceFormatKHR, colorSpace));
#endif
#ifdef VK_KHR_surface
    exports["VkSurfaceFormatKHR_sizeof"] = Napi::Number::New(env, sizeof(VkSurfaceFormatKHR));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, flags));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_surface_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, surface));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_minImageCount_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, minImageCount));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_imageFormat_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, imageFormat));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_imageColorSpace_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, imageColorSpace));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_imageExtent_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, imageExtent));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_imageArrayLayers_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, imageArrayLayers));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_imageUsage_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, imageUsage));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_imageSharingMode_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, imageSharingMode));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_queueFamilyIndexCount_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, queueFamilyIndexCount));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_pQueueFamilyIndices_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, pQueueFamilyIndices));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_preTransform_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, preTransform));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_compositeAlpha_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, compositeAlpha));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_presentMode_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, presentMode));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_clipped_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, clipped));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_oldSwapchain_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCreateInfoKHR, oldSwapchain));
#endif
#ifdef VK_KHR_swapchain
    exports["VkSwapchainCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkSwapchainCreateInfoKHR));
#endif
#ifdef VK_KHR_swapchain
    exports["VkPresentInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPresentInfoKHR, sType));
#endif
#ifdef VK_KHR_swapchain
    exports["VkPresentInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPresentInfoKHR, pNext));
#endif
#ifdef VK_KHR_swapchain
    exports["VkPresentInfoKHR_waitSemaphoreCount_offsetof"] = Napi::Number::New(env, offsetof(VkPresentInfoKHR, waitSemaphoreCount));
#endif
#ifdef VK_KHR_swapchain
    exports["VkPresentInfoKHR_pWaitSemaphores_offsetof"] = Napi::Number::New(env, offsetof(VkPresentInfoKHR, pWaitSemaphores));
#endif
#ifdef VK_KHR_swapchain
    exports["VkPresentInfoKHR_swapchainCount_offsetof"] = Napi::Number::New(env, offsetof(VkPresentInfoKHR, swapchainCount));
#endif
#ifdef VK_KHR_swapchain
    exports["VkPresentInfoKHR_pSwapchains_offsetof"] = Napi::Number::New(env, offsetof(VkPresentInfoKHR, pSwapchains));
#endif
#ifdef VK_KHR_swapchain
    exports["VkPresentInfoKHR_pImageIndices_offsetof"] = Napi::Number::New(env, offsetof(VkPresentInfoKHR, pImageIndices));
#endif
#ifdef VK_KHR_swapchain
    exports["VkPresentInfoKHR_pResults_offsetof"] = Napi::Number::New(env, offsetof(VkPresentInfoKHR, pResults));
#endif
#ifdef VK_KHR_swapchain
    exports["VkPresentInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPresentInfoKHR));
#endif
#ifdef VK_EXT_debug_report
    exports["VkDebugReportCallbackCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDebugReportCallbackCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_debug_report
    exports["VkDebugReportCallbackCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDebugReportCallbackCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_debug_report
    exports["VkDebugReportCallbackCreateInfoEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkDebugReportCallbackCreateInfoEXT, flags));
#endif
#ifdef VK_EXT_debug_report
    exports["VkDebugReportCallbackCreateInfoEXT_pfnCallback_offsetof"] = Napi::Number::New(env, offsetof(VkDebugReportCallbackCreateInfoEXT, pfnCallback));
#endif
#ifdef VK_EXT_debug_report
    exports["VkDebugReportCallbackCreateInfoEXT_pUserData_offsetof"] = Napi::Number::New(env, offsetof(VkDebugReportCallbackCreateInfoEXT, pUserData));
#endif
#ifdef VK_EXT_debug_report
    exports["VkDebugReportCallbackCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDebugReportCallbackCreateInfoEXT));
#endif
#ifdef VK_EXT_validation_flags
    exports["VkValidationFlagsEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkValidationFlagsEXT, sType));
#endif
#ifdef VK_EXT_validation_flags
    exports["VkValidationFlagsEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkValidationFlagsEXT, pNext));
#endif
#ifdef VK_EXT_validation_flags
    exports["VkValidationFlagsEXT_disabledValidationCheckCount_offsetof"] = Napi::Number::New(env, offsetof(VkValidationFlagsEXT, disabledValidationCheckCount));
#endif
#ifdef VK_EXT_validation_flags
    exports["VkValidationFlagsEXT_pDisabledValidationChecks_offsetof"] = Napi::Number::New(env, offsetof(VkValidationFlagsEXT, pDisabledValidationChecks));
#endif
#ifdef VK_EXT_validation_flags
    exports["VkValidationFlagsEXT_sizeof"] = Napi::Number::New(env, sizeof(VkValidationFlagsEXT));
#endif
#ifdef VK_EXT_validation_features
    exports["VkValidationFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkValidationFeaturesEXT, sType));
#endif
#ifdef VK_EXT_validation_features
    exports["VkValidationFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkValidationFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_validation_features
    exports["VkValidationFeaturesEXT_enabledValidationFeatureCount_offsetof"] = Napi::Number::New(env, offsetof(VkValidationFeaturesEXT, enabledValidationFeatureCount));
#endif
#ifdef VK_EXT_validation_features
    exports["VkValidationFeaturesEXT_pEnabledValidationFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkValidationFeaturesEXT, pEnabledValidationFeatures));
#endif
#ifdef VK_EXT_validation_features
    exports["VkValidationFeaturesEXT_disabledValidationFeatureCount_offsetof"] = Napi::Number::New(env, offsetof(VkValidationFeaturesEXT, disabledValidationFeatureCount));
#endif
#ifdef VK_EXT_validation_features
    exports["VkValidationFeaturesEXT_pDisabledValidationFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkValidationFeaturesEXT, pDisabledValidationFeatures));
#endif
#ifdef VK_EXT_validation_features
    exports["VkValidationFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkValidationFeaturesEXT));
#endif
#ifdef VK_AMD_rasterization_order
    exports["VkPipelineRasterizationStateRasterizationOrderAMD_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateRasterizationOrderAMD, sType));
#endif
#ifdef VK_AMD_rasterization_order
    exports["VkPipelineRasterizationStateRasterizationOrderAMD_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateRasterizationOrderAMD, pNext));
#endif
#ifdef VK_AMD_rasterization_order
    exports["VkPipelineRasterizationStateRasterizationOrderAMD_rasterizationOrder_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateRasterizationOrderAMD, rasterizationOrder));
#endif
#ifdef VK_AMD_rasterization_order
    exports["VkPipelineRasterizationStateRasterizationOrderAMD_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineRasterizationStateRasterizationOrderAMD));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerObjectNameInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDebugMarkerObjectNameInfoEXT, sType));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerObjectNameInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDebugMarkerObjectNameInfoEXT, pNext));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerObjectNameInfoEXT_objectType_offsetof"] = Napi::Number::New(env, offsetof(VkDebugMarkerObjectNameInfoEXT, objectType));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerObjectNameInfoEXT_object_offsetof"] = Napi::Number::New(env, offsetof(VkDebugMarkerObjectNameInfoEXT, object));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerObjectNameInfoEXT_pObjectName_offsetof"] = Napi::Number::New(env, offsetof(VkDebugMarkerObjectNameInfoEXT, pObjectName));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerObjectNameInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDebugMarkerObjectNameInfoEXT));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerObjectTagInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDebugMarkerObjectTagInfoEXT, sType));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerObjectTagInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDebugMarkerObjectTagInfoEXT, pNext));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerObjectTagInfoEXT_objectType_offsetof"] = Napi::Number::New(env, offsetof(VkDebugMarkerObjectTagInfoEXT, objectType));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerObjectTagInfoEXT_object_offsetof"] = Napi::Number::New(env, offsetof(VkDebugMarkerObjectTagInfoEXT, object));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerObjectTagInfoEXT_tagName_offsetof"] = Napi::Number::New(env, offsetof(VkDebugMarkerObjectTagInfoEXT, tagName));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerObjectTagInfoEXT_tagSize_offsetof"] = Napi::Number::New(env, offsetof(VkDebugMarkerObjectTagInfoEXT, tagSize));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerObjectTagInfoEXT_pTag_offsetof"] = Napi::Number::New(env, offsetof(VkDebugMarkerObjectTagInfoEXT, pTag));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerObjectTagInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDebugMarkerObjectTagInfoEXT));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerMarkerInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDebugMarkerMarkerInfoEXT, sType));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerMarkerInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDebugMarkerMarkerInfoEXT, pNext));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerMarkerInfoEXT_pMarkerName_offsetof"] = Napi::Number::New(env, offsetof(VkDebugMarkerMarkerInfoEXT, pMarkerName));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerMarkerInfoEXT_color_offsetof"] = Napi::Number::New(env, offsetof(VkDebugMarkerMarkerInfoEXT, color));
#endif
#ifdef VK_EXT_debug_marker
    exports["VkDebugMarkerMarkerInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDebugMarkerMarkerInfoEXT));
#endif
#ifdef VK_NV_dedicated_allocation
    exports["VkDedicatedAllocationImageCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDedicatedAllocationImageCreateInfoNV, sType));
#endif
#ifdef VK_NV_dedicated_allocation
    exports["VkDedicatedAllocationImageCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDedicatedAllocationImageCreateInfoNV, pNext));
#endif
#ifdef VK_NV_dedicated_allocation
    exports["VkDedicatedAllocationImageCreateInfoNV_dedicatedAllocation_offsetof"] = Napi::Number::New(env, offsetof(VkDedicatedAllocationImageCreateInfoNV, dedicatedAllocation));
#endif
#ifdef VK_NV_dedicated_allocation
    exports["VkDedicatedAllocationImageCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkDedicatedAllocationImageCreateInfoNV));
#endif
#ifdef VK_NV_dedicated_allocation
    exports["VkDedicatedAllocationBufferCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDedicatedAllocationBufferCreateInfoNV, sType));
#endif
#ifdef VK_NV_dedicated_allocation
    exports["VkDedicatedAllocationBufferCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDedicatedAllocationBufferCreateInfoNV, pNext));
#endif
#ifdef VK_NV_dedicated_allocation
    exports["VkDedicatedAllocationBufferCreateInfoNV_dedicatedAllocation_offsetof"] = Napi::Number::New(env, offsetof(VkDedicatedAllocationBufferCreateInfoNV, dedicatedAllocation));
#endif
#ifdef VK_NV_dedicated_allocation
    exports["VkDedicatedAllocationBufferCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkDedicatedAllocationBufferCreateInfoNV));
#endif
#ifdef VK_NV_dedicated_allocation
    exports["VkDedicatedAllocationMemoryAllocateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDedicatedAllocationMemoryAllocateInfoNV, sType));
#endif
#ifdef VK_NV_dedicated_allocation
    exports["VkDedicatedAllocationMemoryAllocateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDedicatedAllocationMemoryAllocateInfoNV, pNext));
#endif
#ifdef VK_NV_dedicated_allocation
    exports["VkDedicatedAllocationMemoryAllocateInfoNV_image_offsetof"] = Napi::Number::New(env, offsetof(VkDedicatedAllocationMemoryAllocateInfoNV, image));
#endif
#ifdef VK_NV_dedicated_allocation
    exports["VkDedicatedAllocationMemoryAllocateInfoNV_buffer_offsetof"] = Napi::Number::New(env, offsetof(VkDedicatedAllocationMemoryAllocateInfoNV, buffer));
#endif
#ifdef VK_NV_dedicated_allocation
    exports["VkDedicatedAllocationMemoryAllocateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkDedicatedAllocationMemoryAllocateInfoNV));
#endif
#ifdef VK_NV_external_memory_capabilities
    exports["VkExternalImageFormatPropertiesNV_imageFormatProperties_offsetof"] = Napi::Number::New(env, offsetof(VkExternalImageFormatPropertiesNV, imageFormatProperties));
#endif
#ifdef VK_NV_external_memory_capabilities
    exports["VkExternalImageFormatPropertiesNV_externalMemoryFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkExternalImageFormatPropertiesNV, externalMemoryFeatures));
#endif
#ifdef VK_NV_external_memory_capabilities
    exports["VkExternalImageFormatPropertiesNV_exportFromImportedHandleTypes_offsetof"] = Napi::Number::New(env, offsetof(VkExternalImageFormatPropertiesNV, exportFromImportedHandleTypes));
#endif
#ifdef VK_NV_external_memory_capabilities
    exports["VkExternalImageFormatPropertiesNV_compatibleHandleTypes_offsetof"] = Napi::Number::New(env, offsetof(VkExternalImageFormatPropertiesNV, compatibleHandleTypes));
#endif
#ifdef VK_NV_external_memory_capabilities
    exports["VkExternalImageFormatPropertiesNV_sizeof"] = Napi::Number::New(env, sizeof(VkExternalImageFormatPropertiesNV));
#endif
#ifdef VK_NV_external_memory
    exports["VkExternalMemoryImageCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExternalMemoryImageCreateInfoNV, sType));
#endif
#ifdef VK_NV_external_memory
    exports["VkExternalMemoryImageCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExternalMemoryImageCreateInfoNV, pNext));
#endif
#ifdef VK_NV_external_memory
    exports["VkExternalMemoryImageCreateInfoNV_handleTypes_offsetof"] = Napi::Number::New(env, offsetof(VkExternalMemoryImageCreateInfoNV, handleTypes));
#endif
#ifdef VK_NV_external_memory
    exports["VkExternalMemoryImageCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkExternalMemoryImageCreateInfoNV));
#endif
#ifdef VK_NV_external_memory
    exports["VkExportMemoryAllocateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExportMemoryAllocateInfoNV, sType));
#endif
#ifdef VK_NV_external_memory
    exports["VkExportMemoryAllocateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExportMemoryAllocateInfoNV, pNext));
#endif
#ifdef VK_NV_external_memory
    exports["VkExportMemoryAllocateInfoNV_handleTypes_offsetof"] = Napi::Number::New(env, offsetof(VkExportMemoryAllocateInfoNV, handleTypes));
#endif
#ifdef VK_NV_external_memory
    exports["VkExportMemoryAllocateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkExportMemoryAllocateInfoNV));
#endif
#ifdef VK_NV_external_memory_win32
    exports["VkImportMemoryWin32HandleInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryWin32HandleInfoNV, sType));
#endif
#ifdef VK_NV_external_memory_win32
    exports["VkImportMemoryWin32HandleInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryWin32HandleInfoNV, pNext));
#endif
#ifdef VK_NV_external_memory_win32
    exports["VkImportMemoryWin32HandleInfoNV_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryWin32HandleInfoNV, handleType));
#endif
#ifdef VK_NV_external_memory_win32
    exports["VkImportMemoryWin32HandleInfoNV_handle_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryWin32HandleInfoNV, handle));
#endif
#ifdef VK_NV_external_memory_win32
    exports["VkImportMemoryWin32HandleInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkImportMemoryWin32HandleInfoNV));
#endif
#ifdef VK_NV_external_memory_win32
    exports["VkExportMemoryWin32HandleInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExportMemoryWin32HandleInfoNV, sType));
#endif
#ifdef VK_NV_external_memory_win32
    exports["VkExportMemoryWin32HandleInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExportMemoryWin32HandleInfoNV, pNext));
#endif
#ifdef VK_NV_external_memory_win32
    exports["VkExportMemoryWin32HandleInfoNV_pAttributes_offsetof"] = Napi::Number::New(env, offsetof(VkExportMemoryWin32HandleInfoNV, pAttributes));
#endif
#ifdef VK_NV_external_memory_win32
    exports["VkExportMemoryWin32HandleInfoNV_dwAccess_offsetof"] = Napi::Number::New(env, offsetof(VkExportMemoryWin32HandleInfoNV, dwAccess));
#endif
#ifdef VK_NV_external_memory_win32
    exports["VkExportMemoryWin32HandleInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkExportMemoryWin32HandleInfoNV));
#endif
#ifdef VK_NV_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoNV, sType));
#endif
#ifdef VK_NV_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoNV, pNext));
#endif
#ifdef VK_NV_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoNV_acquireCount_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoNV, acquireCount));
#endif
#ifdef VK_NV_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoNV_pAcquireSyncs_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoNV, pAcquireSyncs));
#endif
#ifdef VK_NV_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoNV_pAcquireKeys_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoNV, pAcquireKeys));
#endif
#ifdef VK_NV_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoNV_pAcquireTimeoutMilliseconds_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoNV, pAcquireTimeoutMilliseconds));
#endif
#ifdef VK_NV_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoNV_releaseCount_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoNV, releaseCount));
#endif
#ifdef VK_NV_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoNV_pReleaseSyncs_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoNV, pReleaseSyncs));
#endif
#ifdef VK_NV_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoNV_pReleaseKeys_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoNV, pReleaseKeys));
#endif
#ifdef VK_NV_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkWin32KeyedMutexAcquireReleaseInfoNV));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV, sType));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV, pNext));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV_deviceGeneratedCommands_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV, deviceGeneratedCommands));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV));
#endif
    exports["VkDevicePrivateDataCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDevicePrivateDataCreateInfo, sType));
    exports["VkDevicePrivateDataCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDevicePrivateDataCreateInfo, pNext));
    exports["VkDevicePrivateDataCreateInfo_privateDataSlotRequestCount_offsetof"] = Napi::Number::New(env, offsetof(VkDevicePrivateDataCreateInfo, privateDataSlotRequestCount));
    exports["VkDevicePrivateDataCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDevicePrivateDataCreateInfo));
#ifdef VK_EXT_private_data
    exports["VkDevicePrivateDataCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDevicePrivateDataCreateInfoEXT));
#endif
    exports["VkPrivateDataSlotCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPrivateDataSlotCreateInfo, sType));
    exports["VkPrivateDataSlotCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPrivateDataSlotCreateInfo, pNext));
    exports["VkPrivateDataSlotCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPrivateDataSlotCreateInfo, flags));
    exports["VkPrivateDataSlotCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPrivateDataSlotCreateInfo));
#ifdef VK_EXT_private_data
    exports["VkPrivateDataSlotCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPrivateDataSlotCreateInfoEXT));
#endif
    exports["VkPhysicalDevicePrivateDataFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePrivateDataFeatures, sType));
    exports["VkPhysicalDevicePrivateDataFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePrivateDataFeatures, pNext));
    exports["VkPhysicalDevicePrivateDataFeatures_privateData_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePrivateDataFeatures, privateData));
    exports["VkPhysicalDevicePrivateDataFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePrivateDataFeatures));
#ifdef VK_EXT_private_data
    exports["VkPhysicalDevicePrivateDataFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePrivateDataFeaturesEXT));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, sType));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, pNext));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV_maxGraphicsShaderGroupCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, maxGraphicsShaderGroupCount));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV_maxIndirectSequenceCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, maxIndirectSequenceCount));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV_maxIndirectCommandsTokenCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, maxIndirectCommandsTokenCount));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV_maxIndirectCommandsStreamCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, maxIndirectCommandsStreamCount));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV_maxIndirectCommandsTokenOffset_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, maxIndirectCommandsTokenOffset));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV_maxIndirectCommandsStreamStride_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, maxIndirectCommandsStreamStride));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV_minSequencesCountBufferOffsetAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, minSequencesCountBufferOffsetAlignment));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV_minSequencesIndexBufferOffsetAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, minSequencesIndexBufferOffsetAlignment));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV_minIndirectCommandsBufferOffsetAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, minIndirectCommandsBufferOffsetAlignment));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV));
#endif
#ifdef VK_EXT_multi_draw
    exports["VkPhysicalDeviceMultiDrawPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiDrawPropertiesEXT, sType));
#endif
#ifdef VK_EXT_multi_draw
    exports["VkPhysicalDeviceMultiDrawPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiDrawPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_multi_draw
    exports["VkPhysicalDeviceMultiDrawPropertiesEXT_maxMultiDrawCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiDrawPropertiesEXT, maxMultiDrawCount));
#endif
#ifdef VK_EXT_multi_draw
    exports["VkPhysicalDeviceMultiDrawPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMultiDrawPropertiesEXT));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGraphicsShaderGroupCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsShaderGroupCreateInfoNV, sType));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGraphicsShaderGroupCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsShaderGroupCreateInfoNV, pNext));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGraphicsShaderGroupCreateInfoNV_stageCount_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsShaderGroupCreateInfoNV, stageCount));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGraphicsShaderGroupCreateInfoNV_pStages_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsShaderGroupCreateInfoNV, pStages));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGraphicsShaderGroupCreateInfoNV_pVertexInputState_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsShaderGroupCreateInfoNV, pVertexInputState));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGraphicsShaderGroupCreateInfoNV_pTessellationState_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsShaderGroupCreateInfoNV, pTessellationState));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGraphicsShaderGroupCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkGraphicsShaderGroupCreateInfoNV));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGraphicsPipelineShaderGroupsCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineShaderGroupsCreateInfoNV, sType));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGraphicsPipelineShaderGroupsCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineShaderGroupsCreateInfoNV, pNext));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGraphicsPipelineShaderGroupsCreateInfoNV_groupCount_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineShaderGroupsCreateInfoNV, groupCount));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGraphicsPipelineShaderGroupsCreateInfoNV_pGroups_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineShaderGroupsCreateInfoNV, pGroups));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGraphicsPipelineShaderGroupsCreateInfoNV_pipelineCount_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineShaderGroupsCreateInfoNV, pipelineCount));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGraphicsPipelineShaderGroupsCreateInfoNV_pPipelines_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineShaderGroupsCreateInfoNV, pPipelines));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGraphicsPipelineShaderGroupsCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkGraphicsPipelineShaderGroupsCreateInfoNV));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkBindShaderGroupIndirectCommandNV_groupIndex_offsetof"] = Napi::Number::New(env, offsetof(VkBindShaderGroupIndirectCommandNV, groupIndex));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkBindShaderGroupIndirectCommandNV_sizeof"] = Napi::Number::New(env, sizeof(VkBindShaderGroupIndirectCommandNV));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkBindIndexBufferIndirectCommandNV_bufferAddress_offsetof"] = Napi::Number::New(env, offsetof(VkBindIndexBufferIndirectCommandNV, bufferAddress));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkBindIndexBufferIndirectCommandNV_size_offsetof"] = Napi::Number::New(env, offsetof(VkBindIndexBufferIndirectCommandNV, size));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkBindIndexBufferIndirectCommandNV_indexType_offsetof"] = Napi::Number::New(env, offsetof(VkBindIndexBufferIndirectCommandNV, indexType));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkBindIndexBufferIndirectCommandNV_sizeof"] = Napi::Number::New(env, sizeof(VkBindIndexBufferIndirectCommandNV));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkBindVertexBufferIndirectCommandNV_bufferAddress_offsetof"] = Napi::Number::New(env, offsetof(VkBindVertexBufferIndirectCommandNV, bufferAddress));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkBindVertexBufferIndirectCommandNV_size_offsetof"] = Napi::Number::New(env, offsetof(VkBindVertexBufferIndirectCommandNV, size));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkBindVertexBufferIndirectCommandNV_stride_offsetof"] = Napi::Number::New(env, offsetof(VkBindVertexBufferIndirectCommandNV, stride));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkBindVertexBufferIndirectCommandNV_sizeof"] = Napi::Number::New(env, sizeof(VkBindVertexBufferIndirectCommandNV));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkSetStateFlagsIndirectCommandNV_data_offsetof"] = Napi::Number::New(env, offsetof(VkSetStateFlagsIndirectCommandNV, data));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkSetStateFlagsIndirectCommandNV_sizeof"] = Napi::Number::New(env, sizeof(VkSetStateFlagsIndirectCommandNV));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsStreamNV_buffer_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsStreamNV, buffer));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsStreamNV_offset_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsStreamNV, offset));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsStreamNV_sizeof"] = Napi::Number::New(env, sizeof(VkIndirectCommandsStreamNV));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutTokenNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutTokenNV, sType));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutTokenNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutTokenNV, pNext));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutTokenNV_tokenType_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutTokenNV, tokenType));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutTokenNV_stream_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutTokenNV, stream));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutTokenNV_offset_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutTokenNV, offset));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutTokenNV_vertexBindingUnit_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutTokenNV, vertexBindingUnit));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutTokenNV_vertexDynamicStride_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutTokenNV, vertexDynamicStride));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutTokenNV_pushconstantPipelineLayout_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutTokenNV, pushconstantPipelineLayout));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutTokenNV_pushconstantShaderStageFlags_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutTokenNV, pushconstantShaderStageFlags));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutTokenNV_pushconstantOffset_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutTokenNV, pushconstantOffset));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutTokenNV_pushconstantSize_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutTokenNV, pushconstantSize));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutTokenNV_indirectStateFlags_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutTokenNV, indirectStateFlags));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutTokenNV_indexTypeCount_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutTokenNV, indexTypeCount));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutTokenNV_pIndexTypes_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutTokenNV, pIndexTypes));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutTokenNV_pIndexTypeValues_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutTokenNV, pIndexTypeValues));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutTokenNV_sizeof"] = Napi::Number::New(env, sizeof(VkIndirectCommandsLayoutTokenNV));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutCreateInfoNV, sType));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutCreateInfoNV, pNext));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutCreateInfoNV_flags_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutCreateInfoNV, flags));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutCreateInfoNV_pipelineBindPoint_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutCreateInfoNV, pipelineBindPoint));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutCreateInfoNV_tokenCount_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutCreateInfoNV, tokenCount));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutCreateInfoNV_pTokens_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutCreateInfoNV, pTokens));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutCreateInfoNV_streamCount_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutCreateInfoNV, streamCount));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutCreateInfoNV_pStreamStrides_offsetof"] = Napi::Number::New(env, offsetof(VkIndirectCommandsLayoutCreateInfoNV, pStreamStrides));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkIndirectCommandsLayoutCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkIndirectCommandsLayoutCreateInfoNV));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsInfoNV, sType));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsInfoNV, pNext));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsInfoNV_pipelineBindPoint_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsInfoNV, pipelineBindPoint));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsInfoNV_pipeline_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsInfoNV, pipeline));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsInfoNV_indirectCommandsLayout_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsInfoNV, indirectCommandsLayout));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsInfoNV_streamCount_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsInfoNV, streamCount));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsInfoNV_pStreams_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsInfoNV, pStreams));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsInfoNV_sequencesCount_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsInfoNV, sequencesCount));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsInfoNV_preprocessBuffer_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsInfoNV, preprocessBuffer));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsInfoNV_preprocessOffset_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsInfoNV, preprocessOffset));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsInfoNV_preprocessSize_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsInfoNV, preprocessSize));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsInfoNV_sequencesCountBuffer_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsInfoNV, sequencesCountBuffer));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsInfoNV_sequencesCountOffset_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsInfoNV, sequencesCountOffset));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsInfoNV_sequencesIndexBuffer_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsInfoNV, sequencesIndexBuffer));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsInfoNV_sequencesIndexOffset_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsInfoNV, sequencesIndexOffset));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkGeneratedCommandsInfoNV));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsMemoryRequirementsInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsMemoryRequirementsInfoNV, sType));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsMemoryRequirementsInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsMemoryRequirementsInfoNV, pNext));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsMemoryRequirementsInfoNV_pipelineBindPoint_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsMemoryRequirementsInfoNV, pipelineBindPoint));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsMemoryRequirementsInfoNV_pipeline_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsMemoryRequirementsInfoNV, pipeline));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsMemoryRequirementsInfoNV_indirectCommandsLayout_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsMemoryRequirementsInfoNV, indirectCommandsLayout));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsMemoryRequirementsInfoNV_maxSequencesCount_offsetof"] = Napi::Number::New(env, offsetof(VkGeneratedCommandsMemoryRequirementsInfoNV, maxSequencesCount));
#endif
#ifdef VK_NV_device_generated_commands
    exports["VkGeneratedCommandsMemoryRequirementsInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkGeneratedCommandsMemoryRequirementsInfoNV));
#endif
    exports["VkPhysicalDeviceFeatures2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures2, sType));
    exports["VkPhysicalDeviceFeatures2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures2, pNext));
    exports["VkPhysicalDeviceFeatures2_features_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFeatures2, features));
    exports["VkPhysicalDeviceFeatures2_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFeatures2));
#ifdef VK_KHR_get_physical_device_properties2
    exports["VkPhysicalDeviceFeatures2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFeatures2KHR));
#endif
    exports["VkPhysicalDeviceProperties2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProperties2, sType));
    exports["VkPhysicalDeviceProperties2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProperties2, pNext));
    exports["VkPhysicalDeviceProperties2_properties_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProperties2, properties));
    exports["VkPhysicalDeviceProperties2_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceProperties2));
#ifdef VK_KHR_get_physical_device_properties2
    exports["VkPhysicalDeviceProperties2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceProperties2KHR));
#endif
    exports["VkFormatProperties2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkFormatProperties2, sType));
    exports["VkFormatProperties2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkFormatProperties2, pNext));
    exports["VkFormatProperties2_formatProperties_offsetof"] = Napi::Number::New(env, offsetof(VkFormatProperties2, formatProperties));
    exports["VkFormatProperties2_sizeof"] = Napi::Number::New(env, sizeof(VkFormatProperties2));
#ifdef VK_KHR_get_physical_device_properties2
    exports["VkFormatProperties2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkFormatProperties2KHR));
#endif
    exports["VkImageFormatProperties2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatProperties2, sType));
    exports["VkImageFormatProperties2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatProperties2, pNext));
    exports["VkImageFormatProperties2_imageFormatProperties_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatProperties2, imageFormatProperties));
    exports["VkImageFormatProperties2_sizeof"] = Napi::Number::New(env, sizeof(VkImageFormatProperties2));
#ifdef VK_KHR_get_physical_device_properties2
    exports["VkImageFormatProperties2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkImageFormatProperties2KHR));
#endif
    exports["VkPhysicalDeviceImageFormatInfo2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageFormatInfo2, sType));
    exports["VkPhysicalDeviceImageFormatInfo2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageFormatInfo2, pNext));
    exports["VkPhysicalDeviceImageFormatInfo2_format_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageFormatInfo2, format));
    exports["VkPhysicalDeviceImageFormatInfo2_type_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageFormatInfo2, type));
    exports["VkPhysicalDeviceImageFormatInfo2_tiling_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageFormatInfo2, tiling));
    exports["VkPhysicalDeviceImageFormatInfo2_usage_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageFormatInfo2, usage));
    exports["VkPhysicalDeviceImageFormatInfo2_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageFormatInfo2, flags));
    exports["VkPhysicalDeviceImageFormatInfo2_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceImageFormatInfo2));
#ifdef VK_KHR_get_physical_device_properties2
    exports["VkPhysicalDeviceImageFormatInfo2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceImageFormatInfo2KHR));
#endif
    exports["VkQueueFamilyProperties2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyProperties2, sType));
    exports["VkQueueFamilyProperties2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyProperties2, pNext));
    exports["VkQueueFamilyProperties2_queueFamilyProperties_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyProperties2, queueFamilyProperties));
    exports["VkQueueFamilyProperties2_sizeof"] = Napi::Number::New(env, sizeof(VkQueueFamilyProperties2));
#ifdef VK_KHR_get_physical_device_properties2
    exports["VkQueueFamilyProperties2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkQueueFamilyProperties2KHR));
#endif
    exports["VkPhysicalDeviceMemoryProperties2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryProperties2, sType));
    exports["VkPhysicalDeviceMemoryProperties2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryProperties2, pNext));
    exports["VkPhysicalDeviceMemoryProperties2_memoryProperties_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryProperties2, memoryProperties));
    exports["VkPhysicalDeviceMemoryProperties2_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMemoryProperties2));
#ifdef VK_KHR_get_physical_device_properties2
    exports["VkPhysicalDeviceMemoryProperties2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMemoryProperties2KHR));
#endif
    exports["VkSparseImageFormatProperties2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageFormatProperties2, sType));
    exports["VkSparseImageFormatProperties2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageFormatProperties2, pNext));
    exports["VkSparseImageFormatProperties2_properties_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageFormatProperties2, properties));
    exports["VkSparseImageFormatProperties2_sizeof"] = Napi::Number::New(env, sizeof(VkSparseImageFormatProperties2));
#ifdef VK_KHR_get_physical_device_properties2
    exports["VkSparseImageFormatProperties2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkSparseImageFormatProperties2KHR));
#endif
    exports["VkPhysicalDeviceSparseImageFormatInfo2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSparseImageFormatInfo2, sType));
    exports["VkPhysicalDeviceSparseImageFormatInfo2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSparseImageFormatInfo2, pNext));
    exports["VkPhysicalDeviceSparseImageFormatInfo2_format_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSparseImageFormatInfo2, format));
    exports["VkPhysicalDeviceSparseImageFormatInfo2_type_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSparseImageFormatInfo2, type));
    exports["VkPhysicalDeviceSparseImageFormatInfo2_samples_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSparseImageFormatInfo2, samples));
    exports["VkPhysicalDeviceSparseImageFormatInfo2_usage_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSparseImageFormatInfo2, usage));
    exports["VkPhysicalDeviceSparseImageFormatInfo2_tiling_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSparseImageFormatInfo2, tiling));
    exports["VkPhysicalDeviceSparseImageFormatInfo2_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSparseImageFormatInfo2));
#ifdef VK_KHR_get_physical_device_properties2
    exports["VkPhysicalDeviceSparseImageFormatInfo2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSparseImageFormatInfo2KHR));
#endif
#ifdef VK_KHR_push_descriptor
    exports["VkPhysicalDevicePushDescriptorPropertiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePushDescriptorPropertiesKHR, sType));
#endif
#ifdef VK_KHR_push_descriptor
    exports["VkPhysicalDevicePushDescriptorPropertiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePushDescriptorPropertiesKHR, pNext));
#endif
#ifdef VK_KHR_push_descriptor
    exports["VkPhysicalDevicePushDescriptorPropertiesKHR_maxPushDescriptors_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePushDescriptorPropertiesKHR, maxPushDescriptors));
#endif
#ifdef VK_KHR_push_descriptor
    exports["VkPhysicalDevicePushDescriptorPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePushDescriptorPropertiesKHR));
#endif
    exports["VkConformanceVersion_major_offsetof"] = Napi::Number::New(env, offsetof(VkConformanceVersion, major));
    exports["VkConformanceVersion_minor_offsetof"] = Napi::Number::New(env, offsetof(VkConformanceVersion, minor));
    exports["VkConformanceVersion_subminor_offsetof"] = Napi::Number::New(env, offsetof(VkConformanceVersion, subminor));
    exports["VkConformanceVersion_patch_offsetof"] = Napi::Number::New(env, offsetof(VkConformanceVersion, patch));
    exports["VkConformanceVersion_sizeof"] = Napi::Number::New(env, sizeof(VkConformanceVersion));
#ifdef VK_KHR_driver_properties
    exports["VkConformanceVersionKHR_sizeof"] = Napi::Number::New(env, sizeof(VkConformanceVersionKHR));
#endif
    exports["VkPhysicalDeviceDriverProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDriverProperties, sType));
    exports["VkPhysicalDeviceDriverProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDriverProperties, pNext));
    exports["VkPhysicalDeviceDriverProperties_driverID_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDriverProperties, driverID));
    exports["VkPhysicalDeviceDriverProperties_driverName_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDriverProperties, driverName));
    exports["VkPhysicalDeviceDriverProperties_driverInfo_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDriverProperties, driverInfo));
    exports["VkPhysicalDeviceDriverProperties_conformanceVersion_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDriverProperties, conformanceVersion));
    exports["VkPhysicalDeviceDriverProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDriverProperties));
#ifdef VK_KHR_driver_properties
    exports["VkPhysicalDeviceDriverPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDriverPropertiesKHR));
#endif
#ifdef VK_KHR_incremental_present
    exports["VkPresentRegionsKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPresentRegionsKHR, sType));
#endif
#ifdef VK_KHR_incremental_present
    exports["VkPresentRegionsKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPresentRegionsKHR, pNext));
#endif
#ifdef VK_KHR_incremental_present
    exports["VkPresentRegionsKHR_swapchainCount_offsetof"] = Napi::Number::New(env, offsetof(VkPresentRegionsKHR, swapchainCount));
#endif
#ifdef VK_KHR_incremental_present
    exports["VkPresentRegionsKHR_pRegions_offsetof"] = Napi::Number::New(env, offsetof(VkPresentRegionsKHR, pRegions));
#endif
#ifdef VK_KHR_incremental_present
    exports["VkPresentRegionsKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPresentRegionsKHR));
#endif
#ifdef VK_KHR_incremental_present
    exports["VkPresentRegionKHR_rectangleCount_offsetof"] = Napi::Number::New(env, offsetof(VkPresentRegionKHR, rectangleCount));
#endif
#ifdef VK_KHR_incremental_present
    exports["VkPresentRegionKHR_pRectangles_offsetof"] = Napi::Number::New(env, offsetof(VkPresentRegionKHR, pRectangles));
#endif
#ifdef VK_KHR_incremental_present
    exports["VkPresentRegionKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPresentRegionKHR));
#endif
#ifdef VK_KHR_incremental_present
    exports["VkRectLayerKHR_offset_offsetof"] = Napi::Number::New(env, offsetof(VkRectLayerKHR, offset));
#endif
#ifdef VK_KHR_incremental_present
    exports["VkRectLayerKHR_extent_offsetof"] = Napi::Number::New(env, offsetof(VkRectLayerKHR, extent));
#endif
#ifdef VK_KHR_incremental_present
    exports["VkRectLayerKHR_layer_offsetof"] = Napi::Number::New(env, offsetof(VkRectLayerKHR, layer));
#endif
#ifdef VK_KHR_incremental_present
    exports["VkRectLayerKHR_sizeof"] = Napi::Number::New(env, sizeof(VkRectLayerKHR));
#endif
    exports["VkPhysicalDeviceVariablePointersFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVariablePointersFeatures, sType));
    exports["VkPhysicalDeviceVariablePointersFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVariablePointersFeatures, pNext));
    exports["VkPhysicalDeviceVariablePointersFeatures_variablePointersStorageBuffer_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVariablePointersFeatures, variablePointersStorageBuffer));
    exports["VkPhysicalDeviceVariablePointersFeatures_variablePointers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVariablePointersFeatures, variablePointers));
    exports["VkPhysicalDeviceVariablePointersFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceVariablePointersFeatures));
#ifdef VK_KHR_variable_pointers
    exports["VkPhysicalDeviceVariablePointersFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceVariablePointersFeaturesKHR));
#endif
#ifdef VK_KHR_variable_pointers
    exports["VkPhysicalDeviceVariablePointerFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceVariablePointerFeaturesKHR));
#endif
    exports["VkPhysicalDeviceVariablePointerFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceVariablePointerFeatures));
    exports["VkExternalMemoryProperties_externalMemoryFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkExternalMemoryProperties, externalMemoryFeatures));
    exports["VkExternalMemoryProperties_exportFromImportedHandleTypes_offsetof"] = Napi::Number::New(env, offsetof(VkExternalMemoryProperties, exportFromImportedHandleTypes));
    exports["VkExternalMemoryProperties_compatibleHandleTypes_offsetof"] = Napi::Number::New(env, offsetof(VkExternalMemoryProperties, compatibleHandleTypes));
    exports["VkExternalMemoryProperties_sizeof"] = Napi::Number::New(env, sizeof(VkExternalMemoryProperties));
#ifdef VK_KHR_external_memory_capabilities
    exports["VkExternalMemoryPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkExternalMemoryPropertiesKHR));
#endif
    exports["VkPhysicalDeviceExternalImageFormatInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalImageFormatInfo, sType));
    exports["VkPhysicalDeviceExternalImageFormatInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalImageFormatInfo, pNext));
    exports["VkPhysicalDeviceExternalImageFormatInfo_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalImageFormatInfo, handleType));
    exports["VkPhysicalDeviceExternalImageFormatInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceExternalImageFormatInfo));
#ifdef VK_KHR_external_memory_capabilities
    exports["VkPhysicalDeviceExternalImageFormatInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceExternalImageFormatInfoKHR));
#endif
    exports["VkExternalImageFormatProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExternalImageFormatProperties, sType));
    exports["VkExternalImageFormatProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExternalImageFormatProperties, pNext));
    exports["VkExternalImageFormatProperties_externalMemoryProperties_offsetof"] = Napi::Number::New(env, offsetof(VkExternalImageFormatProperties, externalMemoryProperties));
    exports["VkExternalImageFormatProperties_sizeof"] = Napi::Number::New(env, sizeof(VkExternalImageFormatProperties));
#ifdef VK_KHR_external_memory_capabilities
    exports["VkExternalImageFormatPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkExternalImageFormatPropertiesKHR));
#endif
    exports["VkPhysicalDeviceExternalBufferInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalBufferInfo, sType));
    exports["VkPhysicalDeviceExternalBufferInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalBufferInfo, pNext));
    exports["VkPhysicalDeviceExternalBufferInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalBufferInfo, flags));
    exports["VkPhysicalDeviceExternalBufferInfo_usage_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalBufferInfo, usage));
    exports["VkPhysicalDeviceExternalBufferInfo_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalBufferInfo, handleType));
    exports["VkPhysicalDeviceExternalBufferInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceExternalBufferInfo));
#ifdef VK_KHR_external_memory_capabilities
    exports["VkPhysicalDeviceExternalBufferInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceExternalBufferInfoKHR));
#endif
    exports["VkExternalBufferProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExternalBufferProperties, sType));
    exports["VkExternalBufferProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExternalBufferProperties, pNext));
    exports["VkExternalBufferProperties_externalMemoryProperties_offsetof"] = Napi::Number::New(env, offsetof(VkExternalBufferProperties, externalMemoryProperties));
    exports["VkExternalBufferProperties_sizeof"] = Napi::Number::New(env, sizeof(VkExternalBufferProperties));
#ifdef VK_KHR_external_memory_capabilities
    exports["VkExternalBufferPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkExternalBufferPropertiesKHR));
#endif
    exports["VkPhysicalDeviceIDProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceIDProperties, sType));
    exports["VkPhysicalDeviceIDProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceIDProperties, pNext));
    exports["VkPhysicalDeviceIDProperties_deviceUUID_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceIDProperties, deviceUUID));
    exports["VkPhysicalDeviceIDProperties_driverUUID_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceIDProperties, driverUUID));
    exports["VkPhysicalDeviceIDProperties_deviceLUID_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceIDProperties, deviceLUID));
    exports["VkPhysicalDeviceIDProperties_deviceNodeMask_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceIDProperties, deviceNodeMask));
    exports["VkPhysicalDeviceIDProperties_deviceLUIDValid_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceIDProperties, deviceLUIDValid));
    exports["VkPhysicalDeviceIDProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceIDProperties));
#ifdef VK_KHR_external_fence_capabilities
    exports["VkPhysicalDeviceIDPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceIDPropertiesKHR));
#endif
    exports["VkExternalMemoryImageCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExternalMemoryImageCreateInfo, sType));
    exports["VkExternalMemoryImageCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExternalMemoryImageCreateInfo, pNext));
    exports["VkExternalMemoryImageCreateInfo_handleTypes_offsetof"] = Napi::Number::New(env, offsetof(VkExternalMemoryImageCreateInfo, handleTypes));
    exports["VkExternalMemoryImageCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkExternalMemoryImageCreateInfo));
#ifdef VK_KHR_external_memory
    exports["VkExternalMemoryImageCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkExternalMemoryImageCreateInfoKHR));
#endif
    exports["VkExternalMemoryBufferCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExternalMemoryBufferCreateInfo, sType));
    exports["VkExternalMemoryBufferCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExternalMemoryBufferCreateInfo, pNext));
    exports["VkExternalMemoryBufferCreateInfo_handleTypes_offsetof"] = Napi::Number::New(env, offsetof(VkExternalMemoryBufferCreateInfo, handleTypes));
    exports["VkExternalMemoryBufferCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkExternalMemoryBufferCreateInfo));
#ifdef VK_KHR_external_memory
    exports["VkExternalMemoryBufferCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkExternalMemoryBufferCreateInfoKHR));
#endif
    exports["VkExportMemoryAllocateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExportMemoryAllocateInfo, sType));
    exports["VkExportMemoryAllocateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExportMemoryAllocateInfo, pNext));
    exports["VkExportMemoryAllocateInfo_handleTypes_offsetof"] = Napi::Number::New(env, offsetof(VkExportMemoryAllocateInfo, handleTypes));
    exports["VkExportMemoryAllocateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkExportMemoryAllocateInfo));
#ifdef VK_KHR_external_memory
    exports["VkExportMemoryAllocateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkExportMemoryAllocateInfoKHR));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkImportMemoryWin32HandleInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryWin32HandleInfoKHR, sType));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkImportMemoryWin32HandleInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryWin32HandleInfoKHR, pNext));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkImportMemoryWin32HandleInfoKHR_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryWin32HandleInfoKHR, handleType));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkImportMemoryWin32HandleInfoKHR_handle_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryWin32HandleInfoKHR, handle));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkImportMemoryWin32HandleInfoKHR_name_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryWin32HandleInfoKHR, name));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkImportMemoryWin32HandleInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkImportMemoryWin32HandleInfoKHR));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkExportMemoryWin32HandleInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExportMemoryWin32HandleInfoKHR, sType));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkExportMemoryWin32HandleInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExportMemoryWin32HandleInfoKHR, pNext));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkExportMemoryWin32HandleInfoKHR_pAttributes_offsetof"] = Napi::Number::New(env, offsetof(VkExportMemoryWin32HandleInfoKHR, pAttributes));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkExportMemoryWin32HandleInfoKHR_dwAccess_offsetof"] = Napi::Number::New(env, offsetof(VkExportMemoryWin32HandleInfoKHR, dwAccess));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkExportMemoryWin32HandleInfoKHR_name_offsetof"] = Napi::Number::New(env, offsetof(VkExportMemoryWin32HandleInfoKHR, name));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkExportMemoryWin32HandleInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkExportMemoryWin32HandleInfoKHR));
#endif
#ifdef VK_FUCHSIA_external_memory
    exports["VkImportMemoryZirconHandleInfoFUCHSIA_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryZirconHandleInfoFUCHSIA, sType));
#endif
#ifdef VK_FUCHSIA_external_memory
    exports["VkImportMemoryZirconHandleInfoFUCHSIA_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryZirconHandleInfoFUCHSIA, pNext));
#endif
#ifdef VK_FUCHSIA_external_memory
    exports["VkImportMemoryZirconHandleInfoFUCHSIA_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryZirconHandleInfoFUCHSIA, handleType));
#endif
#ifdef VK_FUCHSIA_external_memory
    exports["VkImportMemoryZirconHandleInfoFUCHSIA_handle_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryZirconHandleInfoFUCHSIA, handle));
#endif
#ifdef VK_FUCHSIA_external_memory
    exports["VkImportMemoryZirconHandleInfoFUCHSIA_sizeof"] = Napi::Number::New(env, sizeof(VkImportMemoryZirconHandleInfoFUCHSIA));
#endif
#ifdef VK_FUCHSIA_external_memory
    exports["VkMemoryZirconHandlePropertiesFUCHSIA_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryZirconHandlePropertiesFUCHSIA, sType));
#endif
#ifdef VK_FUCHSIA_external_memory
    exports["VkMemoryZirconHandlePropertiesFUCHSIA_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryZirconHandlePropertiesFUCHSIA, pNext));
#endif
#ifdef VK_FUCHSIA_external_memory
    exports["VkMemoryZirconHandlePropertiesFUCHSIA_memoryTypeBits_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryZirconHandlePropertiesFUCHSIA, memoryTypeBits));
#endif
#ifdef VK_FUCHSIA_external_memory
    exports["VkMemoryZirconHandlePropertiesFUCHSIA_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryZirconHandlePropertiesFUCHSIA));
#endif
#ifdef VK_FUCHSIA_external_memory
    exports["VkMemoryGetZirconHandleInfoFUCHSIA_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetZirconHandleInfoFUCHSIA, sType));
#endif
#ifdef VK_FUCHSIA_external_memory
    exports["VkMemoryGetZirconHandleInfoFUCHSIA_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetZirconHandleInfoFUCHSIA, pNext));
#endif
#ifdef VK_FUCHSIA_external_memory
    exports["VkMemoryGetZirconHandleInfoFUCHSIA_memory_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetZirconHandleInfoFUCHSIA, memory));
#endif
#ifdef VK_FUCHSIA_external_memory
    exports["VkMemoryGetZirconHandleInfoFUCHSIA_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetZirconHandleInfoFUCHSIA, handleType));
#endif
#ifdef VK_FUCHSIA_external_memory
    exports["VkMemoryGetZirconHandleInfoFUCHSIA_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryGetZirconHandleInfoFUCHSIA));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkMemoryWin32HandlePropertiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryWin32HandlePropertiesKHR, sType));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkMemoryWin32HandlePropertiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryWin32HandlePropertiesKHR, pNext));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkMemoryWin32HandlePropertiesKHR_memoryTypeBits_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryWin32HandlePropertiesKHR, memoryTypeBits));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkMemoryWin32HandlePropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryWin32HandlePropertiesKHR));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkMemoryGetWin32HandleInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetWin32HandleInfoKHR, sType));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkMemoryGetWin32HandleInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetWin32HandleInfoKHR, pNext));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkMemoryGetWin32HandleInfoKHR_memory_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetWin32HandleInfoKHR, memory));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkMemoryGetWin32HandleInfoKHR_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetWin32HandleInfoKHR, handleType));
#endif
#ifdef VK_KHR_external_memory_win32
    exports["VkMemoryGetWin32HandleInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryGetWin32HandleInfoKHR));
#endif
#ifdef VK_KHR_external_memory_fd
    exports["VkImportMemoryFdInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryFdInfoKHR, sType));
#endif
#ifdef VK_KHR_external_memory_fd
    exports["VkImportMemoryFdInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryFdInfoKHR, pNext));
#endif
#ifdef VK_KHR_external_memory_fd
    exports["VkImportMemoryFdInfoKHR_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryFdInfoKHR, handleType));
#endif
#ifdef VK_KHR_external_memory_fd
    exports["VkImportMemoryFdInfoKHR_fd_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryFdInfoKHR, fd));
#endif
#ifdef VK_KHR_external_memory_fd
    exports["VkImportMemoryFdInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkImportMemoryFdInfoKHR));
#endif
#ifdef VK_KHR_external_memory_fd
    exports["VkMemoryFdPropertiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryFdPropertiesKHR, sType));
#endif
#ifdef VK_KHR_external_memory_fd
    exports["VkMemoryFdPropertiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryFdPropertiesKHR, pNext));
#endif
#ifdef VK_KHR_external_memory_fd
    exports["VkMemoryFdPropertiesKHR_memoryTypeBits_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryFdPropertiesKHR, memoryTypeBits));
#endif
#ifdef VK_KHR_external_memory_fd
    exports["VkMemoryFdPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryFdPropertiesKHR));
#endif
#ifdef VK_KHR_external_memory_fd
    exports["VkMemoryGetFdInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetFdInfoKHR, sType));
#endif
#ifdef VK_KHR_external_memory_fd
    exports["VkMemoryGetFdInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetFdInfoKHR, pNext));
#endif
#ifdef VK_KHR_external_memory_fd
    exports["VkMemoryGetFdInfoKHR_memory_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetFdInfoKHR, memory));
#endif
#ifdef VK_KHR_external_memory_fd
    exports["VkMemoryGetFdInfoKHR_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetFdInfoKHR, handleType));
#endif
#ifdef VK_KHR_external_memory_fd
    exports["VkMemoryGetFdInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryGetFdInfoKHR));
#endif
#ifdef VK_KHR_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoKHR, sType));
#endif
#ifdef VK_KHR_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoKHR, pNext));
#endif
#ifdef VK_KHR_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoKHR_acquireCount_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoKHR, acquireCount));
#endif
#ifdef VK_KHR_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoKHR_pAcquireSyncs_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoKHR, pAcquireSyncs));
#endif
#ifdef VK_KHR_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoKHR_pAcquireKeys_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoKHR, pAcquireKeys));
#endif
#ifdef VK_KHR_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoKHR_pAcquireTimeouts_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoKHR, pAcquireTimeouts));
#endif
#ifdef VK_KHR_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoKHR_releaseCount_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoKHR, releaseCount));
#endif
#ifdef VK_KHR_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoKHR_pReleaseSyncs_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoKHR, pReleaseSyncs));
#endif
#ifdef VK_KHR_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoKHR_pReleaseKeys_offsetof"] = Napi::Number::New(env, offsetof(VkWin32KeyedMutexAcquireReleaseInfoKHR, pReleaseKeys));
#endif
#ifdef VK_KHR_win32_keyed_mutex
    exports["VkWin32KeyedMutexAcquireReleaseInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkWin32KeyedMutexAcquireReleaseInfoKHR));
#endif
    exports["VkPhysicalDeviceExternalSemaphoreInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalSemaphoreInfo, sType));
    exports["VkPhysicalDeviceExternalSemaphoreInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalSemaphoreInfo, pNext));
    exports["VkPhysicalDeviceExternalSemaphoreInfo_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalSemaphoreInfo, handleType));
    exports["VkPhysicalDeviceExternalSemaphoreInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceExternalSemaphoreInfo));
#ifdef VK_KHR_external_semaphore_capabilities
    exports["VkPhysicalDeviceExternalSemaphoreInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceExternalSemaphoreInfoKHR));
#endif
    exports["VkExternalSemaphoreProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExternalSemaphoreProperties, sType));
    exports["VkExternalSemaphoreProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExternalSemaphoreProperties, pNext));
    exports["VkExternalSemaphoreProperties_exportFromImportedHandleTypes_offsetof"] = Napi::Number::New(env, offsetof(VkExternalSemaphoreProperties, exportFromImportedHandleTypes));
    exports["VkExternalSemaphoreProperties_compatibleHandleTypes_offsetof"] = Napi::Number::New(env, offsetof(VkExternalSemaphoreProperties, compatibleHandleTypes));
    exports["VkExternalSemaphoreProperties_externalSemaphoreFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkExternalSemaphoreProperties, externalSemaphoreFeatures));
    exports["VkExternalSemaphoreProperties_sizeof"] = Napi::Number::New(env, sizeof(VkExternalSemaphoreProperties));
#ifdef VK_KHR_external_semaphore_capabilities
    exports["VkExternalSemaphorePropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkExternalSemaphorePropertiesKHR));
#endif
    exports["VkExportSemaphoreCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExportSemaphoreCreateInfo, sType));
    exports["VkExportSemaphoreCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExportSemaphoreCreateInfo, pNext));
    exports["VkExportSemaphoreCreateInfo_handleTypes_offsetof"] = Napi::Number::New(env, offsetof(VkExportSemaphoreCreateInfo, handleTypes));
    exports["VkExportSemaphoreCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkExportSemaphoreCreateInfo));
#ifdef VK_KHR_external_semaphore
    exports["VkExportSemaphoreCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkExportSemaphoreCreateInfoKHR));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkImportSemaphoreWin32HandleInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreWin32HandleInfoKHR, sType));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkImportSemaphoreWin32HandleInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreWin32HandleInfoKHR, pNext));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkImportSemaphoreWin32HandleInfoKHR_semaphore_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreWin32HandleInfoKHR, semaphore));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkImportSemaphoreWin32HandleInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreWin32HandleInfoKHR, flags));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkImportSemaphoreWin32HandleInfoKHR_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreWin32HandleInfoKHR, handleType));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkImportSemaphoreWin32HandleInfoKHR_handle_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreWin32HandleInfoKHR, handle));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkImportSemaphoreWin32HandleInfoKHR_name_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreWin32HandleInfoKHR, name));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkImportSemaphoreWin32HandleInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkImportSemaphoreWin32HandleInfoKHR));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkExportSemaphoreWin32HandleInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExportSemaphoreWin32HandleInfoKHR, sType));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkExportSemaphoreWin32HandleInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExportSemaphoreWin32HandleInfoKHR, pNext));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkExportSemaphoreWin32HandleInfoKHR_pAttributes_offsetof"] = Napi::Number::New(env, offsetof(VkExportSemaphoreWin32HandleInfoKHR, pAttributes));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkExportSemaphoreWin32HandleInfoKHR_dwAccess_offsetof"] = Napi::Number::New(env, offsetof(VkExportSemaphoreWin32HandleInfoKHR, dwAccess));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkExportSemaphoreWin32HandleInfoKHR_name_offsetof"] = Napi::Number::New(env, offsetof(VkExportSemaphoreWin32HandleInfoKHR, name));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkExportSemaphoreWin32HandleInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkExportSemaphoreWin32HandleInfoKHR));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkD3D12FenceSubmitInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkD3D12FenceSubmitInfoKHR, sType));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkD3D12FenceSubmitInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkD3D12FenceSubmitInfoKHR, pNext));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkD3D12FenceSubmitInfoKHR_waitSemaphoreValuesCount_offsetof"] = Napi::Number::New(env, offsetof(VkD3D12FenceSubmitInfoKHR, waitSemaphoreValuesCount));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkD3D12FenceSubmitInfoKHR_pWaitSemaphoreValues_offsetof"] = Napi::Number::New(env, offsetof(VkD3D12FenceSubmitInfoKHR, pWaitSemaphoreValues));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkD3D12FenceSubmitInfoKHR_signalSemaphoreValuesCount_offsetof"] = Napi::Number::New(env, offsetof(VkD3D12FenceSubmitInfoKHR, signalSemaphoreValuesCount));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkD3D12FenceSubmitInfoKHR_pSignalSemaphoreValues_offsetof"] = Napi::Number::New(env, offsetof(VkD3D12FenceSubmitInfoKHR, pSignalSemaphoreValues));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkD3D12FenceSubmitInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkD3D12FenceSubmitInfoKHR));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkSemaphoreGetWin32HandleInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreGetWin32HandleInfoKHR, sType));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkSemaphoreGetWin32HandleInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreGetWin32HandleInfoKHR, pNext));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkSemaphoreGetWin32HandleInfoKHR_semaphore_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreGetWin32HandleInfoKHR, semaphore));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkSemaphoreGetWin32HandleInfoKHR_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreGetWin32HandleInfoKHR, handleType));
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["VkSemaphoreGetWin32HandleInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkSemaphoreGetWin32HandleInfoKHR));
#endif
#ifdef VK_KHR_external_semaphore_fd
    exports["VkImportSemaphoreFdInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreFdInfoKHR, sType));
#endif
#ifdef VK_KHR_external_semaphore_fd
    exports["VkImportSemaphoreFdInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreFdInfoKHR, pNext));
#endif
#ifdef VK_KHR_external_semaphore_fd
    exports["VkImportSemaphoreFdInfoKHR_semaphore_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreFdInfoKHR, semaphore));
#endif
#ifdef VK_KHR_external_semaphore_fd
    exports["VkImportSemaphoreFdInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreFdInfoKHR, flags));
#endif
#ifdef VK_KHR_external_semaphore_fd
    exports["VkImportSemaphoreFdInfoKHR_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreFdInfoKHR, handleType));
#endif
#ifdef VK_KHR_external_semaphore_fd
    exports["VkImportSemaphoreFdInfoKHR_fd_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreFdInfoKHR, fd));
#endif
#ifdef VK_KHR_external_semaphore_fd
    exports["VkImportSemaphoreFdInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkImportSemaphoreFdInfoKHR));
#endif
#ifdef VK_KHR_external_semaphore_fd
    exports["VkSemaphoreGetFdInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreGetFdInfoKHR, sType));
#endif
#ifdef VK_KHR_external_semaphore_fd
    exports["VkSemaphoreGetFdInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreGetFdInfoKHR, pNext));
#endif
#ifdef VK_KHR_external_semaphore_fd
    exports["VkSemaphoreGetFdInfoKHR_semaphore_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreGetFdInfoKHR, semaphore));
#endif
#ifdef VK_KHR_external_semaphore_fd
    exports["VkSemaphoreGetFdInfoKHR_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreGetFdInfoKHR, handleType));
#endif
#ifdef VK_KHR_external_semaphore_fd
    exports["VkSemaphoreGetFdInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkSemaphoreGetFdInfoKHR));
#endif
#ifdef VK_FUCHSIA_external_semaphore
    exports["VkImportSemaphoreZirconHandleInfoFUCHSIA_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreZirconHandleInfoFUCHSIA, sType));
#endif
#ifdef VK_FUCHSIA_external_semaphore
    exports["VkImportSemaphoreZirconHandleInfoFUCHSIA_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreZirconHandleInfoFUCHSIA, pNext));
#endif
#ifdef VK_FUCHSIA_external_semaphore
    exports["VkImportSemaphoreZirconHandleInfoFUCHSIA_semaphore_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreZirconHandleInfoFUCHSIA, semaphore));
#endif
#ifdef VK_FUCHSIA_external_semaphore
    exports["VkImportSemaphoreZirconHandleInfoFUCHSIA_flags_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreZirconHandleInfoFUCHSIA, flags));
#endif
#ifdef VK_FUCHSIA_external_semaphore
    exports["VkImportSemaphoreZirconHandleInfoFUCHSIA_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreZirconHandleInfoFUCHSIA, handleType));
#endif
#ifdef VK_FUCHSIA_external_semaphore
    exports["VkImportSemaphoreZirconHandleInfoFUCHSIA_zirconHandle_offsetof"] = Napi::Number::New(env, offsetof(VkImportSemaphoreZirconHandleInfoFUCHSIA, zirconHandle));
#endif
#ifdef VK_FUCHSIA_external_semaphore
    exports["VkImportSemaphoreZirconHandleInfoFUCHSIA_sizeof"] = Napi::Number::New(env, sizeof(VkImportSemaphoreZirconHandleInfoFUCHSIA));
#endif
#ifdef VK_FUCHSIA_external_semaphore
    exports["VkSemaphoreGetZirconHandleInfoFUCHSIA_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreGetZirconHandleInfoFUCHSIA, sType));
#endif
#ifdef VK_FUCHSIA_external_semaphore
    exports["VkSemaphoreGetZirconHandleInfoFUCHSIA_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreGetZirconHandleInfoFUCHSIA, pNext));
#endif
#ifdef VK_FUCHSIA_external_semaphore
    exports["VkSemaphoreGetZirconHandleInfoFUCHSIA_semaphore_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreGetZirconHandleInfoFUCHSIA, semaphore));
#endif
#ifdef VK_FUCHSIA_external_semaphore
    exports["VkSemaphoreGetZirconHandleInfoFUCHSIA_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreGetZirconHandleInfoFUCHSIA, handleType));
#endif
#ifdef VK_FUCHSIA_external_semaphore
    exports["VkSemaphoreGetZirconHandleInfoFUCHSIA_sizeof"] = Napi::Number::New(env, sizeof(VkSemaphoreGetZirconHandleInfoFUCHSIA));
#endif
    exports["VkPhysicalDeviceExternalFenceInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalFenceInfo, sType));
    exports["VkPhysicalDeviceExternalFenceInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalFenceInfo, pNext));
    exports["VkPhysicalDeviceExternalFenceInfo_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalFenceInfo, handleType));
    exports["VkPhysicalDeviceExternalFenceInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceExternalFenceInfo));
#ifdef VK_KHR_external_fence_capabilities
    exports["VkPhysicalDeviceExternalFenceInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceExternalFenceInfoKHR));
#endif
    exports["VkExternalFenceProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExternalFenceProperties, sType));
    exports["VkExternalFenceProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExternalFenceProperties, pNext));
    exports["VkExternalFenceProperties_exportFromImportedHandleTypes_offsetof"] = Napi::Number::New(env, offsetof(VkExternalFenceProperties, exportFromImportedHandleTypes));
    exports["VkExternalFenceProperties_compatibleHandleTypes_offsetof"] = Napi::Number::New(env, offsetof(VkExternalFenceProperties, compatibleHandleTypes));
    exports["VkExternalFenceProperties_externalFenceFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkExternalFenceProperties, externalFenceFeatures));
    exports["VkExternalFenceProperties_sizeof"] = Napi::Number::New(env, sizeof(VkExternalFenceProperties));
#ifdef VK_KHR_external_fence_capabilities
    exports["VkExternalFencePropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkExternalFencePropertiesKHR));
#endif
    exports["VkExportFenceCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExportFenceCreateInfo, sType));
    exports["VkExportFenceCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExportFenceCreateInfo, pNext));
    exports["VkExportFenceCreateInfo_handleTypes_offsetof"] = Napi::Number::New(env, offsetof(VkExportFenceCreateInfo, handleTypes));
    exports["VkExportFenceCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkExportFenceCreateInfo));
#ifdef VK_KHR_external_fence
    exports["VkExportFenceCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkExportFenceCreateInfoKHR));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkImportFenceWin32HandleInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImportFenceWin32HandleInfoKHR, sType));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkImportFenceWin32HandleInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImportFenceWin32HandleInfoKHR, pNext));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkImportFenceWin32HandleInfoKHR_fence_offsetof"] = Napi::Number::New(env, offsetof(VkImportFenceWin32HandleInfoKHR, fence));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkImportFenceWin32HandleInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkImportFenceWin32HandleInfoKHR, flags));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkImportFenceWin32HandleInfoKHR_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkImportFenceWin32HandleInfoKHR, handleType));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkImportFenceWin32HandleInfoKHR_handle_offsetof"] = Napi::Number::New(env, offsetof(VkImportFenceWin32HandleInfoKHR, handle));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkImportFenceWin32HandleInfoKHR_name_offsetof"] = Napi::Number::New(env, offsetof(VkImportFenceWin32HandleInfoKHR, name));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkImportFenceWin32HandleInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkImportFenceWin32HandleInfoKHR));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkExportFenceWin32HandleInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExportFenceWin32HandleInfoKHR, sType));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkExportFenceWin32HandleInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExportFenceWin32HandleInfoKHR, pNext));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkExportFenceWin32HandleInfoKHR_pAttributes_offsetof"] = Napi::Number::New(env, offsetof(VkExportFenceWin32HandleInfoKHR, pAttributes));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkExportFenceWin32HandleInfoKHR_dwAccess_offsetof"] = Napi::Number::New(env, offsetof(VkExportFenceWin32HandleInfoKHR, dwAccess));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkExportFenceWin32HandleInfoKHR_name_offsetof"] = Napi::Number::New(env, offsetof(VkExportFenceWin32HandleInfoKHR, name));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkExportFenceWin32HandleInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkExportFenceWin32HandleInfoKHR));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkFenceGetWin32HandleInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkFenceGetWin32HandleInfoKHR, sType));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkFenceGetWin32HandleInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkFenceGetWin32HandleInfoKHR, pNext));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkFenceGetWin32HandleInfoKHR_fence_offsetof"] = Napi::Number::New(env, offsetof(VkFenceGetWin32HandleInfoKHR, fence));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkFenceGetWin32HandleInfoKHR_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkFenceGetWin32HandleInfoKHR, handleType));
#endif
#ifdef VK_KHR_external_fence_win32
    exports["VkFenceGetWin32HandleInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkFenceGetWin32HandleInfoKHR));
#endif
#ifdef VK_KHR_external_fence_fd
    exports["VkImportFenceFdInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImportFenceFdInfoKHR, sType));
#endif
#ifdef VK_KHR_external_fence_fd
    exports["VkImportFenceFdInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImportFenceFdInfoKHR, pNext));
#endif
#ifdef VK_KHR_external_fence_fd
    exports["VkImportFenceFdInfoKHR_fence_offsetof"] = Napi::Number::New(env, offsetof(VkImportFenceFdInfoKHR, fence));
#endif
#ifdef VK_KHR_external_fence_fd
    exports["VkImportFenceFdInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkImportFenceFdInfoKHR, flags));
#endif
#ifdef VK_KHR_external_fence_fd
    exports["VkImportFenceFdInfoKHR_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkImportFenceFdInfoKHR, handleType));
#endif
#ifdef VK_KHR_external_fence_fd
    exports["VkImportFenceFdInfoKHR_fd_offsetof"] = Napi::Number::New(env, offsetof(VkImportFenceFdInfoKHR, fd));
#endif
#ifdef VK_KHR_external_fence_fd
    exports["VkImportFenceFdInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkImportFenceFdInfoKHR));
#endif
#ifdef VK_KHR_external_fence_fd
    exports["VkFenceGetFdInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkFenceGetFdInfoKHR, sType));
#endif
#ifdef VK_KHR_external_fence_fd
    exports["VkFenceGetFdInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkFenceGetFdInfoKHR, pNext));
#endif
#ifdef VK_KHR_external_fence_fd
    exports["VkFenceGetFdInfoKHR_fence_offsetof"] = Napi::Number::New(env, offsetof(VkFenceGetFdInfoKHR, fence));
#endif
#ifdef VK_KHR_external_fence_fd
    exports["VkFenceGetFdInfoKHR_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkFenceGetFdInfoKHR, handleType));
#endif
#ifdef VK_KHR_external_fence_fd
    exports["VkFenceGetFdInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkFenceGetFdInfoKHR));
#endif
    exports["VkPhysicalDeviceMultiviewFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiviewFeatures, sType));
    exports["VkPhysicalDeviceMultiviewFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiviewFeatures, pNext));
    exports["VkPhysicalDeviceMultiviewFeatures_multiview_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiviewFeatures, multiview));
    exports["VkPhysicalDeviceMultiviewFeatures_multiviewGeometryShader_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiviewFeatures, multiviewGeometryShader));
    exports["VkPhysicalDeviceMultiviewFeatures_multiviewTessellationShader_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiviewFeatures, multiviewTessellationShader));
    exports["VkPhysicalDeviceMultiviewFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMultiviewFeatures));
#ifdef VK_KHR_multiview
    exports["VkPhysicalDeviceMultiviewFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMultiviewFeaturesKHR));
#endif
    exports["VkPhysicalDeviceMultiviewProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiviewProperties, sType));
    exports["VkPhysicalDeviceMultiviewProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiviewProperties, pNext));
    exports["VkPhysicalDeviceMultiviewProperties_maxMultiviewViewCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiviewProperties, maxMultiviewViewCount));
    exports["VkPhysicalDeviceMultiviewProperties_maxMultiviewInstanceIndex_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiviewProperties, maxMultiviewInstanceIndex));
    exports["VkPhysicalDeviceMultiviewProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMultiviewProperties));
#ifdef VK_KHR_multiview
    exports["VkPhysicalDeviceMultiviewPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMultiviewPropertiesKHR));
#endif
    exports["VkRenderPassMultiviewCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassMultiviewCreateInfo, sType));
    exports["VkRenderPassMultiviewCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassMultiviewCreateInfo, pNext));
    exports["VkRenderPassMultiviewCreateInfo_subpassCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassMultiviewCreateInfo, subpassCount));
    exports["VkRenderPassMultiviewCreateInfo_pViewMasks_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassMultiviewCreateInfo, pViewMasks));
    exports["VkRenderPassMultiviewCreateInfo_dependencyCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassMultiviewCreateInfo, dependencyCount));
    exports["VkRenderPassMultiviewCreateInfo_pViewOffsets_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassMultiviewCreateInfo, pViewOffsets));
    exports["VkRenderPassMultiviewCreateInfo_correlationMaskCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassMultiviewCreateInfo, correlationMaskCount));
    exports["VkRenderPassMultiviewCreateInfo_pCorrelationMasks_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassMultiviewCreateInfo, pCorrelationMasks));
    exports["VkRenderPassMultiviewCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassMultiviewCreateInfo));
#ifdef VK_KHR_multiview
    exports["VkRenderPassMultiviewCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassMultiviewCreateInfoKHR));
#endif
#ifdef VK_EXT_display_surface_counter
    exports["VkSurfaceCapabilities2EXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilities2EXT, sType));
#endif
#ifdef VK_EXT_display_surface_counter
    exports["VkSurfaceCapabilities2EXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilities2EXT, pNext));
#endif
#ifdef VK_EXT_display_surface_counter
    exports["VkSurfaceCapabilities2EXT_minImageCount_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilities2EXT, minImageCount));
#endif
#ifdef VK_EXT_display_surface_counter
    exports["VkSurfaceCapabilities2EXT_maxImageCount_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilities2EXT, maxImageCount));
#endif
#ifdef VK_EXT_display_surface_counter
    exports["VkSurfaceCapabilities2EXT_currentExtent_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilities2EXT, currentExtent));
#endif
#ifdef VK_EXT_display_surface_counter
    exports["VkSurfaceCapabilities2EXT_minImageExtent_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilities2EXT, minImageExtent));
#endif
#ifdef VK_EXT_display_surface_counter
    exports["VkSurfaceCapabilities2EXT_maxImageExtent_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilities2EXT, maxImageExtent));
#endif
#ifdef VK_EXT_display_surface_counter
    exports["VkSurfaceCapabilities2EXT_maxImageArrayLayers_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilities2EXT, maxImageArrayLayers));
#endif
#ifdef VK_EXT_display_surface_counter
    exports["VkSurfaceCapabilities2EXT_supportedTransforms_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilities2EXT, supportedTransforms));
#endif
#ifdef VK_EXT_display_surface_counter
    exports["VkSurfaceCapabilities2EXT_currentTransform_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilities2EXT, currentTransform));
#endif
#ifdef VK_EXT_display_surface_counter
    exports["VkSurfaceCapabilities2EXT_supportedCompositeAlpha_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilities2EXT, supportedCompositeAlpha));
#endif
#ifdef VK_EXT_display_surface_counter
    exports["VkSurfaceCapabilities2EXT_supportedUsageFlags_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilities2EXT, supportedUsageFlags));
#endif
#ifdef VK_EXT_display_surface_counter
    exports["VkSurfaceCapabilities2EXT_supportedSurfaceCounters_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilities2EXT, supportedSurfaceCounters));
#endif
#ifdef VK_EXT_display_surface_counter
    exports["VkSurfaceCapabilities2EXT_sizeof"] = Napi::Number::New(env, sizeof(VkSurfaceCapabilities2EXT));
#endif
#ifdef VK_EXT_display_control
    exports["VkDisplayPowerInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPowerInfoEXT, sType));
#endif
#ifdef VK_EXT_display_control
    exports["VkDisplayPowerInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPowerInfoEXT, pNext));
#endif
#ifdef VK_EXT_display_control
    exports["VkDisplayPowerInfoEXT_powerState_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPowerInfoEXT, powerState));
#endif
#ifdef VK_EXT_display_control
    exports["VkDisplayPowerInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDisplayPowerInfoEXT));
#endif
#ifdef VK_EXT_display_control
    exports["VkDeviceEventInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceEventInfoEXT, sType));
#endif
#ifdef VK_EXT_display_control
    exports["VkDeviceEventInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceEventInfoEXT, pNext));
#endif
#ifdef VK_EXT_display_control
    exports["VkDeviceEventInfoEXT_deviceEvent_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceEventInfoEXT, deviceEvent));
#endif
#ifdef VK_EXT_display_control
    exports["VkDeviceEventInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceEventInfoEXT));
#endif
#ifdef VK_EXT_display_control
    exports["VkDisplayEventInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayEventInfoEXT, sType));
#endif
#ifdef VK_EXT_display_control
    exports["VkDisplayEventInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayEventInfoEXT, pNext));
#endif
#ifdef VK_EXT_display_control
    exports["VkDisplayEventInfoEXT_displayEvent_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayEventInfoEXT, displayEvent));
#endif
#ifdef VK_EXT_display_control
    exports["VkDisplayEventInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDisplayEventInfoEXT));
#endif
#ifdef VK_EXT_display_control
    exports["VkSwapchainCounterCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCounterCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_display_control
    exports["VkSwapchainCounterCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCounterCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_display_control
    exports["VkSwapchainCounterCreateInfoEXT_surfaceCounters_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainCounterCreateInfoEXT, surfaceCounters));
#endif
#ifdef VK_EXT_display_control
    exports["VkSwapchainCounterCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkSwapchainCounterCreateInfoEXT));
#endif
    exports["VkPhysicalDeviceGroupProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceGroupProperties, sType));
    exports["VkPhysicalDeviceGroupProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceGroupProperties, pNext));
    exports["VkPhysicalDeviceGroupProperties_physicalDeviceCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceGroupProperties, physicalDeviceCount));
    exports["VkPhysicalDeviceGroupProperties_physicalDevices_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceGroupProperties, physicalDevices));
    exports["VkPhysicalDeviceGroupProperties_subsetAllocation_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceGroupProperties, subsetAllocation));
    exports["VkPhysicalDeviceGroupProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceGroupProperties));
#ifdef VK_KHR_device_group_creation
    exports["VkPhysicalDeviceGroupPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceGroupPropertiesKHR));
#endif
    exports["VkMemoryAllocateFlagsInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryAllocateFlagsInfo, sType));
    exports["VkMemoryAllocateFlagsInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryAllocateFlagsInfo, pNext));
    exports["VkMemoryAllocateFlagsInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryAllocateFlagsInfo, flags));
    exports["VkMemoryAllocateFlagsInfo_deviceMask_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryAllocateFlagsInfo, deviceMask));
    exports["VkMemoryAllocateFlagsInfo_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryAllocateFlagsInfo));
#ifdef VK_KHR_device_group
    exports["VkMemoryAllocateFlagsInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryAllocateFlagsInfoKHR));
#endif
    exports["VkBindBufferMemoryInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBindBufferMemoryInfo, sType));
    exports["VkBindBufferMemoryInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBindBufferMemoryInfo, pNext));
    exports["VkBindBufferMemoryInfo_buffer_offsetof"] = Napi::Number::New(env, offsetof(VkBindBufferMemoryInfo, buffer));
    exports["VkBindBufferMemoryInfo_memory_offsetof"] = Napi::Number::New(env, offsetof(VkBindBufferMemoryInfo, memory));
    exports["VkBindBufferMemoryInfo_memoryOffset_offsetof"] = Napi::Number::New(env, offsetof(VkBindBufferMemoryInfo, memoryOffset));
    exports["VkBindBufferMemoryInfo_sizeof"] = Napi::Number::New(env, sizeof(VkBindBufferMemoryInfo));
#ifdef VK_KHR_bind_memory2
    exports["VkBindBufferMemoryInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkBindBufferMemoryInfoKHR));
#endif
    exports["VkBindBufferMemoryDeviceGroupInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBindBufferMemoryDeviceGroupInfo, sType));
    exports["VkBindBufferMemoryDeviceGroupInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBindBufferMemoryDeviceGroupInfo, pNext));
    exports["VkBindBufferMemoryDeviceGroupInfo_deviceIndexCount_offsetof"] = Napi::Number::New(env, offsetof(VkBindBufferMemoryDeviceGroupInfo, deviceIndexCount));
    exports["VkBindBufferMemoryDeviceGroupInfo_pDeviceIndices_offsetof"] = Napi::Number::New(env, offsetof(VkBindBufferMemoryDeviceGroupInfo, pDeviceIndices));
    exports["VkBindBufferMemoryDeviceGroupInfo_sizeof"] = Napi::Number::New(env, sizeof(VkBindBufferMemoryDeviceGroupInfo));
#ifdef VK_KHR_device_group
    exports["VkBindBufferMemoryDeviceGroupInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkBindBufferMemoryDeviceGroupInfoKHR));
#endif
    exports["VkBindImageMemoryInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBindImageMemoryInfo, sType));
    exports["VkBindImageMemoryInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBindImageMemoryInfo, pNext));
    exports["VkBindImageMemoryInfo_image_offsetof"] = Napi::Number::New(env, offsetof(VkBindImageMemoryInfo, image));
    exports["VkBindImageMemoryInfo_memory_offsetof"] = Napi::Number::New(env, offsetof(VkBindImageMemoryInfo, memory));
    exports["VkBindImageMemoryInfo_memoryOffset_offsetof"] = Napi::Number::New(env, offsetof(VkBindImageMemoryInfo, memoryOffset));
    exports["VkBindImageMemoryInfo_sizeof"] = Napi::Number::New(env, sizeof(VkBindImageMemoryInfo));
#ifdef VK_KHR_bind_memory2
    exports["VkBindImageMemoryInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkBindImageMemoryInfoKHR));
#endif
    exports["VkBindImageMemoryDeviceGroupInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBindImageMemoryDeviceGroupInfo, sType));
    exports["VkBindImageMemoryDeviceGroupInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBindImageMemoryDeviceGroupInfo, pNext));
    exports["VkBindImageMemoryDeviceGroupInfo_deviceIndexCount_offsetof"] = Napi::Number::New(env, offsetof(VkBindImageMemoryDeviceGroupInfo, deviceIndexCount));
    exports["VkBindImageMemoryDeviceGroupInfo_pDeviceIndices_offsetof"] = Napi::Number::New(env, offsetof(VkBindImageMemoryDeviceGroupInfo, pDeviceIndices));
    exports["VkBindImageMemoryDeviceGroupInfo_splitInstanceBindRegionCount_offsetof"] = Napi::Number::New(env, offsetof(VkBindImageMemoryDeviceGroupInfo, splitInstanceBindRegionCount));
    exports["VkBindImageMemoryDeviceGroupInfo_pSplitInstanceBindRegions_offsetof"] = Napi::Number::New(env, offsetof(VkBindImageMemoryDeviceGroupInfo, pSplitInstanceBindRegions));
    exports["VkBindImageMemoryDeviceGroupInfo_sizeof"] = Napi::Number::New(env, sizeof(VkBindImageMemoryDeviceGroupInfo));
#ifdef VK_KHR_device_group
    exports["VkBindImageMemoryDeviceGroupInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkBindImageMemoryDeviceGroupInfoKHR));
#endif
    exports["VkDeviceGroupRenderPassBeginInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupRenderPassBeginInfo, sType));
    exports["VkDeviceGroupRenderPassBeginInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupRenderPassBeginInfo, pNext));
    exports["VkDeviceGroupRenderPassBeginInfo_deviceMask_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupRenderPassBeginInfo, deviceMask));
    exports["VkDeviceGroupRenderPassBeginInfo_deviceRenderAreaCount_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupRenderPassBeginInfo, deviceRenderAreaCount));
    exports["VkDeviceGroupRenderPassBeginInfo_pDeviceRenderAreas_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupRenderPassBeginInfo, pDeviceRenderAreas));
    exports["VkDeviceGroupRenderPassBeginInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceGroupRenderPassBeginInfo));
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupRenderPassBeginInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceGroupRenderPassBeginInfoKHR));
#endif
    exports["VkDeviceGroupCommandBufferBeginInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupCommandBufferBeginInfo, sType));
    exports["VkDeviceGroupCommandBufferBeginInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupCommandBufferBeginInfo, pNext));
    exports["VkDeviceGroupCommandBufferBeginInfo_deviceMask_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupCommandBufferBeginInfo, deviceMask));
    exports["VkDeviceGroupCommandBufferBeginInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceGroupCommandBufferBeginInfo));
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupCommandBufferBeginInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceGroupCommandBufferBeginInfoKHR));
#endif
    exports["VkDeviceGroupSubmitInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupSubmitInfo, sType));
    exports["VkDeviceGroupSubmitInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupSubmitInfo, pNext));
    exports["VkDeviceGroupSubmitInfo_waitSemaphoreCount_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupSubmitInfo, waitSemaphoreCount));
    exports["VkDeviceGroupSubmitInfo_pWaitSemaphoreDeviceIndices_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupSubmitInfo, pWaitSemaphoreDeviceIndices));
    exports["VkDeviceGroupSubmitInfo_commandBufferCount_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupSubmitInfo, commandBufferCount));
    exports["VkDeviceGroupSubmitInfo_pCommandBufferDeviceMasks_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupSubmitInfo, pCommandBufferDeviceMasks));
    exports["VkDeviceGroupSubmitInfo_signalSemaphoreCount_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupSubmitInfo, signalSemaphoreCount));
    exports["VkDeviceGroupSubmitInfo_pSignalSemaphoreDeviceIndices_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupSubmitInfo, pSignalSemaphoreDeviceIndices));
    exports["VkDeviceGroupSubmitInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceGroupSubmitInfo));
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupSubmitInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceGroupSubmitInfoKHR));
#endif
    exports["VkDeviceGroupBindSparseInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupBindSparseInfo, sType));
    exports["VkDeviceGroupBindSparseInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupBindSparseInfo, pNext));
    exports["VkDeviceGroupBindSparseInfo_resourceDeviceIndex_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupBindSparseInfo, resourceDeviceIndex));
    exports["VkDeviceGroupBindSparseInfo_memoryDeviceIndex_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupBindSparseInfo, memoryDeviceIndex));
    exports["VkDeviceGroupBindSparseInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceGroupBindSparseInfo));
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupBindSparseInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceGroupBindSparseInfoKHR));
#endif
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupPresentCapabilitiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupPresentCapabilitiesKHR, sType));
#endif
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupPresentCapabilitiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupPresentCapabilitiesKHR, pNext));
#endif
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupPresentCapabilitiesKHR_presentMask_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupPresentCapabilitiesKHR, presentMask));
#endif
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupPresentCapabilitiesKHR_modes_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupPresentCapabilitiesKHR, modes));
#endif
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupPresentCapabilitiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceGroupPresentCapabilitiesKHR));
#endif
#ifdef VK_KHR_device_group
    exports["VkImageSwapchainCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageSwapchainCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_device_group
    exports["VkImageSwapchainCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageSwapchainCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_device_group
    exports["VkImageSwapchainCreateInfoKHR_swapchain_offsetof"] = Napi::Number::New(env, offsetof(VkImageSwapchainCreateInfoKHR, swapchain));
#endif
#ifdef VK_KHR_device_group
    exports["VkImageSwapchainCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkImageSwapchainCreateInfoKHR));
#endif
#ifdef VK_KHR_device_group
    exports["VkBindImageMemorySwapchainInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBindImageMemorySwapchainInfoKHR, sType));
#endif
#ifdef VK_KHR_device_group
    exports["VkBindImageMemorySwapchainInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBindImageMemorySwapchainInfoKHR, pNext));
#endif
#ifdef VK_KHR_device_group
    exports["VkBindImageMemorySwapchainInfoKHR_swapchain_offsetof"] = Napi::Number::New(env, offsetof(VkBindImageMemorySwapchainInfoKHR, swapchain));
#endif
#ifdef VK_KHR_device_group
    exports["VkBindImageMemorySwapchainInfoKHR_imageIndex_offsetof"] = Napi::Number::New(env, offsetof(VkBindImageMemorySwapchainInfoKHR, imageIndex));
#endif
#ifdef VK_KHR_device_group
    exports["VkBindImageMemorySwapchainInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkBindImageMemorySwapchainInfoKHR));
#endif
#ifdef VK_KHR_device_group
    exports["VkAcquireNextImageInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAcquireNextImageInfoKHR, sType));
#endif
#ifdef VK_KHR_device_group
    exports["VkAcquireNextImageInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAcquireNextImageInfoKHR, pNext));
#endif
#ifdef VK_KHR_device_group
    exports["VkAcquireNextImageInfoKHR_swapchain_offsetof"] = Napi::Number::New(env, offsetof(VkAcquireNextImageInfoKHR, swapchain));
#endif
#ifdef VK_KHR_device_group
    exports["VkAcquireNextImageInfoKHR_timeout_offsetof"] = Napi::Number::New(env, offsetof(VkAcquireNextImageInfoKHR, timeout));
#endif
#ifdef VK_KHR_device_group
    exports["VkAcquireNextImageInfoKHR_semaphore_offsetof"] = Napi::Number::New(env, offsetof(VkAcquireNextImageInfoKHR, semaphore));
#endif
#ifdef VK_KHR_device_group
    exports["VkAcquireNextImageInfoKHR_fence_offsetof"] = Napi::Number::New(env, offsetof(VkAcquireNextImageInfoKHR, fence));
#endif
#ifdef VK_KHR_device_group
    exports["VkAcquireNextImageInfoKHR_deviceMask_offsetof"] = Napi::Number::New(env, offsetof(VkAcquireNextImageInfoKHR, deviceMask));
#endif
#ifdef VK_KHR_device_group
    exports["VkAcquireNextImageInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkAcquireNextImageInfoKHR));
#endif
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupPresentInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupPresentInfoKHR, sType));
#endif
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupPresentInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupPresentInfoKHR, pNext));
#endif
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupPresentInfoKHR_swapchainCount_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupPresentInfoKHR, swapchainCount));
#endif
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupPresentInfoKHR_pDeviceMasks_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupPresentInfoKHR, pDeviceMasks));
#endif
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupPresentInfoKHR_mode_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupPresentInfoKHR, mode));
#endif
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupPresentInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceGroupPresentInfoKHR));
#endif
    exports["VkDeviceGroupDeviceCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupDeviceCreateInfo, sType));
    exports["VkDeviceGroupDeviceCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupDeviceCreateInfo, pNext));
    exports["VkDeviceGroupDeviceCreateInfo_physicalDeviceCount_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupDeviceCreateInfo, physicalDeviceCount));
    exports["VkDeviceGroupDeviceCreateInfo_pPhysicalDevices_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupDeviceCreateInfo, pPhysicalDevices));
    exports["VkDeviceGroupDeviceCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceGroupDeviceCreateInfo));
#ifdef VK_KHR_device_group_creation
    exports["VkDeviceGroupDeviceCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceGroupDeviceCreateInfoKHR));
#endif
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupSwapchainCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupSwapchainCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupSwapchainCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupSwapchainCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupSwapchainCreateInfoKHR_modes_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceGroupSwapchainCreateInfoKHR, modes));
#endif
#ifdef VK_KHR_device_group
    exports["VkDeviceGroupSwapchainCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceGroupSwapchainCreateInfoKHR));
#endif
    exports["VkDescriptorUpdateTemplateEntry_dstBinding_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorUpdateTemplateEntry, dstBinding));
    exports["VkDescriptorUpdateTemplateEntry_dstArrayElement_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorUpdateTemplateEntry, dstArrayElement));
    exports["VkDescriptorUpdateTemplateEntry_descriptorCount_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorUpdateTemplateEntry, descriptorCount));
    exports["VkDescriptorUpdateTemplateEntry_descriptorType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorUpdateTemplateEntry, descriptorType));
    exports["VkDescriptorUpdateTemplateEntry_offset_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorUpdateTemplateEntry, offset));
    exports["VkDescriptorUpdateTemplateEntry_stride_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorUpdateTemplateEntry, stride));
    exports["VkDescriptorUpdateTemplateEntry_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorUpdateTemplateEntry));
#ifdef VK_KHR_descriptor_update_template
    exports["VkDescriptorUpdateTemplateEntryKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorUpdateTemplateEntryKHR));
#endif
    exports["VkDescriptorUpdateTemplateCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorUpdateTemplateCreateInfo, sType));
    exports["VkDescriptorUpdateTemplateCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorUpdateTemplateCreateInfo, pNext));
    exports["VkDescriptorUpdateTemplateCreateInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorUpdateTemplateCreateInfo, flags));
    exports["VkDescriptorUpdateTemplateCreateInfo_descriptorUpdateEntryCount_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorUpdateTemplateCreateInfo, descriptorUpdateEntryCount));
    exports["VkDescriptorUpdateTemplateCreateInfo_pDescriptorUpdateEntries_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorUpdateTemplateCreateInfo, pDescriptorUpdateEntries));
    exports["VkDescriptorUpdateTemplateCreateInfo_templateType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorUpdateTemplateCreateInfo, templateType));
    exports["VkDescriptorUpdateTemplateCreateInfo_descriptorSetLayout_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorUpdateTemplateCreateInfo, descriptorSetLayout));
    exports["VkDescriptorUpdateTemplateCreateInfo_pipelineBindPoint_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorUpdateTemplateCreateInfo, pipelineBindPoint));
    exports["VkDescriptorUpdateTemplateCreateInfo_pipelineLayout_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorUpdateTemplateCreateInfo, pipelineLayout));
    exports["VkDescriptorUpdateTemplateCreateInfo_set_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorUpdateTemplateCreateInfo, set));
    exports["VkDescriptorUpdateTemplateCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorUpdateTemplateCreateInfo));
#ifdef VK_KHR_descriptor_update_template
    exports["VkDescriptorUpdateTemplateCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorUpdateTemplateCreateInfoKHR));
#endif
#ifdef VK_EXT_hdr_metadata
    exports["VkXYColorEXT_x_offsetof"] = Napi::Number::New(env, offsetof(VkXYColorEXT, x));
#endif
#ifdef VK_EXT_hdr_metadata
    exports["VkXYColorEXT_y_offsetof"] = Napi::Number::New(env, offsetof(VkXYColorEXT, y));
#endif
#ifdef VK_EXT_hdr_metadata
    exports["VkXYColorEXT_sizeof"] = Napi::Number::New(env, sizeof(VkXYColorEXT));
#endif
#ifdef VK_KHR_present_id
    exports["VkPhysicalDevicePresentIdFeaturesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePresentIdFeaturesKHR, sType));
#endif
#ifdef VK_KHR_present_id
    exports["VkPhysicalDevicePresentIdFeaturesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePresentIdFeaturesKHR, pNext));
#endif
#ifdef VK_KHR_present_id
    exports["VkPhysicalDevicePresentIdFeaturesKHR_presentId_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePresentIdFeaturesKHR, presentId));
#endif
#ifdef VK_KHR_present_id
    exports["VkPhysicalDevicePresentIdFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePresentIdFeaturesKHR));
#endif
#ifdef VK_KHR_present_id
    exports["VkPresentIdKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPresentIdKHR, sType));
#endif
#ifdef VK_KHR_present_id
    exports["VkPresentIdKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPresentIdKHR, pNext));
#endif
#ifdef VK_KHR_present_id
    exports["VkPresentIdKHR_swapchainCount_offsetof"] = Napi::Number::New(env, offsetof(VkPresentIdKHR, swapchainCount));
#endif
#ifdef VK_KHR_present_id
    exports["VkPresentIdKHR_pPresentIds_offsetof"] = Napi::Number::New(env, offsetof(VkPresentIdKHR, pPresentIds));
#endif
#ifdef VK_KHR_present_id
    exports["VkPresentIdKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPresentIdKHR));
#endif
#ifdef VK_KHR_present_wait
    exports["VkPhysicalDevicePresentWaitFeaturesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePresentWaitFeaturesKHR, sType));
#endif
#ifdef VK_KHR_present_wait
    exports["VkPhysicalDevicePresentWaitFeaturesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePresentWaitFeaturesKHR, pNext));
#endif
#ifdef VK_KHR_present_wait
    exports["VkPhysicalDevicePresentWaitFeaturesKHR_presentWait_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePresentWaitFeaturesKHR, presentWait));
#endif
#ifdef VK_KHR_present_wait
    exports["VkPhysicalDevicePresentWaitFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePresentWaitFeaturesKHR));
#endif
#ifdef VK_EXT_hdr_metadata
    exports["VkHdrMetadataEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkHdrMetadataEXT, sType));
#endif
#ifdef VK_EXT_hdr_metadata
    exports["VkHdrMetadataEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkHdrMetadataEXT, pNext));
#endif
#ifdef VK_EXT_hdr_metadata
    exports["VkHdrMetadataEXT_displayPrimaryRed_offsetof"] = Napi::Number::New(env, offsetof(VkHdrMetadataEXT, displayPrimaryRed));
#endif
#ifdef VK_EXT_hdr_metadata
    exports["VkHdrMetadataEXT_displayPrimaryGreen_offsetof"] = Napi::Number::New(env, offsetof(VkHdrMetadataEXT, displayPrimaryGreen));
#endif
#ifdef VK_EXT_hdr_metadata
    exports["VkHdrMetadataEXT_displayPrimaryBlue_offsetof"] = Napi::Number::New(env, offsetof(VkHdrMetadataEXT, displayPrimaryBlue));
#endif
#ifdef VK_EXT_hdr_metadata
    exports["VkHdrMetadataEXT_whitePoint_offsetof"] = Napi::Number::New(env, offsetof(VkHdrMetadataEXT, whitePoint));
#endif
#ifdef VK_EXT_hdr_metadata
    exports["VkHdrMetadataEXT_maxLuminance_offsetof"] = Napi::Number::New(env, offsetof(VkHdrMetadataEXT, maxLuminance));
#endif
#ifdef VK_EXT_hdr_metadata
    exports["VkHdrMetadataEXT_minLuminance_offsetof"] = Napi::Number::New(env, offsetof(VkHdrMetadataEXT, minLuminance));
#endif
#ifdef VK_EXT_hdr_metadata
    exports["VkHdrMetadataEXT_maxContentLightLevel_offsetof"] = Napi::Number::New(env, offsetof(VkHdrMetadataEXT, maxContentLightLevel));
#endif
#ifdef VK_EXT_hdr_metadata
    exports["VkHdrMetadataEXT_maxFrameAverageLightLevel_offsetof"] = Napi::Number::New(env, offsetof(VkHdrMetadataEXT, maxFrameAverageLightLevel));
#endif
#ifdef VK_EXT_hdr_metadata
    exports["VkHdrMetadataEXT_sizeof"] = Napi::Number::New(env, sizeof(VkHdrMetadataEXT));
#endif
#ifdef VK_AMD_display_native_hdr
    exports["VkDisplayNativeHdrSurfaceCapabilitiesAMD_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayNativeHdrSurfaceCapabilitiesAMD, sType));
#endif
#ifdef VK_AMD_display_native_hdr
    exports["VkDisplayNativeHdrSurfaceCapabilitiesAMD_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayNativeHdrSurfaceCapabilitiesAMD, pNext));
#endif
#ifdef VK_AMD_display_native_hdr
    exports["VkDisplayNativeHdrSurfaceCapabilitiesAMD_localDimmingSupport_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayNativeHdrSurfaceCapabilitiesAMD, localDimmingSupport));
#endif
#ifdef VK_AMD_display_native_hdr
    exports["VkDisplayNativeHdrSurfaceCapabilitiesAMD_sizeof"] = Napi::Number::New(env, sizeof(VkDisplayNativeHdrSurfaceCapabilitiesAMD));
#endif
#ifdef VK_AMD_display_native_hdr
    exports["VkSwapchainDisplayNativeHdrCreateInfoAMD_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainDisplayNativeHdrCreateInfoAMD, sType));
#endif
#ifdef VK_AMD_display_native_hdr
    exports["VkSwapchainDisplayNativeHdrCreateInfoAMD_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainDisplayNativeHdrCreateInfoAMD, pNext));
#endif
#ifdef VK_AMD_display_native_hdr
    exports["VkSwapchainDisplayNativeHdrCreateInfoAMD_localDimmingEnable_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainDisplayNativeHdrCreateInfoAMD, localDimmingEnable));
#endif
#ifdef VK_AMD_display_native_hdr
    exports["VkSwapchainDisplayNativeHdrCreateInfoAMD_sizeof"] = Napi::Number::New(env, sizeof(VkSwapchainDisplayNativeHdrCreateInfoAMD));
#endif
#ifdef VK_GOOGLE_display_timing
    exports["VkRefreshCycleDurationGOOGLE_refreshDuration_offsetof"] = Napi::Number::New(env, offsetof(VkRefreshCycleDurationGOOGLE, refreshDuration));
#endif
#ifdef VK_GOOGLE_display_timing
    exports["VkRefreshCycleDurationGOOGLE_sizeof"] = Napi::Number::New(env, sizeof(VkRefreshCycleDurationGOOGLE));
#endif
#ifdef VK_GOOGLE_display_timing
    exports["VkPastPresentationTimingGOOGLE_presentID_offsetof"] = Napi::Number::New(env, offsetof(VkPastPresentationTimingGOOGLE, presentID));
#endif
#ifdef VK_GOOGLE_display_timing
    exports["VkPastPresentationTimingGOOGLE_desiredPresentTime_offsetof"] = Napi::Number::New(env, offsetof(VkPastPresentationTimingGOOGLE, desiredPresentTime));
#endif
#ifdef VK_GOOGLE_display_timing
    exports["VkPastPresentationTimingGOOGLE_actualPresentTime_offsetof"] = Napi::Number::New(env, offsetof(VkPastPresentationTimingGOOGLE, actualPresentTime));
#endif
#ifdef VK_GOOGLE_display_timing
    exports["VkPastPresentationTimingGOOGLE_earliestPresentTime_offsetof"] = Napi::Number::New(env, offsetof(VkPastPresentationTimingGOOGLE, earliestPresentTime));
#endif
#ifdef VK_GOOGLE_display_timing
    exports["VkPastPresentationTimingGOOGLE_presentMargin_offsetof"] = Napi::Number::New(env, offsetof(VkPastPresentationTimingGOOGLE, presentMargin));
#endif
#ifdef VK_GOOGLE_display_timing
    exports["VkPastPresentationTimingGOOGLE_sizeof"] = Napi::Number::New(env, sizeof(VkPastPresentationTimingGOOGLE));
#endif
#ifdef VK_GOOGLE_display_timing
    exports["VkPresentTimesInfoGOOGLE_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPresentTimesInfoGOOGLE, sType));
#endif
#ifdef VK_GOOGLE_display_timing
    exports["VkPresentTimesInfoGOOGLE_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPresentTimesInfoGOOGLE, pNext));
#endif
#ifdef VK_GOOGLE_display_timing
    exports["VkPresentTimesInfoGOOGLE_swapchainCount_offsetof"] = Napi::Number::New(env, offsetof(VkPresentTimesInfoGOOGLE, swapchainCount));
#endif
#ifdef VK_GOOGLE_display_timing
    exports["VkPresentTimesInfoGOOGLE_pTimes_offsetof"] = Napi::Number::New(env, offsetof(VkPresentTimesInfoGOOGLE, pTimes));
#endif
#ifdef VK_GOOGLE_display_timing
    exports["VkPresentTimesInfoGOOGLE_sizeof"] = Napi::Number::New(env, sizeof(VkPresentTimesInfoGOOGLE));
#endif
#ifdef VK_GOOGLE_display_timing
    exports["VkPresentTimeGOOGLE_presentID_offsetof"] = Napi::Number::New(env, offsetof(VkPresentTimeGOOGLE, presentID));
#endif
#ifdef VK_GOOGLE_display_timing
    exports["VkPresentTimeGOOGLE_desiredPresentTime_offsetof"] = Napi::Number::New(env, offsetof(VkPresentTimeGOOGLE, desiredPresentTime));
#endif
#ifdef VK_GOOGLE_display_timing
    exports["VkPresentTimeGOOGLE_sizeof"] = Napi::Number::New(env, sizeof(VkPresentTimeGOOGLE));
#endif
#ifdef VK_MVK_ios_surface
    exports["VkIOSSurfaceCreateInfoMVK_sType_offsetof"] = Napi::Number::New(env, offsetof(VkIOSSurfaceCreateInfoMVK, sType));
#endif
#ifdef VK_MVK_ios_surface
    exports["VkIOSSurfaceCreateInfoMVK_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkIOSSurfaceCreateInfoMVK, pNext));
#endif
#ifdef VK_MVK_ios_surface
    exports["VkIOSSurfaceCreateInfoMVK_flags_offsetof"] = Napi::Number::New(env, offsetof(VkIOSSurfaceCreateInfoMVK, flags));
#endif
#ifdef VK_MVK_ios_surface
    exports["VkIOSSurfaceCreateInfoMVK_pView_offsetof"] = Napi::Number::New(env, offsetof(VkIOSSurfaceCreateInfoMVK, pView));
#endif
#ifdef VK_MVK_ios_surface
    exports["VkIOSSurfaceCreateInfoMVK_sizeof"] = Napi::Number::New(env, sizeof(VkIOSSurfaceCreateInfoMVK));
#endif
#ifdef VK_MVK_macos_surface
    exports["VkMacOSSurfaceCreateInfoMVK_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMacOSSurfaceCreateInfoMVK, sType));
#endif
#ifdef VK_MVK_macos_surface
    exports["VkMacOSSurfaceCreateInfoMVK_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMacOSSurfaceCreateInfoMVK, pNext));
#endif
#ifdef VK_MVK_macos_surface
    exports["VkMacOSSurfaceCreateInfoMVK_flags_offsetof"] = Napi::Number::New(env, offsetof(VkMacOSSurfaceCreateInfoMVK, flags));
#endif
#ifdef VK_MVK_macos_surface
    exports["VkMacOSSurfaceCreateInfoMVK_pView_offsetof"] = Napi::Number::New(env, offsetof(VkMacOSSurfaceCreateInfoMVK, pView));
#endif
#ifdef VK_MVK_macos_surface
    exports["VkMacOSSurfaceCreateInfoMVK_sizeof"] = Napi::Number::New(env, sizeof(VkMacOSSurfaceCreateInfoMVK));
#endif
#ifdef VK_EXT_metal_surface
    exports["VkMetalSurfaceCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMetalSurfaceCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_metal_surface
    exports["VkMetalSurfaceCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMetalSurfaceCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_metal_surface
    exports["VkMetalSurfaceCreateInfoEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkMetalSurfaceCreateInfoEXT, flags));
#endif
#ifdef VK_EXT_metal_surface
    exports["VkMetalSurfaceCreateInfoEXT_pLayer_offsetof"] = Napi::Number::New(env, offsetof(VkMetalSurfaceCreateInfoEXT, pLayer));
#endif
#ifdef VK_EXT_metal_surface
    exports["VkMetalSurfaceCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkMetalSurfaceCreateInfoEXT));
#endif
#ifdef VK_NV_clip_space_w_scaling
    exports["VkViewportWScalingNV_xcoeff_offsetof"] = Napi::Number::New(env, offsetof(VkViewportWScalingNV, xcoeff));
#endif
#ifdef VK_NV_clip_space_w_scaling
    exports["VkViewportWScalingNV_ycoeff_offsetof"] = Napi::Number::New(env, offsetof(VkViewportWScalingNV, ycoeff));
#endif
#ifdef VK_NV_clip_space_w_scaling
    exports["VkViewportWScalingNV_sizeof"] = Napi::Number::New(env, sizeof(VkViewportWScalingNV));
#endif
#ifdef VK_NV_clip_space_w_scaling
    exports["VkPipelineViewportWScalingStateCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportWScalingStateCreateInfoNV, sType));
#endif
#ifdef VK_NV_clip_space_w_scaling
    exports["VkPipelineViewportWScalingStateCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportWScalingStateCreateInfoNV, pNext));
#endif
#ifdef VK_NV_clip_space_w_scaling
    exports["VkPipelineViewportWScalingStateCreateInfoNV_viewportWScalingEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportWScalingStateCreateInfoNV, viewportWScalingEnable));
#endif
#ifdef VK_NV_clip_space_w_scaling
    exports["VkPipelineViewportWScalingStateCreateInfoNV_viewportCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportWScalingStateCreateInfoNV, viewportCount));
#endif
#ifdef VK_NV_clip_space_w_scaling
    exports["VkPipelineViewportWScalingStateCreateInfoNV_pViewportWScalings_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportWScalingStateCreateInfoNV, pViewportWScalings));
#endif
#ifdef VK_NV_clip_space_w_scaling
    exports["VkPipelineViewportWScalingStateCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineViewportWScalingStateCreateInfoNV));
#endif
#ifdef VK_NV_viewport_swizzle
    exports["VkViewportSwizzleNV_x_offsetof"] = Napi::Number::New(env, offsetof(VkViewportSwizzleNV, x));
#endif
#ifdef VK_NV_viewport_swizzle
    exports["VkViewportSwizzleNV_y_offsetof"] = Napi::Number::New(env, offsetof(VkViewportSwizzleNV, y));
#endif
#ifdef VK_NV_viewport_swizzle
    exports["VkViewportSwizzleNV_z_offsetof"] = Napi::Number::New(env, offsetof(VkViewportSwizzleNV, z));
#endif
#ifdef VK_NV_viewport_swizzle
    exports["VkViewportSwizzleNV_w_offsetof"] = Napi::Number::New(env, offsetof(VkViewportSwizzleNV, w));
#endif
#ifdef VK_NV_viewport_swizzle
    exports["VkViewportSwizzleNV_sizeof"] = Napi::Number::New(env, sizeof(VkViewportSwizzleNV));
#endif
#ifdef VK_NV_viewport_swizzle
    exports["VkPipelineViewportSwizzleStateCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportSwizzleStateCreateInfoNV, sType));
#endif
#ifdef VK_NV_viewport_swizzle
    exports["VkPipelineViewportSwizzleStateCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportSwizzleStateCreateInfoNV, pNext));
#endif
#ifdef VK_NV_viewport_swizzle
    exports["VkPipelineViewportSwizzleStateCreateInfoNV_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportSwizzleStateCreateInfoNV, flags));
#endif
#ifdef VK_NV_viewport_swizzle
    exports["VkPipelineViewportSwizzleStateCreateInfoNV_viewportCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportSwizzleStateCreateInfoNV, viewportCount));
#endif
#ifdef VK_NV_viewport_swizzle
    exports["VkPipelineViewportSwizzleStateCreateInfoNV_pViewportSwizzles_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportSwizzleStateCreateInfoNV, pViewportSwizzles));
#endif
#ifdef VK_NV_viewport_swizzle
    exports["VkPipelineViewportSwizzleStateCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineViewportSwizzleStateCreateInfoNV));
#endif
#ifdef VK_EXT_discard_rectangles
    exports["VkPhysicalDeviceDiscardRectanglePropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDiscardRectanglePropertiesEXT, sType));
#endif
#ifdef VK_EXT_discard_rectangles
    exports["VkPhysicalDeviceDiscardRectanglePropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDiscardRectanglePropertiesEXT, pNext));
#endif
#ifdef VK_EXT_discard_rectangles
    exports["VkPhysicalDeviceDiscardRectanglePropertiesEXT_maxDiscardRectangles_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDiscardRectanglePropertiesEXT, maxDiscardRectangles));
#endif
#ifdef VK_EXT_discard_rectangles
    exports["VkPhysicalDeviceDiscardRectanglePropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDiscardRectanglePropertiesEXT));
#endif
#ifdef VK_EXT_discard_rectangles
    exports["VkPipelineDiscardRectangleStateCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDiscardRectangleStateCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_discard_rectangles
    exports["VkPipelineDiscardRectangleStateCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDiscardRectangleStateCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_discard_rectangles
    exports["VkPipelineDiscardRectangleStateCreateInfoEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDiscardRectangleStateCreateInfoEXT, flags));
#endif
#ifdef VK_EXT_discard_rectangles
    exports["VkPipelineDiscardRectangleStateCreateInfoEXT_discardRectangleMode_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDiscardRectangleStateCreateInfoEXT, discardRectangleMode));
#endif
#ifdef VK_EXT_discard_rectangles
    exports["VkPipelineDiscardRectangleStateCreateInfoEXT_discardRectangleCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDiscardRectangleStateCreateInfoEXT, discardRectangleCount));
#endif
#ifdef VK_EXT_discard_rectangles
    exports["VkPipelineDiscardRectangleStateCreateInfoEXT_pDiscardRectangles_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineDiscardRectangleStateCreateInfoEXT, pDiscardRectangles));
#endif
#ifdef VK_EXT_discard_rectangles
    exports["VkPipelineDiscardRectangleStateCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineDiscardRectangleStateCreateInfoEXT));
#endif
#ifdef VK_NVX_multiview_per_view_attributes
    exports["VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, sType));
#endif
#ifdef VK_NVX_multiview_per_view_attributes
    exports["VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, pNext));
#endif
#ifdef VK_NVX_multiview_per_view_attributes
    exports["VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX_perViewPositionAllComponents_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, perViewPositionAllComponents));
#endif
#ifdef VK_NVX_multiview_per_view_attributes
    exports["VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX));
#endif
    exports["VkInputAttachmentAspectReference_subpass_offsetof"] = Napi::Number::New(env, offsetof(VkInputAttachmentAspectReference, subpass));
    exports["VkInputAttachmentAspectReference_inputAttachmentIndex_offsetof"] = Napi::Number::New(env, offsetof(VkInputAttachmentAspectReference, inputAttachmentIndex));
    exports["VkInputAttachmentAspectReference_aspectMask_offsetof"] = Napi::Number::New(env, offsetof(VkInputAttachmentAspectReference, aspectMask));
    exports["VkInputAttachmentAspectReference_sizeof"] = Napi::Number::New(env, sizeof(VkInputAttachmentAspectReference));
#ifdef VK_KHR_maintenance2
    exports["VkInputAttachmentAspectReferenceKHR_sizeof"] = Napi::Number::New(env, sizeof(VkInputAttachmentAspectReferenceKHR));
#endif
    exports["VkRenderPassInputAttachmentAspectCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassInputAttachmentAspectCreateInfo, sType));
    exports["VkRenderPassInputAttachmentAspectCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassInputAttachmentAspectCreateInfo, pNext));
    exports["VkRenderPassInputAttachmentAspectCreateInfo_aspectReferenceCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassInputAttachmentAspectCreateInfo, aspectReferenceCount));
    exports["VkRenderPassInputAttachmentAspectCreateInfo_pAspectReferences_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassInputAttachmentAspectCreateInfo, pAspectReferences));
    exports["VkRenderPassInputAttachmentAspectCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassInputAttachmentAspectCreateInfo));
#ifdef VK_KHR_maintenance2
    exports["VkRenderPassInputAttachmentAspectCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassInputAttachmentAspectCreateInfoKHR));
#endif
#ifdef VK_KHR_get_surface_capabilities2
    exports["VkPhysicalDeviceSurfaceInfo2KHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSurfaceInfo2KHR, sType));
#endif
#ifdef VK_KHR_get_surface_capabilities2
    exports["VkPhysicalDeviceSurfaceInfo2KHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSurfaceInfo2KHR, pNext));
#endif
#ifdef VK_KHR_get_surface_capabilities2
    exports["VkPhysicalDeviceSurfaceInfo2KHR_surface_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSurfaceInfo2KHR, surface));
#endif
#ifdef VK_KHR_get_surface_capabilities2
    exports["VkPhysicalDeviceSurfaceInfo2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSurfaceInfo2KHR));
#endif
#ifdef VK_KHR_get_surface_capabilities2
    exports["VkSurfaceCapabilities2KHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilities2KHR, sType));
#endif
#ifdef VK_KHR_get_surface_capabilities2
    exports["VkSurfaceCapabilities2KHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilities2KHR, pNext));
#endif
#ifdef VK_KHR_get_surface_capabilities2
    exports["VkSurfaceCapabilities2KHR_surfaceCapabilities_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilities2KHR, surfaceCapabilities));
#endif
#ifdef VK_KHR_get_surface_capabilities2
    exports["VkSurfaceCapabilities2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkSurfaceCapabilities2KHR));
#endif
#ifdef VK_KHR_get_surface_capabilities2
    exports["VkSurfaceFormat2KHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceFormat2KHR, sType));
#endif
#ifdef VK_KHR_get_surface_capabilities2
    exports["VkSurfaceFormat2KHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceFormat2KHR, pNext));
#endif
#ifdef VK_KHR_get_surface_capabilities2
    exports["VkSurfaceFormat2KHR_surfaceFormat_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceFormat2KHR, surfaceFormat));
#endif
#ifdef VK_KHR_get_surface_capabilities2
    exports["VkSurfaceFormat2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkSurfaceFormat2KHR));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayProperties2KHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayProperties2KHR, sType));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayProperties2KHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayProperties2KHR, pNext));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayProperties2KHR_displayProperties_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayProperties2KHR, displayProperties));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayProperties2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkDisplayProperties2KHR));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayPlaneProperties2KHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneProperties2KHR, sType));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayPlaneProperties2KHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneProperties2KHR, pNext));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayPlaneProperties2KHR_displayPlaneProperties_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneProperties2KHR, displayPlaneProperties));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayPlaneProperties2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkDisplayPlaneProperties2KHR));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayModeProperties2KHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayModeProperties2KHR, sType));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayModeProperties2KHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayModeProperties2KHR, pNext));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayModeProperties2KHR_displayModeProperties_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayModeProperties2KHR, displayModeProperties));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayModeProperties2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkDisplayModeProperties2KHR));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayPlaneInfo2KHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneInfo2KHR, sType));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayPlaneInfo2KHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneInfo2KHR, pNext));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayPlaneInfo2KHR_mode_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneInfo2KHR, mode));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayPlaneInfo2KHR_planeIndex_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneInfo2KHR, planeIndex));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayPlaneInfo2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkDisplayPlaneInfo2KHR));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayPlaneCapabilities2KHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneCapabilities2KHR, sType));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayPlaneCapabilities2KHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneCapabilities2KHR, pNext));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayPlaneCapabilities2KHR_capabilities_offsetof"] = Napi::Number::New(env, offsetof(VkDisplayPlaneCapabilities2KHR, capabilities));
#endif
#ifdef VK_KHR_get_display_properties2
    exports["VkDisplayPlaneCapabilities2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkDisplayPlaneCapabilities2KHR));
#endif
#ifdef VK_KHR_shared_presentable_image
    exports["VkSharedPresentSurfaceCapabilitiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSharedPresentSurfaceCapabilitiesKHR, sType));
#endif
#ifdef VK_KHR_shared_presentable_image
    exports["VkSharedPresentSurfaceCapabilitiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSharedPresentSurfaceCapabilitiesKHR, pNext));
#endif
#ifdef VK_KHR_shared_presentable_image
    exports["VkSharedPresentSurfaceCapabilitiesKHR_sharedPresentSupportedUsageFlags_offsetof"] = Napi::Number::New(env, offsetof(VkSharedPresentSurfaceCapabilitiesKHR, sharedPresentSupportedUsageFlags));
#endif
#ifdef VK_KHR_shared_presentable_image
    exports["VkSharedPresentSurfaceCapabilitiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkSharedPresentSurfaceCapabilitiesKHR));
#endif
    exports["VkPhysicalDevice16BitStorageFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevice16BitStorageFeatures, sType));
    exports["VkPhysicalDevice16BitStorageFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevice16BitStorageFeatures, pNext));
    exports["VkPhysicalDevice16BitStorageFeatures_storageBuffer16BitAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevice16BitStorageFeatures, storageBuffer16BitAccess));
    exports["VkPhysicalDevice16BitStorageFeatures_uniformAndStorageBuffer16BitAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevice16BitStorageFeatures, uniformAndStorageBuffer16BitAccess));
    exports["VkPhysicalDevice16BitStorageFeatures_storagePushConstant16_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevice16BitStorageFeatures, storagePushConstant16));
    exports["VkPhysicalDevice16BitStorageFeatures_storageInputOutput16_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevice16BitStorageFeatures, storageInputOutput16));
    exports["VkPhysicalDevice16BitStorageFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevice16BitStorageFeatures));
#ifdef VK_KHR_16bit_storage
    exports["VkPhysicalDevice16BitStorageFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevice16BitStorageFeaturesKHR));
#endif
    exports["VkPhysicalDeviceSubgroupProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubgroupProperties, sType));
    exports["VkPhysicalDeviceSubgroupProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubgroupProperties, pNext));
    exports["VkPhysicalDeviceSubgroupProperties_subgroupSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubgroupProperties, subgroupSize));
    exports["VkPhysicalDeviceSubgroupProperties_supportedStages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubgroupProperties, supportedStages));
    exports["VkPhysicalDeviceSubgroupProperties_supportedOperations_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubgroupProperties, supportedOperations));
    exports["VkPhysicalDeviceSubgroupProperties_quadOperationsInAllStages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubgroupProperties, quadOperationsInAllStages));
    exports["VkPhysicalDeviceSubgroupProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSubgroupProperties));
    exports["VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, sType));
    exports["VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, pNext));
    exports["VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures_shaderSubgroupExtendedTypes_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, shaderSubgroupExtendedTypes));
    exports["VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures));
#ifdef VK_KHR_shader_subgroup_extended_types
    exports["VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR));
#endif
    exports["VkBufferMemoryRequirementsInfo2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryRequirementsInfo2, sType));
    exports["VkBufferMemoryRequirementsInfo2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryRequirementsInfo2, pNext));
    exports["VkBufferMemoryRequirementsInfo2_buffer_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryRequirementsInfo2, buffer));
    exports["VkBufferMemoryRequirementsInfo2_sizeof"] = Napi::Number::New(env, sizeof(VkBufferMemoryRequirementsInfo2));
#ifdef VK_KHR_get_memory_requirements2
    exports["VkBufferMemoryRequirementsInfo2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkBufferMemoryRequirementsInfo2KHR));
#endif
    exports["VkDeviceBufferMemoryRequirements_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceBufferMemoryRequirements, sType));
    exports["VkDeviceBufferMemoryRequirements_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceBufferMemoryRequirements, pNext));
    exports["VkDeviceBufferMemoryRequirements_pCreateInfo_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceBufferMemoryRequirements, pCreateInfo));
    exports["VkDeviceBufferMemoryRequirements_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceBufferMemoryRequirements));
#ifdef VK_KHR_maintenance4
    exports["VkDeviceBufferMemoryRequirementsKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceBufferMemoryRequirementsKHR));
#endif
    exports["VkImageMemoryRequirementsInfo2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryRequirementsInfo2, sType));
    exports["VkImageMemoryRequirementsInfo2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryRequirementsInfo2, pNext));
    exports["VkImageMemoryRequirementsInfo2_image_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryRequirementsInfo2, image));
    exports["VkImageMemoryRequirementsInfo2_sizeof"] = Napi::Number::New(env, sizeof(VkImageMemoryRequirementsInfo2));
#ifdef VK_KHR_get_memory_requirements2
    exports["VkImageMemoryRequirementsInfo2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkImageMemoryRequirementsInfo2KHR));
#endif
    exports["VkImageSparseMemoryRequirementsInfo2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageSparseMemoryRequirementsInfo2, sType));
    exports["VkImageSparseMemoryRequirementsInfo2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageSparseMemoryRequirementsInfo2, pNext));
    exports["VkImageSparseMemoryRequirementsInfo2_image_offsetof"] = Napi::Number::New(env, offsetof(VkImageSparseMemoryRequirementsInfo2, image));
    exports["VkImageSparseMemoryRequirementsInfo2_sizeof"] = Napi::Number::New(env, sizeof(VkImageSparseMemoryRequirementsInfo2));
#ifdef VK_KHR_get_memory_requirements2
    exports["VkImageSparseMemoryRequirementsInfo2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkImageSparseMemoryRequirementsInfo2KHR));
#endif
    exports["VkDeviceImageMemoryRequirements_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceImageMemoryRequirements, sType));
    exports["VkDeviceImageMemoryRequirements_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceImageMemoryRequirements, pNext));
    exports["VkDeviceImageMemoryRequirements_pCreateInfo_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceImageMemoryRequirements, pCreateInfo));
    exports["VkDeviceImageMemoryRequirements_planeAspect_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceImageMemoryRequirements, planeAspect));
    exports["VkDeviceImageMemoryRequirements_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceImageMemoryRequirements));
#ifdef VK_KHR_maintenance4
    exports["VkDeviceImageMemoryRequirementsKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceImageMemoryRequirementsKHR));
#endif
    exports["VkMemoryRequirements2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryRequirements2, sType));
    exports["VkMemoryRequirements2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryRequirements2, pNext));
    exports["VkMemoryRequirements2_memoryRequirements_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryRequirements2, memoryRequirements));
    exports["VkMemoryRequirements2_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryRequirements2));
#ifdef VK_NV_ray_tracing
    exports["VkMemoryRequirements2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryRequirements2KHR));
#endif
    exports["VkSparseImageMemoryRequirements2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageMemoryRequirements2, sType));
    exports["VkSparseImageMemoryRequirements2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageMemoryRequirements2, pNext));
    exports["VkSparseImageMemoryRequirements2_memoryRequirements_offsetof"] = Napi::Number::New(env, offsetof(VkSparseImageMemoryRequirements2, memoryRequirements));
    exports["VkSparseImageMemoryRequirements2_sizeof"] = Napi::Number::New(env, sizeof(VkSparseImageMemoryRequirements2));
#ifdef VK_KHR_get_memory_requirements2
    exports["VkSparseImageMemoryRequirements2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkSparseImageMemoryRequirements2KHR));
#endif
    exports["VkPhysicalDevicePointClippingProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePointClippingProperties, sType));
    exports["VkPhysicalDevicePointClippingProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePointClippingProperties, pNext));
    exports["VkPhysicalDevicePointClippingProperties_pointClippingBehavior_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePointClippingProperties, pointClippingBehavior));
    exports["VkPhysicalDevicePointClippingProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePointClippingProperties));
#ifdef VK_KHR_maintenance2
    exports["VkPhysicalDevicePointClippingPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePointClippingPropertiesKHR));
#endif
    exports["VkMemoryDedicatedRequirements_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryDedicatedRequirements, sType));
    exports["VkMemoryDedicatedRequirements_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryDedicatedRequirements, pNext));
    exports["VkMemoryDedicatedRequirements_prefersDedicatedAllocation_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryDedicatedRequirements, prefersDedicatedAllocation));
    exports["VkMemoryDedicatedRequirements_requiresDedicatedAllocation_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryDedicatedRequirements, requiresDedicatedAllocation));
    exports["VkMemoryDedicatedRequirements_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryDedicatedRequirements));
#ifdef VK_KHR_dedicated_allocation
    exports["VkMemoryDedicatedRequirementsKHR_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryDedicatedRequirementsKHR));
#endif
    exports["VkMemoryDedicatedAllocateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryDedicatedAllocateInfo, sType));
    exports["VkMemoryDedicatedAllocateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryDedicatedAllocateInfo, pNext));
    exports["VkMemoryDedicatedAllocateInfo_image_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryDedicatedAllocateInfo, image));
    exports["VkMemoryDedicatedAllocateInfo_buffer_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryDedicatedAllocateInfo, buffer));
    exports["VkMemoryDedicatedAllocateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryDedicatedAllocateInfo));
#ifdef VK_KHR_dedicated_allocation
    exports["VkMemoryDedicatedAllocateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryDedicatedAllocateInfoKHR));
#endif
    exports["VkImageViewUsageCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewUsageCreateInfo, sType));
    exports["VkImageViewUsageCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewUsageCreateInfo, pNext));
    exports["VkImageViewUsageCreateInfo_usage_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewUsageCreateInfo, usage));
    exports["VkImageViewUsageCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkImageViewUsageCreateInfo));
#ifdef VK_KHR_maintenance2
    exports["VkImageViewUsageCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkImageViewUsageCreateInfoKHR));
#endif
    exports["VkPipelineTessellationDomainOriginStateCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineTessellationDomainOriginStateCreateInfo, sType));
    exports["VkPipelineTessellationDomainOriginStateCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineTessellationDomainOriginStateCreateInfo, pNext));
    exports["VkPipelineTessellationDomainOriginStateCreateInfo_domainOrigin_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineTessellationDomainOriginStateCreateInfo, domainOrigin));
    exports["VkPipelineTessellationDomainOriginStateCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineTessellationDomainOriginStateCreateInfo));
#ifdef VK_KHR_maintenance2
    exports["VkPipelineTessellationDomainOriginStateCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineTessellationDomainOriginStateCreateInfoKHR));
#endif
    exports["VkSamplerYcbcrConversionInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerYcbcrConversionInfo, sType));
    exports["VkSamplerYcbcrConversionInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerYcbcrConversionInfo, pNext));
    exports["VkSamplerYcbcrConversionInfo_conversion_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerYcbcrConversionInfo, conversion));
    exports["VkSamplerYcbcrConversionInfo_sizeof"] = Napi::Number::New(env, sizeof(VkSamplerYcbcrConversionInfo));
#ifdef VK_KHR_sampler_ycbcr_conversion
    exports["VkSamplerYcbcrConversionInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkSamplerYcbcrConversionInfoKHR));
#endif
    exports["VkSamplerYcbcrConversionCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerYcbcrConversionCreateInfo, sType));
    exports["VkSamplerYcbcrConversionCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerYcbcrConversionCreateInfo, pNext));
    exports["VkSamplerYcbcrConversionCreateInfo_format_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerYcbcrConversionCreateInfo, format));
    exports["VkSamplerYcbcrConversionCreateInfo_ycbcrModel_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerYcbcrConversionCreateInfo, ycbcrModel));
    exports["VkSamplerYcbcrConversionCreateInfo_ycbcrRange_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerYcbcrConversionCreateInfo, ycbcrRange));
    exports["VkSamplerYcbcrConversionCreateInfo_components_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerYcbcrConversionCreateInfo, components));
    exports["VkSamplerYcbcrConversionCreateInfo_xChromaOffset_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerYcbcrConversionCreateInfo, xChromaOffset));
    exports["VkSamplerYcbcrConversionCreateInfo_yChromaOffset_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerYcbcrConversionCreateInfo, yChromaOffset));
    exports["VkSamplerYcbcrConversionCreateInfo_chromaFilter_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerYcbcrConversionCreateInfo, chromaFilter));
    exports["VkSamplerYcbcrConversionCreateInfo_forceExplicitReconstruction_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerYcbcrConversionCreateInfo, forceExplicitReconstruction));
    exports["VkSamplerYcbcrConversionCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkSamplerYcbcrConversionCreateInfo));
#ifdef VK_KHR_sampler_ycbcr_conversion
    exports["VkSamplerYcbcrConversionCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkSamplerYcbcrConversionCreateInfoKHR));
#endif
    exports["VkBindImagePlaneMemoryInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBindImagePlaneMemoryInfo, sType));
    exports["VkBindImagePlaneMemoryInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBindImagePlaneMemoryInfo, pNext));
    exports["VkBindImagePlaneMemoryInfo_planeAspect_offsetof"] = Napi::Number::New(env, offsetof(VkBindImagePlaneMemoryInfo, planeAspect));
    exports["VkBindImagePlaneMemoryInfo_sizeof"] = Napi::Number::New(env, sizeof(VkBindImagePlaneMemoryInfo));
#ifdef VK_KHR_sampler_ycbcr_conversion
    exports["VkBindImagePlaneMemoryInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkBindImagePlaneMemoryInfoKHR));
#endif
    exports["VkImagePlaneMemoryRequirementsInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImagePlaneMemoryRequirementsInfo, sType));
    exports["VkImagePlaneMemoryRequirementsInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImagePlaneMemoryRequirementsInfo, pNext));
    exports["VkImagePlaneMemoryRequirementsInfo_planeAspect_offsetof"] = Napi::Number::New(env, offsetof(VkImagePlaneMemoryRequirementsInfo, planeAspect));
    exports["VkImagePlaneMemoryRequirementsInfo_sizeof"] = Napi::Number::New(env, sizeof(VkImagePlaneMemoryRequirementsInfo));
#ifdef VK_KHR_sampler_ycbcr_conversion
    exports["VkImagePlaneMemoryRequirementsInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkImagePlaneMemoryRequirementsInfoKHR));
#endif
    exports["VkPhysicalDeviceSamplerYcbcrConversionFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSamplerYcbcrConversionFeatures, sType));
    exports["VkPhysicalDeviceSamplerYcbcrConversionFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSamplerYcbcrConversionFeatures, pNext));
    exports["VkPhysicalDeviceSamplerYcbcrConversionFeatures_samplerYcbcrConversion_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSamplerYcbcrConversionFeatures, samplerYcbcrConversion));
    exports["VkPhysicalDeviceSamplerYcbcrConversionFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSamplerYcbcrConversionFeatures));
#ifdef VK_KHR_sampler_ycbcr_conversion
    exports["VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR));
#endif
    exports["VkSamplerYcbcrConversionImageFormatProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerYcbcrConversionImageFormatProperties, sType));
    exports["VkSamplerYcbcrConversionImageFormatProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerYcbcrConversionImageFormatProperties, pNext));
    exports["VkSamplerYcbcrConversionImageFormatProperties_combinedImageSamplerDescriptorCount_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerYcbcrConversionImageFormatProperties, combinedImageSamplerDescriptorCount));
    exports["VkSamplerYcbcrConversionImageFormatProperties_sizeof"] = Napi::Number::New(env, sizeof(VkSamplerYcbcrConversionImageFormatProperties));
#ifdef VK_KHR_sampler_ycbcr_conversion
    exports["VkSamplerYcbcrConversionImageFormatPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkSamplerYcbcrConversionImageFormatPropertiesKHR));
#endif
#ifdef VK_AMD_texture_gather_bias_lod
    exports["VkTextureLODGatherFormatPropertiesAMD_sType_offsetof"] = Napi::Number::New(env, offsetof(VkTextureLODGatherFormatPropertiesAMD, sType));
#endif
#ifdef VK_AMD_texture_gather_bias_lod
    exports["VkTextureLODGatherFormatPropertiesAMD_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkTextureLODGatherFormatPropertiesAMD, pNext));
#endif
#ifdef VK_AMD_texture_gather_bias_lod
    exports["VkTextureLODGatherFormatPropertiesAMD_supportsTextureGatherLODBiasAMD_offsetof"] = Napi::Number::New(env, offsetof(VkTextureLODGatherFormatPropertiesAMD, supportsTextureGatherLODBiasAMD));
#endif
#ifdef VK_AMD_texture_gather_bias_lod
    exports["VkTextureLODGatherFormatPropertiesAMD_sizeof"] = Napi::Number::New(env, sizeof(VkTextureLODGatherFormatPropertiesAMD));
#endif
#ifdef VK_EXT_conditional_rendering
    exports["VkConditionalRenderingBeginInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkConditionalRenderingBeginInfoEXT, sType));
#endif
#ifdef VK_EXT_conditional_rendering
    exports["VkConditionalRenderingBeginInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkConditionalRenderingBeginInfoEXT, pNext));
#endif
#ifdef VK_EXT_conditional_rendering
    exports["VkConditionalRenderingBeginInfoEXT_buffer_offsetof"] = Napi::Number::New(env, offsetof(VkConditionalRenderingBeginInfoEXT, buffer));
#endif
#ifdef VK_EXT_conditional_rendering
    exports["VkConditionalRenderingBeginInfoEXT_offset_offsetof"] = Napi::Number::New(env, offsetof(VkConditionalRenderingBeginInfoEXT, offset));
#endif
#ifdef VK_EXT_conditional_rendering
    exports["VkConditionalRenderingBeginInfoEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkConditionalRenderingBeginInfoEXT, flags));
#endif
#ifdef VK_EXT_conditional_rendering
    exports["VkConditionalRenderingBeginInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkConditionalRenderingBeginInfoEXT));
#endif
    exports["VkProtectedSubmitInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkProtectedSubmitInfo, sType));
    exports["VkProtectedSubmitInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkProtectedSubmitInfo, pNext));
    exports["VkProtectedSubmitInfo_protectedSubmit_offsetof"] = Napi::Number::New(env, offsetof(VkProtectedSubmitInfo, protectedSubmit));
    exports["VkProtectedSubmitInfo_sizeof"] = Napi::Number::New(env, sizeof(VkProtectedSubmitInfo));
    exports["VkPhysicalDeviceProtectedMemoryFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProtectedMemoryFeatures, sType));
    exports["VkPhysicalDeviceProtectedMemoryFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProtectedMemoryFeatures, pNext));
    exports["VkPhysicalDeviceProtectedMemoryFeatures_protectedMemory_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProtectedMemoryFeatures, protectedMemory));
    exports["VkPhysicalDeviceProtectedMemoryFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceProtectedMemoryFeatures));
    exports["VkPhysicalDeviceProtectedMemoryProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProtectedMemoryProperties, sType));
    exports["VkPhysicalDeviceProtectedMemoryProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProtectedMemoryProperties, pNext));
    exports["VkPhysicalDeviceProtectedMemoryProperties_protectedNoFault_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProtectedMemoryProperties, protectedNoFault));
    exports["VkPhysicalDeviceProtectedMemoryProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceProtectedMemoryProperties));
    exports["VkDeviceQueueInfo2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceQueueInfo2, sType));
    exports["VkDeviceQueueInfo2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceQueueInfo2, pNext));
    exports["VkDeviceQueueInfo2_flags_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceQueueInfo2, flags));
    exports["VkDeviceQueueInfo2_queueFamilyIndex_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceQueueInfo2, queueFamilyIndex));
    exports["VkDeviceQueueInfo2_queueIndex_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceQueueInfo2, queueIndex));
    exports["VkDeviceQueueInfo2_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceQueueInfo2));
#ifdef VK_NV_fragment_coverage_to_color
    exports["VkPipelineCoverageToColorStateCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCoverageToColorStateCreateInfoNV, sType));
#endif
#ifdef VK_NV_fragment_coverage_to_color
    exports["VkPipelineCoverageToColorStateCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCoverageToColorStateCreateInfoNV, pNext));
#endif
#ifdef VK_NV_fragment_coverage_to_color
    exports["VkPipelineCoverageToColorStateCreateInfoNV_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCoverageToColorStateCreateInfoNV, flags));
#endif
#ifdef VK_NV_fragment_coverage_to_color
    exports["VkPipelineCoverageToColorStateCreateInfoNV_coverageToColorEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCoverageToColorStateCreateInfoNV, coverageToColorEnable));
#endif
#ifdef VK_NV_fragment_coverage_to_color
    exports["VkPipelineCoverageToColorStateCreateInfoNV_coverageToColorLocation_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCoverageToColorStateCreateInfoNV, coverageToColorLocation));
#endif
#ifdef VK_NV_fragment_coverage_to_color
    exports["VkPipelineCoverageToColorStateCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineCoverageToColorStateCreateInfoNV));
#endif
    exports["VkPhysicalDeviceSamplerFilterMinmaxProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSamplerFilterMinmaxProperties, sType));
    exports["VkPhysicalDeviceSamplerFilterMinmaxProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSamplerFilterMinmaxProperties, pNext));
    exports["VkPhysicalDeviceSamplerFilterMinmaxProperties_filterMinmaxSingleComponentFormats_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSamplerFilterMinmaxProperties, filterMinmaxSingleComponentFormats));
    exports["VkPhysicalDeviceSamplerFilterMinmaxProperties_filterMinmaxImageComponentMapping_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSamplerFilterMinmaxProperties, filterMinmaxImageComponentMapping));
    exports["VkPhysicalDeviceSamplerFilterMinmaxProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSamplerFilterMinmaxProperties));
#ifdef VK_EXT_sampler_filter_minmax
    exports["VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkSampleLocationEXT_x_offsetof"] = Napi::Number::New(env, offsetof(VkSampleLocationEXT, x));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkSampleLocationEXT_y_offsetof"] = Napi::Number::New(env, offsetof(VkSampleLocationEXT, y));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkSampleLocationEXT_sizeof"] = Napi::Number::New(env, sizeof(VkSampleLocationEXT));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkSampleLocationsInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSampleLocationsInfoEXT, sType));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkSampleLocationsInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSampleLocationsInfoEXT, pNext));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkSampleLocationsInfoEXT_sampleLocationsPerPixel_offsetof"] = Napi::Number::New(env, offsetof(VkSampleLocationsInfoEXT, sampleLocationsPerPixel));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkSampleLocationsInfoEXT_sampleLocationGridSize_offsetof"] = Napi::Number::New(env, offsetof(VkSampleLocationsInfoEXT, sampleLocationGridSize));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkSampleLocationsInfoEXT_sampleLocationsCount_offsetof"] = Napi::Number::New(env, offsetof(VkSampleLocationsInfoEXT, sampleLocationsCount));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkSampleLocationsInfoEXT_pSampleLocations_offsetof"] = Napi::Number::New(env, offsetof(VkSampleLocationsInfoEXT, pSampleLocations));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkSampleLocationsInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkSampleLocationsInfoEXT));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkAttachmentSampleLocationsEXT_attachmentIndex_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentSampleLocationsEXT, attachmentIndex));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkAttachmentSampleLocationsEXT_sampleLocationsInfo_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentSampleLocationsEXT, sampleLocationsInfo));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkAttachmentSampleLocationsEXT_sizeof"] = Napi::Number::New(env, sizeof(VkAttachmentSampleLocationsEXT));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkSubpassSampleLocationsEXT_subpassIndex_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassSampleLocationsEXT, subpassIndex));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkSubpassSampleLocationsEXT_sampleLocationsInfo_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassSampleLocationsEXT, sampleLocationsInfo));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkSubpassSampleLocationsEXT_sizeof"] = Napi::Number::New(env, sizeof(VkSubpassSampleLocationsEXT));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkRenderPassSampleLocationsBeginInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassSampleLocationsBeginInfoEXT, sType));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkRenderPassSampleLocationsBeginInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassSampleLocationsBeginInfoEXT, pNext));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkRenderPassSampleLocationsBeginInfoEXT_attachmentInitialSampleLocationsCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassSampleLocationsBeginInfoEXT, attachmentInitialSampleLocationsCount));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkRenderPassSampleLocationsBeginInfoEXT_pAttachmentInitialSampleLocations_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassSampleLocationsBeginInfoEXT, pAttachmentInitialSampleLocations));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkRenderPassSampleLocationsBeginInfoEXT_postSubpassSampleLocationsCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassSampleLocationsBeginInfoEXT, postSubpassSampleLocationsCount));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkRenderPassSampleLocationsBeginInfoEXT_pPostSubpassSampleLocations_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassSampleLocationsBeginInfoEXT, pPostSubpassSampleLocations));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkRenderPassSampleLocationsBeginInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassSampleLocationsBeginInfoEXT));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkPipelineSampleLocationsStateCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineSampleLocationsStateCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkPipelineSampleLocationsStateCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineSampleLocationsStateCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkPipelineSampleLocationsStateCreateInfoEXT_sampleLocationsEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineSampleLocationsStateCreateInfoEXT, sampleLocationsEnable));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkPipelineSampleLocationsStateCreateInfoEXT_sampleLocationsInfo_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineSampleLocationsStateCreateInfoEXT, sampleLocationsInfo));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkPipelineSampleLocationsStateCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineSampleLocationsStateCreateInfoEXT));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkPhysicalDeviceSampleLocationsPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSampleLocationsPropertiesEXT, sType));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkPhysicalDeviceSampleLocationsPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSampleLocationsPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkPhysicalDeviceSampleLocationsPropertiesEXT_sampleLocationSampleCounts_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSampleLocationsPropertiesEXT, sampleLocationSampleCounts));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkPhysicalDeviceSampleLocationsPropertiesEXT_maxSampleLocationGridSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSampleLocationsPropertiesEXT, maxSampleLocationGridSize));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkPhysicalDeviceSampleLocationsPropertiesEXT_sampleLocationCoordinateRange_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSampleLocationsPropertiesEXT, sampleLocationCoordinateRange));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkPhysicalDeviceSampleLocationsPropertiesEXT_sampleLocationSubPixelBits_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSampleLocationsPropertiesEXT, sampleLocationSubPixelBits));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkPhysicalDeviceSampleLocationsPropertiesEXT_variableSampleLocations_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSampleLocationsPropertiesEXT, variableSampleLocations));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkPhysicalDeviceSampleLocationsPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSampleLocationsPropertiesEXT));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkMultisamplePropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMultisamplePropertiesEXT, sType));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkMultisamplePropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMultisamplePropertiesEXT, pNext));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkMultisamplePropertiesEXT_maxSampleLocationGridSize_offsetof"] = Napi::Number::New(env, offsetof(VkMultisamplePropertiesEXT, maxSampleLocationGridSize));
#endif
#ifdef VK_EXT_sample_locations
    exports["VkMultisamplePropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkMultisamplePropertiesEXT));
#endif
    exports["VkSamplerReductionModeCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerReductionModeCreateInfo, sType));
    exports["VkSamplerReductionModeCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerReductionModeCreateInfo, pNext));
    exports["VkSamplerReductionModeCreateInfo_reductionMode_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerReductionModeCreateInfo, reductionMode));
    exports["VkSamplerReductionModeCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkSamplerReductionModeCreateInfo));
#ifdef VK_EXT_sampler_filter_minmax
    exports["VkSamplerReductionModeCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkSamplerReductionModeCreateInfoEXT));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, sType));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT_advancedBlendCoherentOperations_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, advancedBlendCoherentOperations));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT));
#endif
#ifdef VK_EXT_multi_draw
    exports["VkPhysicalDeviceMultiDrawFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiDrawFeaturesEXT, sType));
#endif
#ifdef VK_EXT_multi_draw
    exports["VkPhysicalDeviceMultiDrawFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiDrawFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_multi_draw
    exports["VkPhysicalDeviceMultiDrawFeaturesEXT_multiDraw_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultiDrawFeaturesEXT, multiDraw));
#endif
#ifdef VK_EXT_multi_draw
    exports["VkPhysicalDeviceMultiDrawFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMultiDrawFeaturesEXT));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, sType));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT_advancedBlendMaxColorAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendMaxColorAttachments));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT_advancedBlendIndependentBlend_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendIndependentBlend));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT_advancedBlendNonPremultipliedSrcColor_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendNonPremultipliedSrcColor));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT_advancedBlendNonPremultipliedDstColor_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendNonPremultipliedDstColor));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT_advancedBlendCorrelatedOverlap_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendCorrelatedOverlap));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT_advancedBlendAllOperations_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendAllOperations));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPipelineColorBlendAdvancedStateCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendAdvancedStateCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPipelineColorBlendAdvancedStateCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendAdvancedStateCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPipelineColorBlendAdvancedStateCreateInfoEXT_srcPremultiplied_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendAdvancedStateCreateInfoEXT, srcPremultiplied));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPipelineColorBlendAdvancedStateCreateInfoEXT_dstPremultiplied_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendAdvancedStateCreateInfoEXT, dstPremultiplied));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPipelineColorBlendAdvancedStateCreateInfoEXT_blendOverlap_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorBlendAdvancedStateCreateInfoEXT, blendOverlap));
#endif
#ifdef VK_EXT_blend_operation_advanced
    exports["VkPipelineColorBlendAdvancedStateCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineColorBlendAdvancedStateCreateInfoEXT));
#endif
    exports["VkPhysicalDeviceInlineUniformBlockFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceInlineUniformBlockFeatures, sType));
    exports["VkPhysicalDeviceInlineUniformBlockFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceInlineUniformBlockFeatures, pNext));
    exports["VkPhysicalDeviceInlineUniformBlockFeatures_inlineUniformBlock_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceInlineUniformBlockFeatures, inlineUniformBlock));
    exports["VkPhysicalDeviceInlineUniformBlockFeatures_descriptorBindingInlineUniformBlockUpdateAfterBind_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceInlineUniformBlockFeatures, descriptorBindingInlineUniformBlockUpdateAfterBind));
    exports["VkPhysicalDeviceInlineUniformBlockFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceInlineUniformBlockFeatures));
#ifdef VK_EXT_inline_uniform_block
    exports["VkPhysicalDeviceInlineUniformBlockFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceInlineUniformBlockFeaturesEXT));
#endif
    exports["VkPhysicalDeviceInlineUniformBlockProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceInlineUniformBlockProperties, sType));
    exports["VkPhysicalDeviceInlineUniformBlockProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceInlineUniformBlockProperties, pNext));
    exports["VkPhysicalDeviceInlineUniformBlockProperties_maxInlineUniformBlockSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceInlineUniformBlockProperties, maxInlineUniformBlockSize));
    exports["VkPhysicalDeviceInlineUniformBlockProperties_maxPerStageDescriptorInlineUniformBlocks_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceInlineUniformBlockProperties, maxPerStageDescriptorInlineUniformBlocks));
    exports["VkPhysicalDeviceInlineUniformBlockProperties_maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceInlineUniformBlockProperties, maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks));
    exports["VkPhysicalDeviceInlineUniformBlockProperties_maxDescriptorSetInlineUniformBlocks_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceInlineUniformBlockProperties, maxDescriptorSetInlineUniformBlocks));
    exports["VkPhysicalDeviceInlineUniformBlockProperties_maxDescriptorSetUpdateAfterBindInlineUniformBlocks_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceInlineUniformBlockProperties, maxDescriptorSetUpdateAfterBindInlineUniformBlocks));
    exports["VkPhysicalDeviceInlineUniformBlockProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceInlineUniformBlockProperties));
#ifdef VK_EXT_inline_uniform_block
    exports["VkPhysicalDeviceInlineUniformBlockPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceInlineUniformBlockPropertiesEXT));
#endif
    exports["VkWriteDescriptorSetInlineUniformBlock_sType_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSetInlineUniformBlock, sType));
    exports["VkWriteDescriptorSetInlineUniformBlock_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSetInlineUniformBlock, pNext));
    exports["VkWriteDescriptorSetInlineUniformBlock_dataSize_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSetInlineUniformBlock, dataSize));
    exports["VkWriteDescriptorSetInlineUniformBlock_pData_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSetInlineUniformBlock, pData));
    exports["VkWriteDescriptorSetInlineUniformBlock_sizeof"] = Napi::Number::New(env, sizeof(VkWriteDescriptorSetInlineUniformBlock));
#ifdef VK_EXT_inline_uniform_block
    exports["VkWriteDescriptorSetInlineUniformBlockEXT_sizeof"] = Napi::Number::New(env, sizeof(VkWriteDescriptorSetInlineUniformBlockEXT));
#endif
    exports["VkDescriptorPoolInlineUniformBlockCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorPoolInlineUniformBlockCreateInfo, sType));
    exports["VkDescriptorPoolInlineUniformBlockCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorPoolInlineUniformBlockCreateInfo, pNext));
    exports["VkDescriptorPoolInlineUniformBlockCreateInfo_maxInlineUniformBlockBindings_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorPoolInlineUniformBlockCreateInfo, maxInlineUniformBlockBindings));
    exports["VkDescriptorPoolInlineUniformBlockCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorPoolInlineUniformBlockCreateInfo));
#ifdef VK_EXT_inline_uniform_block
    exports["VkDescriptorPoolInlineUniformBlockCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorPoolInlineUniformBlockCreateInfoEXT));
#endif
#ifdef VK_NV_framebuffer_mixed_samples
    exports["VkPipelineCoverageModulationStateCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCoverageModulationStateCreateInfoNV, sType));
#endif
#ifdef VK_NV_framebuffer_mixed_samples
    exports["VkPipelineCoverageModulationStateCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCoverageModulationStateCreateInfoNV, pNext));
#endif
#ifdef VK_NV_framebuffer_mixed_samples
    exports["VkPipelineCoverageModulationStateCreateInfoNV_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCoverageModulationStateCreateInfoNV, flags));
#endif
#ifdef VK_NV_framebuffer_mixed_samples
    exports["VkPipelineCoverageModulationStateCreateInfoNV_coverageModulationMode_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCoverageModulationStateCreateInfoNV, coverageModulationMode));
#endif
#ifdef VK_NV_framebuffer_mixed_samples
    exports["VkPipelineCoverageModulationStateCreateInfoNV_coverageModulationTableEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCoverageModulationStateCreateInfoNV, coverageModulationTableEnable));
#endif
#ifdef VK_NV_framebuffer_mixed_samples
    exports["VkPipelineCoverageModulationStateCreateInfoNV_coverageModulationTableCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCoverageModulationStateCreateInfoNV, coverageModulationTableCount));
#endif
#ifdef VK_NV_framebuffer_mixed_samples
    exports["VkPipelineCoverageModulationStateCreateInfoNV_pCoverageModulationTable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCoverageModulationStateCreateInfoNV, pCoverageModulationTable));
#endif
#ifdef VK_NV_framebuffer_mixed_samples
    exports["VkPipelineCoverageModulationStateCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineCoverageModulationStateCreateInfoNV));
#endif
    exports["VkImageFormatListCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatListCreateInfo, sType));
    exports["VkImageFormatListCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatListCreateInfo, pNext));
    exports["VkImageFormatListCreateInfo_viewFormatCount_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatListCreateInfo, viewFormatCount));
    exports["VkImageFormatListCreateInfo_pViewFormats_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatListCreateInfo, pViewFormats));
    exports["VkImageFormatListCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkImageFormatListCreateInfo));
#ifdef VK_KHR_image_format_list
    exports["VkImageFormatListCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkImageFormatListCreateInfoKHR));
#endif
#ifdef VK_EXT_validation_cache
    exports["VkValidationCacheCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkValidationCacheCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_validation_cache
    exports["VkValidationCacheCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkValidationCacheCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_validation_cache
    exports["VkValidationCacheCreateInfoEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkValidationCacheCreateInfoEXT, flags));
#endif
#ifdef VK_EXT_validation_cache
    exports["VkValidationCacheCreateInfoEXT_initialDataSize_offsetof"] = Napi::Number::New(env, offsetof(VkValidationCacheCreateInfoEXT, initialDataSize));
#endif
#ifdef VK_EXT_validation_cache
    exports["VkValidationCacheCreateInfoEXT_pInitialData_offsetof"] = Napi::Number::New(env, offsetof(VkValidationCacheCreateInfoEXT, pInitialData));
#endif
#ifdef VK_EXT_validation_cache
    exports["VkValidationCacheCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkValidationCacheCreateInfoEXT));
#endif
#ifdef VK_EXT_validation_cache
    exports["VkShaderModuleValidationCacheCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkShaderModuleValidationCacheCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_validation_cache
    exports["VkShaderModuleValidationCacheCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkShaderModuleValidationCacheCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_validation_cache
    exports["VkShaderModuleValidationCacheCreateInfoEXT_validationCache_offsetof"] = Napi::Number::New(env, offsetof(VkShaderModuleValidationCacheCreateInfoEXT, validationCache));
#endif
#ifdef VK_EXT_validation_cache
    exports["VkShaderModuleValidationCacheCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkShaderModuleValidationCacheCreateInfoEXT));
#endif
    exports["VkPhysicalDeviceMaintenance3Properties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMaintenance3Properties, sType));
    exports["VkPhysicalDeviceMaintenance3Properties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMaintenance3Properties, pNext));
    exports["VkPhysicalDeviceMaintenance3Properties_maxPerSetDescriptors_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMaintenance3Properties, maxPerSetDescriptors));
    exports["VkPhysicalDeviceMaintenance3Properties_maxMemoryAllocationSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMaintenance3Properties, maxMemoryAllocationSize));
    exports["VkPhysicalDeviceMaintenance3Properties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMaintenance3Properties));
#ifdef VK_KHR_maintenance3
    exports["VkPhysicalDeviceMaintenance3PropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMaintenance3PropertiesKHR));
#endif
    exports["VkPhysicalDeviceMaintenance4Features_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMaintenance4Features, sType));
    exports["VkPhysicalDeviceMaintenance4Features_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMaintenance4Features, pNext));
    exports["VkPhysicalDeviceMaintenance4Features_maintenance4_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMaintenance4Features, maintenance4));
    exports["VkPhysicalDeviceMaintenance4Features_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMaintenance4Features));
#ifdef VK_KHR_maintenance4
    exports["VkPhysicalDeviceMaintenance4FeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMaintenance4FeaturesKHR));
#endif
    exports["VkPhysicalDeviceMaintenance4Properties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMaintenance4Properties, sType));
    exports["VkPhysicalDeviceMaintenance4Properties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMaintenance4Properties, pNext));
    exports["VkPhysicalDeviceMaintenance4Properties_maxBufferSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMaintenance4Properties, maxBufferSize));
    exports["VkPhysicalDeviceMaintenance4Properties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMaintenance4Properties));
#ifdef VK_KHR_maintenance4
    exports["VkPhysicalDeviceMaintenance4PropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMaintenance4PropertiesKHR));
#endif
    exports["VkDescriptorSetLayoutSupport_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutSupport, sType));
    exports["VkDescriptorSetLayoutSupport_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutSupport, pNext));
    exports["VkDescriptorSetLayoutSupport_supported_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutSupport, supported));
    exports["VkDescriptorSetLayoutSupport_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorSetLayoutSupport));
#ifdef VK_KHR_maintenance3
    exports["VkDescriptorSetLayoutSupportKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorSetLayoutSupportKHR));
#endif
    exports["VkPhysicalDeviceShaderDrawParametersFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderDrawParametersFeatures, sType));
    exports["VkPhysicalDeviceShaderDrawParametersFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderDrawParametersFeatures, pNext));
    exports["VkPhysicalDeviceShaderDrawParametersFeatures_shaderDrawParameters_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderDrawParametersFeatures, shaderDrawParameters));
    exports["VkPhysicalDeviceShaderDrawParametersFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderDrawParametersFeatures));
    exports["VkPhysicalDeviceShaderDrawParameterFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderDrawParameterFeatures));
    exports["VkPhysicalDeviceShaderFloat16Int8Features_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderFloat16Int8Features, sType));
    exports["VkPhysicalDeviceShaderFloat16Int8Features_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderFloat16Int8Features, pNext));
    exports["VkPhysicalDeviceShaderFloat16Int8Features_shaderFloat16_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderFloat16Int8Features, shaderFloat16));
    exports["VkPhysicalDeviceShaderFloat16Int8Features_shaderInt8_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderFloat16Int8Features, shaderInt8));
    exports["VkPhysicalDeviceShaderFloat16Int8Features_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderFloat16Int8Features));
#ifdef VK_KHR_shader_float16_int8
    exports["VkPhysicalDeviceShaderFloat16Int8FeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderFloat16Int8FeaturesKHR));
#endif
#ifdef VK_KHR_shader_float16_int8
    exports["VkPhysicalDeviceFloat16Int8FeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFloat16Int8FeaturesKHR));
#endif
    exports["VkPhysicalDeviceFloatControlsProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, sType));
    exports["VkPhysicalDeviceFloatControlsProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, pNext));
    exports["VkPhysicalDeviceFloatControlsProperties_denormBehaviorIndependence_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, denormBehaviorIndependence));
    exports["VkPhysicalDeviceFloatControlsProperties_roundingModeIndependence_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, roundingModeIndependence));
    exports["VkPhysicalDeviceFloatControlsProperties_shaderSignedZeroInfNanPreserveFloat16_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, shaderSignedZeroInfNanPreserveFloat16));
    exports["VkPhysicalDeviceFloatControlsProperties_shaderSignedZeroInfNanPreserveFloat32_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, shaderSignedZeroInfNanPreserveFloat32));
    exports["VkPhysicalDeviceFloatControlsProperties_shaderSignedZeroInfNanPreserveFloat64_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, shaderSignedZeroInfNanPreserveFloat64));
    exports["VkPhysicalDeviceFloatControlsProperties_shaderDenormPreserveFloat16_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, shaderDenormPreserveFloat16));
    exports["VkPhysicalDeviceFloatControlsProperties_shaderDenormPreserveFloat32_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, shaderDenormPreserveFloat32));
    exports["VkPhysicalDeviceFloatControlsProperties_shaderDenormPreserveFloat64_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, shaderDenormPreserveFloat64));
    exports["VkPhysicalDeviceFloatControlsProperties_shaderDenormFlushToZeroFloat16_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, shaderDenormFlushToZeroFloat16));
    exports["VkPhysicalDeviceFloatControlsProperties_shaderDenormFlushToZeroFloat32_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, shaderDenormFlushToZeroFloat32));
    exports["VkPhysicalDeviceFloatControlsProperties_shaderDenormFlushToZeroFloat64_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, shaderDenormFlushToZeroFloat64));
    exports["VkPhysicalDeviceFloatControlsProperties_shaderRoundingModeRTEFloat16_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, shaderRoundingModeRTEFloat16));
    exports["VkPhysicalDeviceFloatControlsProperties_shaderRoundingModeRTEFloat32_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, shaderRoundingModeRTEFloat32));
    exports["VkPhysicalDeviceFloatControlsProperties_shaderRoundingModeRTEFloat64_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, shaderRoundingModeRTEFloat64));
    exports["VkPhysicalDeviceFloatControlsProperties_shaderRoundingModeRTZFloat16_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, shaderRoundingModeRTZFloat16));
    exports["VkPhysicalDeviceFloatControlsProperties_shaderRoundingModeRTZFloat32_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, shaderRoundingModeRTZFloat32));
    exports["VkPhysicalDeviceFloatControlsProperties_shaderRoundingModeRTZFloat64_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFloatControlsProperties, shaderRoundingModeRTZFloat64));
    exports["VkPhysicalDeviceFloatControlsProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFloatControlsProperties));
#ifdef VK_KHR_shader_float_controls
    exports["VkPhysicalDeviceFloatControlsPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFloatControlsPropertiesKHR));
#endif
    exports["VkPhysicalDeviceHostQueryResetFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceHostQueryResetFeatures, sType));
    exports["VkPhysicalDeviceHostQueryResetFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceHostQueryResetFeatures, pNext));
    exports["VkPhysicalDeviceHostQueryResetFeatures_hostQueryReset_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceHostQueryResetFeatures, hostQueryReset));
    exports["VkPhysicalDeviceHostQueryResetFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceHostQueryResetFeatures));
#ifdef VK_EXT_host_query_reset
    exports["VkPhysicalDeviceHostQueryResetFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceHostQueryResetFeaturesEXT));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkNativeBufferUsage2ANDROID_consumer_offsetof"] = Napi::Number::New(env, offsetof(VkNativeBufferUsage2ANDROID, consumer));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkNativeBufferUsage2ANDROID_producer_offsetof"] = Napi::Number::New(env, offsetof(VkNativeBufferUsage2ANDROID, producer));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkNativeBufferUsage2ANDROID_sizeof"] = Napi::Number::New(env, sizeof(VkNativeBufferUsage2ANDROID));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkNativeBufferANDROID_sType_offsetof"] = Napi::Number::New(env, offsetof(VkNativeBufferANDROID, sType));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkNativeBufferANDROID_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkNativeBufferANDROID, pNext));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkNativeBufferANDROID_handle_offsetof"] = Napi::Number::New(env, offsetof(VkNativeBufferANDROID, handle));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkNativeBufferANDROID_stride_offsetof"] = Napi::Number::New(env, offsetof(VkNativeBufferANDROID, stride));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkNativeBufferANDROID_format_offsetof"] = Napi::Number::New(env, offsetof(VkNativeBufferANDROID, format));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkNativeBufferANDROID_usage_offsetof"] = Napi::Number::New(env, offsetof(VkNativeBufferANDROID, usage));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkNativeBufferANDROID_usage2_offsetof"] = Napi::Number::New(env, offsetof(VkNativeBufferANDROID, usage2));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkNativeBufferANDROID_sizeof"] = Napi::Number::New(env, sizeof(VkNativeBufferANDROID));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkSwapchainImageCreateInfoANDROID_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainImageCreateInfoANDROID, sType));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkSwapchainImageCreateInfoANDROID_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainImageCreateInfoANDROID, pNext));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkSwapchainImageCreateInfoANDROID_usage_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainImageCreateInfoANDROID, usage));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkSwapchainImageCreateInfoANDROID_sizeof"] = Napi::Number::New(env, sizeof(VkSwapchainImageCreateInfoANDROID));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkPhysicalDevicePresentationPropertiesANDROID_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePresentationPropertiesANDROID, sType));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkPhysicalDevicePresentationPropertiesANDROID_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePresentationPropertiesANDROID, pNext));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkPhysicalDevicePresentationPropertiesANDROID_sharedImage_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePresentationPropertiesANDROID, sharedImage));
#endif
#ifdef VK_ANDROID_native_buffer
    exports["VkPhysicalDevicePresentationPropertiesANDROID_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePresentationPropertiesANDROID));
#endif
#ifdef VK_AMD_shader_info
    exports["VkShaderResourceUsageAMD_numUsedVgprs_offsetof"] = Napi::Number::New(env, offsetof(VkShaderResourceUsageAMD, numUsedVgprs));
#endif
#ifdef VK_AMD_shader_info
    exports["VkShaderResourceUsageAMD_numUsedSgprs_offsetof"] = Napi::Number::New(env, offsetof(VkShaderResourceUsageAMD, numUsedSgprs));
#endif
#ifdef VK_AMD_shader_info
    exports["VkShaderResourceUsageAMD_ldsSizePerLocalWorkGroup_offsetof"] = Napi::Number::New(env, offsetof(VkShaderResourceUsageAMD, ldsSizePerLocalWorkGroup));
#endif
#ifdef VK_AMD_shader_info
    exports["VkShaderResourceUsageAMD_ldsUsageSizeInBytes_offsetof"] = Napi::Number::New(env, offsetof(VkShaderResourceUsageAMD, ldsUsageSizeInBytes));
#endif
#ifdef VK_AMD_shader_info
    exports["VkShaderResourceUsageAMD_scratchMemUsageInBytes_offsetof"] = Napi::Number::New(env, offsetof(VkShaderResourceUsageAMD, scratchMemUsageInBytes));
#endif
#ifdef VK_AMD_shader_info
    exports["VkShaderResourceUsageAMD_sizeof"] = Napi::Number::New(env, sizeof(VkShaderResourceUsageAMD));
#endif
#ifdef VK_AMD_shader_info
    exports["VkShaderStatisticsInfoAMD_shaderStageMask_offsetof"] = Napi::Number::New(env, offsetof(VkShaderStatisticsInfoAMD, shaderStageMask));
#endif
#ifdef VK_AMD_shader_info
    exports["VkShaderStatisticsInfoAMD_resourceUsage_offsetof"] = Napi::Number::New(env, offsetof(VkShaderStatisticsInfoAMD, resourceUsage));
#endif
#ifdef VK_AMD_shader_info
    exports["VkShaderStatisticsInfoAMD_numPhysicalVgprs_offsetof"] = Napi::Number::New(env, offsetof(VkShaderStatisticsInfoAMD, numPhysicalVgprs));
#endif
#ifdef VK_AMD_shader_info
    exports["VkShaderStatisticsInfoAMD_numPhysicalSgprs_offsetof"] = Napi::Number::New(env, offsetof(VkShaderStatisticsInfoAMD, numPhysicalSgprs));
#endif
#ifdef VK_AMD_shader_info
    exports["VkShaderStatisticsInfoAMD_numAvailableVgprs_offsetof"] = Napi::Number::New(env, offsetof(VkShaderStatisticsInfoAMD, numAvailableVgprs));
#endif
#ifdef VK_AMD_shader_info
    exports["VkShaderStatisticsInfoAMD_numAvailableSgprs_offsetof"] = Napi::Number::New(env, offsetof(VkShaderStatisticsInfoAMD, numAvailableSgprs));
#endif
#ifdef VK_AMD_shader_info
    exports["VkShaderStatisticsInfoAMD_computeWorkGroupSize_offsetof"] = Napi::Number::New(env, offsetof(VkShaderStatisticsInfoAMD, computeWorkGroupSize));
#endif
#ifdef VK_AMD_shader_info
    exports["VkShaderStatisticsInfoAMD_sizeof"] = Napi::Number::New(env, sizeof(VkShaderStatisticsInfoAMD));
#endif
#ifdef VK_KHR_global_priority
    exports["VkDeviceQueueGlobalPriorityCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceQueueGlobalPriorityCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_global_priority
    exports["VkDeviceQueueGlobalPriorityCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceQueueGlobalPriorityCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_global_priority
    exports["VkDeviceQueueGlobalPriorityCreateInfoKHR_globalPriority_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceQueueGlobalPriorityCreateInfoKHR, globalPriority));
#endif
#ifdef VK_KHR_global_priority
    exports["VkDeviceQueueGlobalPriorityCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceQueueGlobalPriorityCreateInfoKHR));
#endif
#ifdef VK_EXT_global_priority
    exports["VkDeviceQueueGlobalPriorityCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceQueueGlobalPriorityCreateInfoEXT));
#endif
#ifdef VK_KHR_global_priority
    exports["VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR, sType));
#endif
#ifdef VK_KHR_global_priority
    exports["VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR, pNext));
#endif
#ifdef VK_KHR_global_priority
    exports["VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR_globalPriorityQuery_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR, globalPriorityQuery));
#endif
#ifdef VK_KHR_global_priority
    exports["VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR));
#endif
#ifdef VK_EXT_global_priority_query
    exports["VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT));
#endif
#ifdef VK_KHR_global_priority
    exports["VkQueueFamilyGlobalPriorityPropertiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyGlobalPriorityPropertiesKHR, sType));
#endif
#ifdef VK_KHR_global_priority
    exports["VkQueueFamilyGlobalPriorityPropertiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyGlobalPriorityPropertiesKHR, pNext));
#endif
#ifdef VK_KHR_global_priority
    exports["VkQueueFamilyGlobalPriorityPropertiesKHR_priorityCount_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyGlobalPriorityPropertiesKHR, priorityCount));
#endif
#ifdef VK_KHR_global_priority
    exports["VkQueueFamilyGlobalPriorityPropertiesKHR_priorities_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyGlobalPriorityPropertiesKHR, priorities));
#endif
#ifdef VK_KHR_global_priority
    exports["VkQueueFamilyGlobalPriorityPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkQueueFamilyGlobalPriorityPropertiesKHR));
#endif
#ifdef VK_EXT_global_priority_query
    exports["VkQueueFamilyGlobalPriorityPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkQueueFamilyGlobalPriorityPropertiesEXT));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsObjectNameInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsObjectNameInfoEXT, sType));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsObjectNameInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsObjectNameInfoEXT, pNext));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsObjectNameInfoEXT_objectType_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsObjectNameInfoEXT, objectType));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsObjectNameInfoEXT_objectHandle_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsObjectNameInfoEXT, objectHandle));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsObjectNameInfoEXT_pObjectName_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsObjectNameInfoEXT, pObjectName));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsObjectNameInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDebugUtilsObjectNameInfoEXT));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsObjectTagInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsObjectTagInfoEXT, sType));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsObjectTagInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsObjectTagInfoEXT, pNext));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsObjectTagInfoEXT_objectType_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsObjectTagInfoEXT, objectType));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsObjectTagInfoEXT_objectHandle_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsObjectTagInfoEXT, objectHandle));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsObjectTagInfoEXT_tagName_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsObjectTagInfoEXT, tagName));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsObjectTagInfoEXT_tagSize_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsObjectTagInfoEXT, tagSize));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsObjectTagInfoEXT_pTag_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsObjectTagInfoEXT, pTag));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsObjectTagInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDebugUtilsObjectTagInfoEXT));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsLabelEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsLabelEXT, sType));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsLabelEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsLabelEXT, pNext));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsLabelEXT_pLabelName_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsLabelEXT, pLabelName));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsLabelEXT_color_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsLabelEXT, color));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsLabelEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDebugUtilsLabelEXT));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCreateInfoEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCreateInfoEXT, flags));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCreateInfoEXT_messageSeverity_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCreateInfoEXT, messageSeverity));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCreateInfoEXT_messageType_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCreateInfoEXT, messageType));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCreateInfoEXT_pfnUserCallback_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCreateInfoEXT, pfnUserCallback));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCreateInfoEXT_pUserData_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCreateInfoEXT, pUserData));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDebugUtilsMessengerCreateInfoEXT));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCallbackDataEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCallbackDataEXT, sType));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCallbackDataEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCallbackDataEXT, pNext));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCallbackDataEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCallbackDataEXT, flags));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCallbackDataEXT_pMessageIdName_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCallbackDataEXT, pMessageIdName));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCallbackDataEXT_messageIdNumber_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCallbackDataEXT, messageIdNumber));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCallbackDataEXT_pMessage_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCallbackDataEXT, pMessage));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCallbackDataEXT_queueLabelCount_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCallbackDataEXT, queueLabelCount));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCallbackDataEXT_pQueueLabels_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCallbackDataEXT, pQueueLabels));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCallbackDataEXT_cmdBufLabelCount_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCallbackDataEXT, cmdBufLabelCount));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCallbackDataEXT_pCmdBufLabels_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCallbackDataEXT, pCmdBufLabels));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCallbackDataEXT_objectCount_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCallbackDataEXT, objectCount));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCallbackDataEXT_pObjects_offsetof"] = Napi::Number::New(env, offsetof(VkDebugUtilsMessengerCallbackDataEXT, pObjects));
#endif
#ifdef VK_EXT_debug_utils
    exports["VkDebugUtilsMessengerCallbackDataEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDebugUtilsMessengerCallbackDataEXT));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkPhysicalDeviceDeviceMemoryReportFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, sType));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkPhysicalDeviceDeviceMemoryReportFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkPhysicalDeviceDeviceMemoryReportFeaturesEXT_deviceMemoryReport_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, deviceMemoryReport));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkPhysicalDeviceDeviceMemoryReportFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkDeviceDeviceMemoryReportCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceDeviceMemoryReportCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkDeviceDeviceMemoryReportCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceDeviceMemoryReportCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkDeviceDeviceMemoryReportCreateInfoEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceDeviceMemoryReportCreateInfoEXT, flags));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkDeviceDeviceMemoryReportCreateInfoEXT_pfnUserCallback_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceDeviceMemoryReportCreateInfoEXT, pfnUserCallback));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkDeviceDeviceMemoryReportCreateInfoEXT_pUserData_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceDeviceMemoryReportCreateInfoEXT, pUserData));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkDeviceDeviceMemoryReportCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceDeviceMemoryReportCreateInfoEXT));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkDeviceMemoryReportCallbackDataEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceMemoryReportCallbackDataEXT, sType));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkDeviceMemoryReportCallbackDataEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceMemoryReportCallbackDataEXT, pNext));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkDeviceMemoryReportCallbackDataEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceMemoryReportCallbackDataEXT, flags));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkDeviceMemoryReportCallbackDataEXT_type_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceMemoryReportCallbackDataEXT, type));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkDeviceMemoryReportCallbackDataEXT_memoryObjectId_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceMemoryReportCallbackDataEXT, memoryObjectId));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkDeviceMemoryReportCallbackDataEXT_size_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceMemoryReportCallbackDataEXT, size));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkDeviceMemoryReportCallbackDataEXT_objectType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceMemoryReportCallbackDataEXT, objectType));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkDeviceMemoryReportCallbackDataEXT_objectHandle_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceMemoryReportCallbackDataEXT, objectHandle));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkDeviceMemoryReportCallbackDataEXT_heapIndex_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceMemoryReportCallbackDataEXT, heapIndex));
#endif
#ifdef VK_EXT_device_memory_report
    exports["VkDeviceMemoryReportCallbackDataEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceMemoryReportCallbackDataEXT));
#endif
#ifdef VK_EXT_external_memory_host
    exports["VkImportMemoryHostPointerInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryHostPointerInfoEXT, sType));
#endif
#ifdef VK_EXT_external_memory_host
    exports["VkImportMemoryHostPointerInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryHostPointerInfoEXT, pNext));
#endif
#ifdef VK_EXT_external_memory_host
    exports["VkImportMemoryHostPointerInfoEXT_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryHostPointerInfoEXT, handleType));
#endif
#ifdef VK_EXT_external_memory_host
    exports["VkImportMemoryHostPointerInfoEXT_pHostPointer_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryHostPointerInfoEXT, pHostPointer));
#endif
#ifdef VK_EXT_external_memory_host
    exports["VkImportMemoryHostPointerInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkImportMemoryHostPointerInfoEXT));
#endif
#ifdef VK_EXT_external_memory_host
    exports["VkMemoryHostPointerPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryHostPointerPropertiesEXT, sType));
#endif
#ifdef VK_EXT_external_memory_host
    exports["VkMemoryHostPointerPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryHostPointerPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_external_memory_host
    exports["VkMemoryHostPointerPropertiesEXT_memoryTypeBits_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryHostPointerPropertiesEXT, memoryTypeBits));
#endif
#ifdef VK_EXT_external_memory_host
    exports["VkMemoryHostPointerPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryHostPointerPropertiesEXT));
#endif
#ifdef VK_EXT_external_memory_host
    exports["VkPhysicalDeviceExternalMemoryHostPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalMemoryHostPropertiesEXT, sType));
#endif
#ifdef VK_EXT_external_memory_host
    exports["VkPhysicalDeviceExternalMemoryHostPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalMemoryHostPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_external_memory_host
    exports["VkPhysicalDeviceExternalMemoryHostPropertiesEXT_minImportedHostPointerAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalMemoryHostPropertiesEXT, minImportedHostPointerAlignment));
#endif
#ifdef VK_EXT_external_memory_host
    exports["VkPhysicalDeviceExternalMemoryHostPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceExternalMemoryHostPropertiesEXT));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPhysicalDeviceConservativeRasterizationPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT, sType));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPhysicalDeviceConservativeRasterizationPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPhysicalDeviceConservativeRasterizationPropertiesEXT_primitiveOverestimationSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT, primitiveOverestimationSize));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPhysicalDeviceConservativeRasterizationPropertiesEXT_maxExtraPrimitiveOverestimationSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT, maxExtraPrimitiveOverestimationSize));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPhysicalDeviceConservativeRasterizationPropertiesEXT_extraPrimitiveOverestimationSizeGranularity_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT, extraPrimitiveOverestimationSizeGranularity));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPhysicalDeviceConservativeRasterizationPropertiesEXT_primitiveUnderestimation_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT, primitiveUnderestimation));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPhysicalDeviceConservativeRasterizationPropertiesEXT_conservativePointAndLineRasterization_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT, conservativePointAndLineRasterization));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPhysicalDeviceConservativeRasterizationPropertiesEXT_degenerateTrianglesRasterized_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT, degenerateTrianglesRasterized));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPhysicalDeviceConservativeRasterizationPropertiesEXT_degenerateLinesRasterized_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT, degenerateLinesRasterized));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPhysicalDeviceConservativeRasterizationPropertiesEXT_fullyCoveredFragmentShaderInputVariable_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT, fullyCoveredFragmentShaderInputVariable));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPhysicalDeviceConservativeRasterizationPropertiesEXT_conservativeRasterizationPostDepthCoverage_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT, conservativeRasterizationPostDepthCoverage));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPhysicalDeviceConservativeRasterizationPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT));
#endif
#ifdef VK_EXT_calibrated_timestamps
    exports["VkCalibratedTimestampInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCalibratedTimestampInfoEXT, sType));
#endif
#ifdef VK_EXT_calibrated_timestamps
    exports["VkCalibratedTimestampInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCalibratedTimestampInfoEXT, pNext));
#endif
#ifdef VK_EXT_calibrated_timestamps
    exports["VkCalibratedTimestampInfoEXT_timeDomain_offsetof"] = Napi::Number::New(env, offsetof(VkCalibratedTimestampInfoEXT, timeDomain));
#endif
#ifdef VK_EXT_calibrated_timestamps
    exports["VkCalibratedTimestampInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkCalibratedTimestampInfoEXT));
#endif
#ifdef VK_AMD_shader_core_properties
    exports["VkPhysicalDeviceShaderCorePropertiesAMD_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCorePropertiesAMD, sType));
#endif
#ifdef VK_AMD_shader_core_properties
    exports["VkPhysicalDeviceShaderCorePropertiesAMD_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCorePropertiesAMD, pNext));
#endif
#ifdef VK_AMD_shader_core_properties
    exports["VkPhysicalDeviceShaderCorePropertiesAMD_shaderEngineCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCorePropertiesAMD, shaderEngineCount));
#endif
#ifdef VK_AMD_shader_core_properties
    exports["VkPhysicalDeviceShaderCorePropertiesAMD_shaderArraysPerEngineCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCorePropertiesAMD, shaderArraysPerEngineCount));
#endif
#ifdef VK_AMD_shader_core_properties
    exports["VkPhysicalDeviceShaderCorePropertiesAMD_computeUnitsPerShaderArray_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCorePropertiesAMD, computeUnitsPerShaderArray));
#endif
#ifdef VK_AMD_shader_core_properties
    exports["VkPhysicalDeviceShaderCorePropertiesAMD_simdPerComputeUnit_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCorePropertiesAMD, simdPerComputeUnit));
#endif
#ifdef VK_AMD_shader_core_properties
    exports["VkPhysicalDeviceShaderCorePropertiesAMD_wavefrontsPerSimd_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCorePropertiesAMD, wavefrontsPerSimd));
#endif
#ifdef VK_AMD_shader_core_properties
    exports["VkPhysicalDeviceShaderCorePropertiesAMD_wavefrontSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCorePropertiesAMD, wavefrontSize));
#endif
#ifdef VK_AMD_shader_core_properties
    exports["VkPhysicalDeviceShaderCorePropertiesAMD_sgprsPerSimd_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCorePropertiesAMD, sgprsPerSimd));
#endif
#ifdef VK_AMD_shader_core_properties
    exports["VkPhysicalDeviceShaderCorePropertiesAMD_minSgprAllocation_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCorePropertiesAMD, minSgprAllocation));
#endif
#ifdef VK_AMD_shader_core_properties
    exports["VkPhysicalDeviceShaderCorePropertiesAMD_maxSgprAllocation_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCorePropertiesAMD, maxSgprAllocation));
#endif
#ifdef VK_AMD_shader_core_properties
    exports["VkPhysicalDeviceShaderCorePropertiesAMD_sgprAllocationGranularity_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCorePropertiesAMD, sgprAllocationGranularity));
#endif
#ifdef VK_AMD_shader_core_properties
    exports["VkPhysicalDeviceShaderCorePropertiesAMD_vgprsPerSimd_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCorePropertiesAMD, vgprsPerSimd));
#endif
#ifdef VK_AMD_shader_core_properties
    exports["VkPhysicalDeviceShaderCorePropertiesAMD_minVgprAllocation_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCorePropertiesAMD, minVgprAllocation));
#endif
#ifdef VK_AMD_shader_core_properties
    exports["VkPhysicalDeviceShaderCorePropertiesAMD_maxVgprAllocation_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCorePropertiesAMD, maxVgprAllocation));
#endif
#ifdef VK_AMD_shader_core_properties
    exports["VkPhysicalDeviceShaderCorePropertiesAMD_vgprAllocationGranularity_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCorePropertiesAMD, vgprAllocationGranularity));
#endif
#ifdef VK_AMD_shader_core_properties
    exports["VkPhysicalDeviceShaderCorePropertiesAMD_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderCorePropertiesAMD));
#endif
#ifdef VK_AMD_shader_core_properties2
    exports["VkPhysicalDeviceShaderCoreProperties2AMD_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCoreProperties2AMD, sType));
#endif
#ifdef VK_AMD_shader_core_properties2
    exports["VkPhysicalDeviceShaderCoreProperties2AMD_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCoreProperties2AMD, pNext));
#endif
#ifdef VK_AMD_shader_core_properties2
    exports["VkPhysicalDeviceShaderCoreProperties2AMD_shaderCoreFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCoreProperties2AMD, shaderCoreFeatures));
#endif
#ifdef VK_AMD_shader_core_properties2
    exports["VkPhysicalDeviceShaderCoreProperties2AMD_activeComputeUnitCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCoreProperties2AMD, activeComputeUnitCount));
#endif
#ifdef VK_AMD_shader_core_properties2
    exports["VkPhysicalDeviceShaderCoreProperties2AMD_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderCoreProperties2AMD));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPipelineRasterizationConservativeStateCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationConservativeStateCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPipelineRasterizationConservativeStateCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationConservativeStateCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPipelineRasterizationConservativeStateCreateInfoEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationConservativeStateCreateInfoEXT, flags));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPipelineRasterizationConservativeStateCreateInfoEXT_conservativeRasterizationMode_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationConservativeStateCreateInfoEXT, conservativeRasterizationMode));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPipelineRasterizationConservativeStateCreateInfoEXT_extraPrimitiveOverestimationSize_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationConservativeStateCreateInfoEXT, extraPrimitiveOverestimationSize));
#endif
#ifdef VK_EXT_conservative_rasterization
    exports["VkPipelineRasterizationConservativeStateCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineRasterizationConservativeStateCreateInfoEXT));
#endif
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, sType));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, pNext));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_shaderInputAttachmentArrayDynamicIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, shaderInputAttachmentArrayDynamicIndexing));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_shaderUniformTexelBufferArrayDynamicIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, shaderUniformTexelBufferArrayDynamicIndexing));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_shaderStorageTexelBufferArrayDynamicIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, shaderStorageTexelBufferArrayDynamicIndexing));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_shaderUniformBufferArrayNonUniformIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, shaderUniformBufferArrayNonUniformIndexing));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_shaderSampledImageArrayNonUniformIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, shaderSampledImageArrayNonUniformIndexing));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_shaderStorageBufferArrayNonUniformIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, shaderStorageBufferArrayNonUniformIndexing));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_shaderStorageImageArrayNonUniformIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, shaderStorageImageArrayNonUniformIndexing));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_shaderInputAttachmentArrayNonUniformIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, shaderInputAttachmentArrayNonUniformIndexing));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_shaderUniformTexelBufferArrayNonUniformIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, shaderUniformTexelBufferArrayNonUniformIndexing));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_shaderStorageTexelBufferArrayNonUniformIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, shaderStorageTexelBufferArrayNonUniformIndexing));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_descriptorBindingUniformBufferUpdateAfterBind_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingUniformBufferUpdateAfterBind));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_descriptorBindingSampledImageUpdateAfterBind_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingSampledImageUpdateAfterBind));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_descriptorBindingStorageImageUpdateAfterBind_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingStorageImageUpdateAfterBind));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_descriptorBindingStorageBufferUpdateAfterBind_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingStorageBufferUpdateAfterBind));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_descriptorBindingUniformTexelBufferUpdateAfterBind_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingUniformTexelBufferUpdateAfterBind));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_descriptorBindingStorageTexelBufferUpdateAfterBind_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingStorageTexelBufferUpdateAfterBind));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_descriptorBindingUpdateUnusedWhilePending_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingUpdateUnusedWhilePending));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_descriptorBindingPartiallyBound_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingPartiallyBound));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_descriptorBindingVariableDescriptorCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingVariableDescriptorCount));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_runtimeDescriptorArray_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingFeatures, runtimeDescriptorArray));
    exports["VkPhysicalDeviceDescriptorIndexingFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDescriptorIndexingFeatures));
#ifdef VK_EXT_descriptor_indexing
    exports["VkPhysicalDeviceDescriptorIndexingFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDescriptorIndexingFeaturesEXT));
#endif
    exports["VkPhysicalDeviceDescriptorIndexingProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, sType));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, pNext));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_maxUpdateAfterBindDescriptorsInAllPools_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, maxUpdateAfterBindDescriptorsInAllPools));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_shaderUniformBufferArrayNonUniformIndexingNative_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, shaderUniformBufferArrayNonUniformIndexingNative));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_shaderSampledImageArrayNonUniformIndexingNative_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, shaderSampledImageArrayNonUniformIndexingNative));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_shaderStorageBufferArrayNonUniformIndexingNative_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, shaderStorageBufferArrayNonUniformIndexingNative));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_shaderStorageImageArrayNonUniformIndexingNative_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, shaderStorageImageArrayNonUniformIndexingNative));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_shaderInputAttachmentArrayNonUniformIndexingNative_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, shaderInputAttachmentArrayNonUniformIndexingNative));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_robustBufferAccessUpdateAfterBind_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, robustBufferAccessUpdateAfterBind));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_quadDivergentImplicitLod_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, quadDivergentImplicitLod));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_maxPerStageDescriptorUpdateAfterBindSamplers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, maxPerStageDescriptorUpdateAfterBindSamplers));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_maxPerStageDescriptorUpdateAfterBindUniformBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, maxPerStageDescriptorUpdateAfterBindUniformBuffers));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_maxPerStageDescriptorUpdateAfterBindStorageBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, maxPerStageDescriptorUpdateAfterBindStorageBuffers));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_maxPerStageDescriptorUpdateAfterBindSampledImages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, maxPerStageDescriptorUpdateAfterBindSampledImages));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_maxPerStageDescriptorUpdateAfterBindStorageImages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, maxPerStageDescriptorUpdateAfterBindStorageImages));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_maxPerStageDescriptorUpdateAfterBindInputAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, maxPerStageDescriptorUpdateAfterBindInputAttachments));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_maxPerStageUpdateAfterBindResources_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, maxPerStageUpdateAfterBindResources));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_maxDescriptorSetUpdateAfterBindSamplers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, maxDescriptorSetUpdateAfterBindSamplers));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_maxDescriptorSetUpdateAfterBindUniformBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, maxDescriptorSetUpdateAfterBindUniformBuffers));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, maxDescriptorSetUpdateAfterBindUniformBuffersDynamic));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_maxDescriptorSetUpdateAfterBindStorageBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, maxDescriptorSetUpdateAfterBindStorageBuffers));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, maxDescriptorSetUpdateAfterBindStorageBuffersDynamic));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_maxDescriptorSetUpdateAfterBindSampledImages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, maxDescriptorSetUpdateAfterBindSampledImages));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_maxDescriptorSetUpdateAfterBindStorageImages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, maxDescriptorSetUpdateAfterBindStorageImages));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_maxDescriptorSetUpdateAfterBindInputAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorIndexingProperties, maxDescriptorSetUpdateAfterBindInputAttachments));
    exports["VkPhysicalDeviceDescriptorIndexingProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDescriptorIndexingProperties));
#ifdef VK_EXT_descriptor_indexing
    exports["VkPhysicalDeviceDescriptorIndexingPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDescriptorIndexingPropertiesEXT));
#endif
    exports["VkDescriptorSetLayoutBindingFlagsCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutBindingFlagsCreateInfo, sType));
    exports["VkDescriptorSetLayoutBindingFlagsCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutBindingFlagsCreateInfo, pNext));
    exports["VkDescriptorSetLayoutBindingFlagsCreateInfo_bindingCount_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutBindingFlagsCreateInfo, bindingCount));
    exports["VkDescriptorSetLayoutBindingFlagsCreateInfo_pBindingFlags_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutBindingFlagsCreateInfo, pBindingFlags));
    exports["VkDescriptorSetLayoutBindingFlagsCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorSetLayoutBindingFlagsCreateInfo));
#ifdef VK_EXT_descriptor_indexing
    exports["VkDescriptorSetLayoutBindingFlagsCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorSetLayoutBindingFlagsCreateInfoEXT));
#endif
    exports["VkDescriptorSetVariableDescriptorCountAllocateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetVariableDescriptorCountAllocateInfo, sType));
    exports["VkDescriptorSetVariableDescriptorCountAllocateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetVariableDescriptorCountAllocateInfo, pNext));
    exports["VkDescriptorSetVariableDescriptorCountAllocateInfo_descriptorSetCount_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetVariableDescriptorCountAllocateInfo, descriptorSetCount));
    exports["VkDescriptorSetVariableDescriptorCountAllocateInfo_pDescriptorCounts_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetVariableDescriptorCountAllocateInfo, pDescriptorCounts));
    exports["VkDescriptorSetVariableDescriptorCountAllocateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorSetVariableDescriptorCountAllocateInfo));
#ifdef VK_EXT_descriptor_indexing
    exports["VkDescriptorSetVariableDescriptorCountAllocateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorSetVariableDescriptorCountAllocateInfoEXT));
#endif
    exports["VkDescriptorSetVariableDescriptorCountLayoutSupport_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetVariableDescriptorCountLayoutSupport, sType));
    exports["VkDescriptorSetVariableDescriptorCountLayoutSupport_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetVariableDescriptorCountLayoutSupport, pNext));
    exports["VkDescriptorSetVariableDescriptorCountLayoutSupport_maxVariableDescriptorCount_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetVariableDescriptorCountLayoutSupport, maxVariableDescriptorCount));
    exports["VkDescriptorSetVariableDescriptorCountLayoutSupport_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorSetVariableDescriptorCountLayoutSupport));
#ifdef VK_EXT_descriptor_indexing
    exports["VkDescriptorSetVariableDescriptorCountLayoutSupportEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorSetVariableDescriptorCountLayoutSupportEXT));
#endif
    exports["VkAttachmentDescription2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription2, sType));
    exports["VkAttachmentDescription2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription2, pNext));
    exports["VkAttachmentDescription2_flags_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription2, flags));
    exports["VkAttachmentDescription2_format_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription2, format));
    exports["VkAttachmentDescription2_samples_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription2, samples));
    exports["VkAttachmentDescription2_loadOp_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription2, loadOp));
    exports["VkAttachmentDescription2_storeOp_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription2, storeOp));
    exports["VkAttachmentDescription2_stencilLoadOp_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription2, stencilLoadOp));
    exports["VkAttachmentDescription2_stencilStoreOp_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription2, stencilStoreOp));
    exports["VkAttachmentDescription2_initialLayout_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription2, initialLayout));
    exports["VkAttachmentDescription2_finalLayout_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescription2, finalLayout));
    exports["VkAttachmentDescription2_sizeof"] = Napi::Number::New(env, sizeof(VkAttachmentDescription2));
#ifdef VK_KHR_create_renderpass2
    exports["VkAttachmentDescription2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkAttachmentDescription2KHR));
#endif
    exports["VkAttachmentReference2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentReference2, sType));
    exports["VkAttachmentReference2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentReference2, pNext));
    exports["VkAttachmentReference2_attachment_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentReference2, attachment));
    exports["VkAttachmentReference2_layout_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentReference2, layout));
    exports["VkAttachmentReference2_aspectMask_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentReference2, aspectMask));
    exports["VkAttachmentReference2_sizeof"] = Napi::Number::New(env, sizeof(VkAttachmentReference2));
#ifdef VK_KHR_create_renderpass2
    exports["VkAttachmentReference2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkAttachmentReference2KHR));
#endif
    exports["VkSubpassDescription2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription2, sType));
    exports["VkSubpassDescription2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription2, pNext));
    exports["VkSubpassDescription2_flags_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription2, flags));
    exports["VkSubpassDescription2_pipelineBindPoint_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription2, pipelineBindPoint));
    exports["VkSubpassDescription2_viewMask_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription2, viewMask));
    exports["VkSubpassDescription2_inputAttachmentCount_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription2, inputAttachmentCount));
    exports["VkSubpassDescription2_pInputAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription2, pInputAttachments));
    exports["VkSubpassDescription2_colorAttachmentCount_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription2, colorAttachmentCount));
    exports["VkSubpassDescription2_pColorAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription2, pColorAttachments));
    exports["VkSubpassDescription2_pResolveAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription2, pResolveAttachments));
    exports["VkSubpassDescription2_pDepthStencilAttachment_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription2, pDepthStencilAttachment));
    exports["VkSubpassDescription2_preserveAttachmentCount_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription2, preserveAttachmentCount));
    exports["VkSubpassDescription2_pPreserveAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescription2, pPreserveAttachments));
    exports["VkSubpassDescription2_sizeof"] = Napi::Number::New(env, sizeof(VkSubpassDescription2));
#ifdef VK_KHR_create_renderpass2
    exports["VkSubpassDescription2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkSubpassDescription2KHR));
#endif
    exports["VkSubpassDependency2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDependency2, sType));
    exports["VkSubpassDependency2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDependency2, pNext));
    exports["VkSubpassDependency2_srcSubpass_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDependency2, srcSubpass));
    exports["VkSubpassDependency2_dstSubpass_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDependency2, dstSubpass));
    exports["VkSubpassDependency2_srcStageMask_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDependency2, srcStageMask));
    exports["VkSubpassDependency2_dstStageMask_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDependency2, dstStageMask));
    exports["VkSubpassDependency2_srcAccessMask_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDependency2, srcAccessMask));
    exports["VkSubpassDependency2_dstAccessMask_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDependency2, dstAccessMask));
    exports["VkSubpassDependency2_dependencyFlags_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDependency2, dependencyFlags));
    exports["VkSubpassDependency2_viewOffset_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDependency2, viewOffset));
    exports["VkSubpassDependency2_sizeof"] = Napi::Number::New(env, sizeof(VkSubpassDependency2));
#ifdef VK_KHR_create_renderpass2
    exports["VkSubpassDependency2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkSubpassDependency2KHR));
#endif
    exports["VkRenderPassCreateInfo2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo2, sType));
    exports["VkRenderPassCreateInfo2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo2, pNext));
    exports["VkRenderPassCreateInfo2_flags_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo2, flags));
    exports["VkRenderPassCreateInfo2_attachmentCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo2, attachmentCount));
    exports["VkRenderPassCreateInfo2_pAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo2, pAttachments));
    exports["VkRenderPassCreateInfo2_subpassCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo2, subpassCount));
    exports["VkRenderPassCreateInfo2_pSubpasses_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo2, pSubpasses));
    exports["VkRenderPassCreateInfo2_dependencyCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo2, dependencyCount));
    exports["VkRenderPassCreateInfo2_pDependencies_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo2, pDependencies));
    exports["VkRenderPassCreateInfo2_correlatedViewMaskCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo2, correlatedViewMaskCount));
    exports["VkRenderPassCreateInfo2_pCorrelatedViewMasks_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreateInfo2, pCorrelatedViewMasks));
    exports["VkRenderPassCreateInfo2_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassCreateInfo2));
#ifdef VK_KHR_create_renderpass2
    exports["VkRenderPassCreateInfo2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassCreateInfo2KHR));
#endif
    exports["VkSubpassBeginInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassBeginInfo, sType));
    exports["VkSubpassBeginInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassBeginInfo, pNext));
    exports["VkSubpassBeginInfo_contents_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassBeginInfo, contents));
    exports["VkSubpassBeginInfo_sizeof"] = Napi::Number::New(env, sizeof(VkSubpassBeginInfo));
#ifdef VK_KHR_create_renderpass2
    exports["VkSubpassBeginInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkSubpassBeginInfoKHR));
#endif
    exports["VkSubpassEndInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassEndInfo, sType));
    exports["VkSubpassEndInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassEndInfo, pNext));
    exports["VkSubpassEndInfo_sizeof"] = Napi::Number::New(env, sizeof(VkSubpassEndInfo));
#ifdef VK_KHR_create_renderpass2
    exports["VkSubpassEndInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkSubpassEndInfoKHR));
#endif
    exports["VkPhysicalDeviceTimelineSemaphoreFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTimelineSemaphoreFeatures, sType));
    exports["VkPhysicalDeviceTimelineSemaphoreFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTimelineSemaphoreFeatures, pNext));
    exports["VkPhysicalDeviceTimelineSemaphoreFeatures_timelineSemaphore_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTimelineSemaphoreFeatures, timelineSemaphore));
    exports["VkPhysicalDeviceTimelineSemaphoreFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceTimelineSemaphoreFeatures));
#ifdef VK_KHR_timeline_semaphore
    exports["VkPhysicalDeviceTimelineSemaphoreFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceTimelineSemaphoreFeaturesKHR));
#endif
    exports["VkPhysicalDeviceTimelineSemaphoreProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTimelineSemaphoreProperties, sType));
    exports["VkPhysicalDeviceTimelineSemaphoreProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTimelineSemaphoreProperties, pNext));
    exports["VkPhysicalDeviceTimelineSemaphoreProperties_maxTimelineSemaphoreValueDifference_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTimelineSemaphoreProperties, maxTimelineSemaphoreValueDifference));
    exports["VkPhysicalDeviceTimelineSemaphoreProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceTimelineSemaphoreProperties));
#ifdef VK_KHR_timeline_semaphore
    exports["VkPhysicalDeviceTimelineSemaphorePropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceTimelineSemaphorePropertiesKHR));
#endif
    exports["VkSemaphoreTypeCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreTypeCreateInfo, sType));
    exports["VkSemaphoreTypeCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreTypeCreateInfo, pNext));
    exports["VkSemaphoreTypeCreateInfo_semaphoreType_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreTypeCreateInfo, semaphoreType));
    exports["VkSemaphoreTypeCreateInfo_initialValue_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreTypeCreateInfo, initialValue));
    exports["VkSemaphoreTypeCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkSemaphoreTypeCreateInfo));
#ifdef VK_KHR_timeline_semaphore
    exports["VkSemaphoreTypeCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkSemaphoreTypeCreateInfoKHR));
#endif
    exports["VkTimelineSemaphoreSubmitInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkTimelineSemaphoreSubmitInfo, sType));
    exports["VkTimelineSemaphoreSubmitInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkTimelineSemaphoreSubmitInfo, pNext));
    exports["VkTimelineSemaphoreSubmitInfo_waitSemaphoreValueCount_offsetof"] = Napi::Number::New(env, offsetof(VkTimelineSemaphoreSubmitInfo, waitSemaphoreValueCount));
    exports["VkTimelineSemaphoreSubmitInfo_pWaitSemaphoreValues_offsetof"] = Napi::Number::New(env, offsetof(VkTimelineSemaphoreSubmitInfo, pWaitSemaphoreValues));
    exports["VkTimelineSemaphoreSubmitInfo_signalSemaphoreValueCount_offsetof"] = Napi::Number::New(env, offsetof(VkTimelineSemaphoreSubmitInfo, signalSemaphoreValueCount));
    exports["VkTimelineSemaphoreSubmitInfo_pSignalSemaphoreValues_offsetof"] = Napi::Number::New(env, offsetof(VkTimelineSemaphoreSubmitInfo, pSignalSemaphoreValues));
    exports["VkTimelineSemaphoreSubmitInfo_sizeof"] = Napi::Number::New(env, sizeof(VkTimelineSemaphoreSubmitInfo));
#ifdef VK_KHR_timeline_semaphore
    exports["VkTimelineSemaphoreSubmitInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkTimelineSemaphoreSubmitInfoKHR));
#endif
    exports["VkSemaphoreWaitInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreWaitInfo, sType));
    exports["VkSemaphoreWaitInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreWaitInfo, pNext));
    exports["VkSemaphoreWaitInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreWaitInfo, flags));
    exports["VkSemaphoreWaitInfo_semaphoreCount_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreWaitInfo, semaphoreCount));
    exports["VkSemaphoreWaitInfo_pSemaphores_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreWaitInfo, pSemaphores));
    exports["VkSemaphoreWaitInfo_pValues_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreWaitInfo, pValues));
    exports["VkSemaphoreWaitInfo_sizeof"] = Napi::Number::New(env, sizeof(VkSemaphoreWaitInfo));
#ifdef VK_KHR_timeline_semaphore
    exports["VkSemaphoreWaitInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkSemaphoreWaitInfoKHR));
#endif
    exports["VkSemaphoreSignalInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreSignalInfo, sType));
    exports["VkSemaphoreSignalInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreSignalInfo, pNext));
    exports["VkSemaphoreSignalInfo_semaphore_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreSignalInfo, semaphore));
    exports["VkSemaphoreSignalInfo_value_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreSignalInfo, value));
    exports["VkSemaphoreSignalInfo_sizeof"] = Napi::Number::New(env, sizeof(VkSemaphoreSignalInfo));
#ifdef VK_KHR_timeline_semaphore
    exports["VkSemaphoreSignalInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkSemaphoreSignalInfoKHR));
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    exports["VkVertexInputBindingDivisorDescriptionEXT_binding_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputBindingDivisorDescriptionEXT, binding));
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    exports["VkVertexInputBindingDivisorDescriptionEXT_divisor_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputBindingDivisorDescriptionEXT, divisor));
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    exports["VkVertexInputBindingDivisorDescriptionEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVertexInputBindingDivisorDescriptionEXT));
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    exports["VkPipelineVertexInputDivisorStateCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineVertexInputDivisorStateCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    exports["VkPipelineVertexInputDivisorStateCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineVertexInputDivisorStateCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    exports["VkPipelineVertexInputDivisorStateCreateInfoEXT_vertexBindingDivisorCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineVertexInputDivisorStateCreateInfoEXT, vertexBindingDivisorCount));
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    exports["VkPipelineVertexInputDivisorStateCreateInfoEXT_pVertexBindingDivisors_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineVertexInputDivisorStateCreateInfoEXT, pVertexBindingDivisors));
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    exports["VkPipelineVertexInputDivisorStateCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineVertexInputDivisorStateCreateInfoEXT));
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    exports["VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, sType));
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    exports["VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    exports["VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT_maxVertexAttribDivisor_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, maxVertexAttribDivisor));
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    exports["VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT));
#endif
#ifdef VK_EXT_pci_bus_info
    exports["VkPhysicalDevicePCIBusInfoPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePCIBusInfoPropertiesEXT, sType));
#endif
#ifdef VK_EXT_pci_bus_info
    exports["VkPhysicalDevicePCIBusInfoPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePCIBusInfoPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_pci_bus_info
    exports["VkPhysicalDevicePCIBusInfoPropertiesEXT_pciDomain_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePCIBusInfoPropertiesEXT, pciDomain));
#endif
#ifdef VK_EXT_pci_bus_info
    exports["VkPhysicalDevicePCIBusInfoPropertiesEXT_pciBus_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePCIBusInfoPropertiesEXT, pciBus));
#endif
#ifdef VK_EXT_pci_bus_info
    exports["VkPhysicalDevicePCIBusInfoPropertiesEXT_pciDevice_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePCIBusInfoPropertiesEXT, pciDevice));
#endif
#ifdef VK_EXT_pci_bus_info
    exports["VkPhysicalDevicePCIBusInfoPropertiesEXT_pciFunction_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePCIBusInfoPropertiesEXT, pciFunction));
#endif
#ifdef VK_EXT_pci_bus_info
    exports["VkPhysicalDevicePCIBusInfoPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePCIBusInfoPropertiesEXT));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkImportAndroidHardwareBufferInfoANDROID_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImportAndroidHardwareBufferInfoANDROID, sType));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkImportAndroidHardwareBufferInfoANDROID_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImportAndroidHardwareBufferInfoANDROID, pNext));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkImportAndroidHardwareBufferInfoANDROID_buffer_offsetof"] = Napi::Number::New(env, offsetof(VkImportAndroidHardwareBufferInfoANDROID, buffer));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkImportAndroidHardwareBufferInfoANDROID_sizeof"] = Napi::Number::New(env, sizeof(VkImportAndroidHardwareBufferInfoANDROID));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferUsageANDROID_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferUsageANDROID, sType));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferUsageANDROID_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferUsageANDROID, pNext));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferUsageANDROID_androidHardwareBufferUsage_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferUsageANDROID, androidHardwareBufferUsage));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferUsageANDROID_sizeof"] = Napi::Number::New(env, sizeof(VkAndroidHardwareBufferUsageANDROID));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferPropertiesANDROID_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferPropertiesANDROID, sType));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferPropertiesANDROID_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferPropertiesANDROID, pNext));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferPropertiesANDROID_allocationSize_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferPropertiesANDROID, allocationSize));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferPropertiesANDROID_memoryTypeBits_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferPropertiesANDROID, memoryTypeBits));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferPropertiesANDROID_sizeof"] = Napi::Number::New(env, sizeof(VkAndroidHardwareBufferPropertiesANDROID));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkMemoryGetAndroidHardwareBufferInfoANDROID_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetAndroidHardwareBufferInfoANDROID, sType));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkMemoryGetAndroidHardwareBufferInfoANDROID_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetAndroidHardwareBufferInfoANDROID, pNext));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkMemoryGetAndroidHardwareBufferInfoANDROID_memory_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetAndroidHardwareBufferInfoANDROID, memory));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkMemoryGetAndroidHardwareBufferInfoANDROID_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryGetAndroidHardwareBufferInfoANDROID));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatPropertiesANDROID_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatPropertiesANDROID, sType));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatPropertiesANDROID_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatPropertiesANDROID, pNext));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatPropertiesANDROID_format_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatPropertiesANDROID, format));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatPropertiesANDROID_externalFormat_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatPropertiesANDROID, externalFormat));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatPropertiesANDROID_formatFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatPropertiesANDROID, formatFeatures));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatPropertiesANDROID_samplerYcbcrConversionComponents_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatPropertiesANDROID, samplerYcbcrConversionComponents));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatPropertiesANDROID_suggestedYcbcrModel_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatPropertiesANDROID, suggestedYcbcrModel));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatPropertiesANDROID_suggestedYcbcrRange_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatPropertiesANDROID, suggestedYcbcrRange));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatPropertiesANDROID_suggestedXChromaOffset_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatPropertiesANDROID, suggestedXChromaOffset));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatPropertiesANDROID_suggestedYChromaOffset_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatPropertiesANDROID, suggestedYChromaOffset));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatPropertiesANDROID_sizeof"] = Napi::Number::New(env, sizeof(VkAndroidHardwareBufferFormatPropertiesANDROID));
#endif
#ifdef VK_EXT_conditional_rendering
    exports["VkCommandBufferInheritanceConditionalRenderingInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceConditionalRenderingInfoEXT, sType));
#endif
#ifdef VK_EXT_conditional_rendering
    exports["VkCommandBufferInheritanceConditionalRenderingInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceConditionalRenderingInfoEXT, pNext));
#endif
#ifdef VK_EXT_conditional_rendering
    exports["VkCommandBufferInheritanceConditionalRenderingInfoEXT_conditionalRenderingEnable_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceConditionalRenderingInfoEXT, conditionalRenderingEnable));
#endif
#ifdef VK_EXT_conditional_rendering
    exports["VkCommandBufferInheritanceConditionalRenderingInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkCommandBufferInheritanceConditionalRenderingInfoEXT));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkExternalFormatANDROID_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExternalFormatANDROID, sType));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkExternalFormatANDROID_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExternalFormatANDROID, pNext));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkExternalFormatANDROID_externalFormat_offsetof"] = Napi::Number::New(env, offsetof(VkExternalFormatANDROID, externalFormat));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkExternalFormatANDROID_sizeof"] = Napi::Number::New(env, sizeof(VkExternalFormatANDROID));
#endif
    exports["VkPhysicalDevice8BitStorageFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevice8BitStorageFeatures, sType));
    exports["VkPhysicalDevice8BitStorageFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevice8BitStorageFeatures, pNext));
    exports["VkPhysicalDevice8BitStorageFeatures_storageBuffer8BitAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevice8BitStorageFeatures, storageBuffer8BitAccess));
    exports["VkPhysicalDevice8BitStorageFeatures_uniformAndStorageBuffer8BitAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevice8BitStorageFeatures, uniformAndStorageBuffer8BitAccess));
    exports["VkPhysicalDevice8BitStorageFeatures_storagePushConstant8_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevice8BitStorageFeatures, storagePushConstant8));
    exports["VkPhysicalDevice8BitStorageFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevice8BitStorageFeatures));
#ifdef VK_KHR_8bit_storage
    exports["VkPhysicalDevice8BitStorageFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevice8BitStorageFeaturesKHR));
#endif
#ifdef VK_EXT_conditional_rendering
    exports["VkPhysicalDeviceConditionalRenderingFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceConditionalRenderingFeaturesEXT, sType));
#endif
#ifdef VK_EXT_conditional_rendering
    exports["VkPhysicalDeviceConditionalRenderingFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceConditionalRenderingFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_conditional_rendering
    exports["VkPhysicalDeviceConditionalRenderingFeaturesEXT_conditionalRendering_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceConditionalRenderingFeaturesEXT, conditionalRendering));
#endif
#ifdef VK_EXT_conditional_rendering
    exports["VkPhysicalDeviceConditionalRenderingFeaturesEXT_inheritedConditionalRendering_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceConditionalRenderingFeaturesEXT, inheritedConditionalRendering));
#endif
#ifdef VK_EXT_conditional_rendering
    exports["VkPhysicalDeviceConditionalRenderingFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceConditionalRenderingFeaturesEXT));
#endif
    exports["VkPhysicalDeviceVulkanMemoryModelFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkanMemoryModelFeatures, sType));
    exports["VkPhysicalDeviceVulkanMemoryModelFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkanMemoryModelFeatures, pNext));
    exports["VkPhysicalDeviceVulkanMemoryModelFeatures_vulkanMemoryModel_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkanMemoryModelFeatures, vulkanMemoryModel));
    exports["VkPhysicalDeviceVulkanMemoryModelFeatures_vulkanMemoryModelDeviceScope_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkanMemoryModelFeatures, vulkanMemoryModelDeviceScope));
    exports["VkPhysicalDeviceVulkanMemoryModelFeatures_vulkanMemoryModelAvailabilityVisibilityChains_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkanMemoryModelFeatures, vulkanMemoryModelAvailabilityVisibilityChains));
    exports["VkPhysicalDeviceVulkanMemoryModelFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceVulkanMemoryModelFeatures));
#ifdef VK_KHR_vulkan_memory_model
    exports["VkPhysicalDeviceVulkanMemoryModelFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceVulkanMemoryModelFeaturesKHR));
#endif
    exports["VkPhysicalDeviceShaderAtomicInt64Features_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicInt64Features, sType));
    exports["VkPhysicalDeviceShaderAtomicInt64Features_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicInt64Features, pNext));
    exports["VkPhysicalDeviceShaderAtomicInt64Features_shaderBufferInt64Atomics_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicInt64Features, shaderBufferInt64Atomics));
    exports["VkPhysicalDeviceShaderAtomicInt64Features_shaderSharedInt64Atomics_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicInt64Features, shaderSharedInt64Atomics));
    exports["VkPhysicalDeviceShaderAtomicInt64Features_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderAtomicInt64Features));
#ifdef VK_KHR_shader_atomic_int64
    exports["VkPhysicalDeviceShaderAtomicInt64FeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderAtomicInt64FeaturesKHR));
#endif
#ifdef VK_EXT_shader_atomic_float
    exports["VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, sType));
#endif
#ifdef VK_EXT_shader_atomic_float
    exports["VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_shader_atomic_float
    exports["VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_shaderBufferFloat32Atomics_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderBufferFloat32Atomics));
#endif
#ifdef VK_EXT_shader_atomic_float
    exports["VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_shaderBufferFloat32AtomicAdd_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderBufferFloat32AtomicAdd));
#endif
#ifdef VK_EXT_shader_atomic_float
    exports["VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_shaderBufferFloat64Atomics_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderBufferFloat64Atomics));
#endif
#ifdef VK_EXT_shader_atomic_float
    exports["VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_shaderBufferFloat64AtomicAdd_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderBufferFloat64AtomicAdd));
#endif
#ifdef VK_EXT_shader_atomic_float
    exports["VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_shaderSharedFloat32Atomics_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderSharedFloat32Atomics));
#endif
#ifdef VK_EXT_shader_atomic_float
    exports["VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_shaderSharedFloat32AtomicAdd_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderSharedFloat32AtomicAdd));
#endif
#ifdef VK_EXT_shader_atomic_float
    exports["VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_shaderSharedFloat64Atomics_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderSharedFloat64Atomics));
#endif
#ifdef VK_EXT_shader_atomic_float
    exports["VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_shaderSharedFloat64AtomicAdd_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderSharedFloat64AtomicAdd));
#endif
#ifdef VK_EXT_shader_atomic_float
    exports["VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_shaderImageFloat32Atomics_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderImageFloat32Atomics));
#endif
#ifdef VK_EXT_shader_atomic_float
    exports["VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_shaderImageFloat32AtomicAdd_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderImageFloat32AtomicAdd));
#endif
#ifdef VK_EXT_shader_atomic_float
    exports["VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_sparseImageFloat32Atomics_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, sparseImageFloat32Atomics));
#endif
#ifdef VK_EXT_shader_atomic_float
    exports["VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_sparseImageFloat32AtomicAdd_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, sparseImageFloat32AtomicAdd));
#endif
#ifdef VK_EXT_shader_atomic_float
    exports["VkPhysicalDeviceShaderAtomicFloatFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT));
#endif
#ifdef VK_EXT_shader_atomic_float2
    exports["VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, sType));
#endif
#ifdef VK_EXT_shader_atomic_float2
    exports["VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, pNext));
#endif
#ifdef VK_EXT_shader_atomic_float2
    exports["VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT_shaderBufferFloat16Atomics_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderBufferFloat16Atomics));
#endif
#ifdef VK_EXT_shader_atomic_float2
    exports["VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT_shaderBufferFloat16AtomicAdd_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderBufferFloat16AtomicAdd));
#endif
#ifdef VK_EXT_shader_atomic_float2
    exports["VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT_shaderBufferFloat16AtomicMinMax_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderBufferFloat16AtomicMinMax));
#endif
#ifdef VK_EXT_shader_atomic_float2
    exports["VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT_shaderBufferFloat32AtomicMinMax_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderBufferFloat32AtomicMinMax));
#endif
#ifdef VK_EXT_shader_atomic_float2
    exports["VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT_shaderBufferFloat64AtomicMinMax_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderBufferFloat64AtomicMinMax));
#endif
#ifdef VK_EXT_shader_atomic_float2
    exports["VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT_shaderSharedFloat16Atomics_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderSharedFloat16Atomics));
#endif
#ifdef VK_EXT_shader_atomic_float2
    exports["VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT_shaderSharedFloat16AtomicAdd_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderSharedFloat16AtomicAdd));
#endif
#ifdef VK_EXT_shader_atomic_float2
    exports["VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT_shaderSharedFloat16AtomicMinMax_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderSharedFloat16AtomicMinMax));
#endif
#ifdef VK_EXT_shader_atomic_float2
    exports["VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT_shaderSharedFloat32AtomicMinMax_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderSharedFloat32AtomicMinMax));
#endif
#ifdef VK_EXT_shader_atomic_float2
    exports["VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT_shaderSharedFloat64AtomicMinMax_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderSharedFloat64AtomicMinMax));
#endif
#ifdef VK_EXT_shader_atomic_float2
    exports["VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT_shaderImageFloat32AtomicMinMax_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderImageFloat32AtomicMinMax));
#endif
#ifdef VK_EXT_shader_atomic_float2
    exports["VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT_sparseImageFloat32AtomicMinMax_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, sparseImageFloat32AtomicMinMax));
#endif
#ifdef VK_EXT_shader_atomic_float2
    exports["VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT));
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    exports["VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, sType));
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    exports["VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    exports["VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT_vertexAttributeInstanceRateDivisor_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, vertexAttributeInstanceRateDivisor));
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    exports["VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT_vertexAttributeInstanceRateZeroDivisor_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, vertexAttributeInstanceRateZeroDivisor));
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    exports["VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT));
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
    exports["VkQueueFamilyCheckpointPropertiesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyCheckpointPropertiesNV, sType));
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
    exports["VkQueueFamilyCheckpointPropertiesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyCheckpointPropertiesNV, pNext));
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
    exports["VkQueueFamilyCheckpointPropertiesNV_checkpointExecutionStageMask_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyCheckpointPropertiesNV, checkpointExecutionStageMask));
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
    exports["VkQueueFamilyCheckpointPropertiesNV_sizeof"] = Napi::Number::New(env, sizeof(VkQueueFamilyCheckpointPropertiesNV));
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
    exports["VkCheckpointDataNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCheckpointDataNV, sType));
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
    exports["VkCheckpointDataNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCheckpointDataNV, pNext));
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
    exports["VkCheckpointDataNV_stage_offsetof"] = Napi::Number::New(env, offsetof(VkCheckpointDataNV, stage));
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
    exports["VkCheckpointDataNV_pCheckpointMarker_offsetof"] = Napi::Number::New(env, offsetof(VkCheckpointDataNV, pCheckpointMarker));
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
    exports["VkCheckpointDataNV_sizeof"] = Napi::Number::New(env, sizeof(VkCheckpointDataNV));
#endif
    exports["VkPhysicalDeviceDepthStencilResolveProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDepthStencilResolveProperties, sType));
    exports["VkPhysicalDeviceDepthStencilResolveProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDepthStencilResolveProperties, pNext));
    exports["VkPhysicalDeviceDepthStencilResolveProperties_supportedDepthResolveModes_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDepthStencilResolveProperties, supportedDepthResolveModes));
    exports["VkPhysicalDeviceDepthStencilResolveProperties_supportedStencilResolveModes_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDepthStencilResolveProperties, supportedStencilResolveModes));
    exports["VkPhysicalDeviceDepthStencilResolveProperties_independentResolveNone_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDepthStencilResolveProperties, independentResolveNone));
    exports["VkPhysicalDeviceDepthStencilResolveProperties_independentResolve_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDepthStencilResolveProperties, independentResolve));
    exports["VkPhysicalDeviceDepthStencilResolveProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDepthStencilResolveProperties));
#ifdef VK_KHR_depth_stencil_resolve
    exports["VkPhysicalDeviceDepthStencilResolvePropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDepthStencilResolvePropertiesKHR));
#endif
    exports["VkSubpassDescriptionDepthStencilResolve_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescriptionDepthStencilResolve, sType));
    exports["VkSubpassDescriptionDepthStencilResolve_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescriptionDepthStencilResolve, pNext));
    exports["VkSubpassDescriptionDepthStencilResolve_depthResolveMode_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescriptionDepthStencilResolve, depthResolveMode));
    exports["VkSubpassDescriptionDepthStencilResolve_stencilResolveMode_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescriptionDepthStencilResolve, stencilResolveMode));
    exports["VkSubpassDescriptionDepthStencilResolve_pDepthStencilResolveAttachment_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassDescriptionDepthStencilResolve, pDepthStencilResolveAttachment));
    exports["VkSubpassDescriptionDepthStencilResolve_sizeof"] = Napi::Number::New(env, sizeof(VkSubpassDescriptionDepthStencilResolve));
#ifdef VK_KHR_depth_stencil_resolve
    exports["VkSubpassDescriptionDepthStencilResolveKHR_sizeof"] = Napi::Number::New(env, sizeof(VkSubpassDescriptionDepthStencilResolveKHR));
#endif
#ifdef VK_EXT_astc_decode_mode
    exports["VkImageViewASTCDecodeModeEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewASTCDecodeModeEXT, sType));
#endif
#ifdef VK_EXT_astc_decode_mode
    exports["VkImageViewASTCDecodeModeEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewASTCDecodeModeEXT, pNext));
#endif
#ifdef VK_EXT_astc_decode_mode
    exports["VkImageViewASTCDecodeModeEXT_decodeMode_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewASTCDecodeModeEXT, decodeMode));
#endif
#ifdef VK_EXT_astc_decode_mode
    exports["VkImageViewASTCDecodeModeEXT_sizeof"] = Napi::Number::New(env, sizeof(VkImageViewASTCDecodeModeEXT));
#endif
#ifdef VK_EXT_astc_decode_mode
    exports["VkPhysicalDeviceASTCDecodeFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceASTCDecodeFeaturesEXT, sType));
#endif
#ifdef VK_EXT_astc_decode_mode
    exports["VkPhysicalDeviceASTCDecodeFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceASTCDecodeFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_astc_decode_mode
    exports["VkPhysicalDeviceASTCDecodeFeaturesEXT_decodeModeSharedExponent_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceASTCDecodeFeaturesEXT, decodeModeSharedExponent));
#endif
#ifdef VK_EXT_astc_decode_mode
    exports["VkPhysicalDeviceASTCDecodeFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceASTCDecodeFeaturesEXT));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTransformFeedbackFeaturesEXT, sType));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTransformFeedbackFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackFeaturesEXT_transformFeedback_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTransformFeedbackFeaturesEXT, transformFeedback));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackFeaturesEXT_geometryStreams_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTransformFeedbackFeaturesEXT, geometryStreams));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceTransformFeedbackFeaturesEXT));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTransformFeedbackPropertiesEXT, sType));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTransformFeedbackPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackPropertiesEXT_maxTransformFeedbackStreams_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTransformFeedbackPropertiesEXT, maxTransformFeedbackStreams));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackPropertiesEXT_maxTransformFeedbackBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTransformFeedbackPropertiesEXT, maxTransformFeedbackBuffers));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackPropertiesEXT_maxTransformFeedbackBufferSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTransformFeedbackPropertiesEXT, maxTransformFeedbackBufferSize));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackPropertiesEXT_maxTransformFeedbackStreamDataSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTransformFeedbackPropertiesEXT, maxTransformFeedbackStreamDataSize));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackPropertiesEXT_maxTransformFeedbackBufferDataSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTransformFeedbackPropertiesEXT, maxTransformFeedbackBufferDataSize));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackPropertiesEXT_maxTransformFeedbackBufferDataStride_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTransformFeedbackPropertiesEXT, maxTransformFeedbackBufferDataStride));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackPropertiesEXT_transformFeedbackQueries_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTransformFeedbackPropertiesEXT, transformFeedbackQueries));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackPropertiesEXT_transformFeedbackStreamsLinesTriangles_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTransformFeedbackPropertiesEXT, transformFeedbackStreamsLinesTriangles));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackPropertiesEXT_transformFeedbackRasterizationStreamSelect_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTransformFeedbackPropertiesEXT, transformFeedbackRasterizationStreamSelect));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackPropertiesEXT_transformFeedbackDraw_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTransformFeedbackPropertiesEXT, transformFeedbackDraw));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPhysicalDeviceTransformFeedbackPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceTransformFeedbackPropertiesEXT));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPipelineRasterizationStateStreamCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateStreamCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPipelineRasterizationStateStreamCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateStreamCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPipelineRasterizationStateStreamCreateInfoEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateStreamCreateInfoEXT, flags));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPipelineRasterizationStateStreamCreateInfoEXT_rasterizationStream_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationStateStreamCreateInfoEXT, rasterizationStream));
#endif
#ifdef VK_EXT_transform_feedback
    exports["VkPipelineRasterizationStateStreamCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineRasterizationStateStreamCreateInfoEXT));
#endif
#ifdef VK_NV_representative_fragment_test
    exports["VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, sType));
#endif
#ifdef VK_NV_representative_fragment_test
    exports["VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, pNext));
#endif
#ifdef VK_NV_representative_fragment_test
    exports["VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV_representativeFragmentTest_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, representativeFragmentTest));
#endif
#ifdef VK_NV_representative_fragment_test
    exports["VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV));
#endif
#ifdef VK_NV_representative_fragment_test
    exports["VkPipelineRepresentativeFragmentTestStateCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRepresentativeFragmentTestStateCreateInfoNV, sType));
#endif
#ifdef VK_NV_representative_fragment_test
    exports["VkPipelineRepresentativeFragmentTestStateCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRepresentativeFragmentTestStateCreateInfoNV, pNext));
#endif
#ifdef VK_NV_representative_fragment_test
    exports["VkPipelineRepresentativeFragmentTestStateCreateInfoNV_representativeFragmentTestEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRepresentativeFragmentTestStateCreateInfoNV, representativeFragmentTestEnable));
#endif
#ifdef VK_NV_representative_fragment_test
    exports["VkPipelineRepresentativeFragmentTestStateCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineRepresentativeFragmentTestStateCreateInfoNV));
#endif
#ifdef VK_NV_scissor_exclusive
    exports["VkPhysicalDeviceExclusiveScissorFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExclusiveScissorFeaturesNV, sType));
#endif
#ifdef VK_NV_scissor_exclusive
    exports["VkPhysicalDeviceExclusiveScissorFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExclusiveScissorFeaturesNV, pNext));
#endif
#ifdef VK_NV_scissor_exclusive
    exports["VkPhysicalDeviceExclusiveScissorFeaturesNV_exclusiveScissor_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExclusiveScissorFeaturesNV, exclusiveScissor));
#endif
#ifdef VK_NV_scissor_exclusive
    exports["VkPhysicalDeviceExclusiveScissorFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceExclusiveScissorFeaturesNV));
#endif
#ifdef VK_NV_scissor_exclusive
    exports["VkPipelineViewportExclusiveScissorStateCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportExclusiveScissorStateCreateInfoNV, sType));
#endif
#ifdef VK_NV_scissor_exclusive
    exports["VkPipelineViewportExclusiveScissorStateCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportExclusiveScissorStateCreateInfoNV, pNext));
#endif
#ifdef VK_NV_scissor_exclusive
    exports["VkPipelineViewportExclusiveScissorStateCreateInfoNV_exclusiveScissorCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportExclusiveScissorStateCreateInfoNV, exclusiveScissorCount));
#endif
#ifdef VK_NV_scissor_exclusive
    exports["VkPipelineViewportExclusiveScissorStateCreateInfoNV_pExclusiveScissors_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportExclusiveScissorStateCreateInfoNV, pExclusiveScissors));
#endif
#ifdef VK_NV_scissor_exclusive
    exports["VkPipelineViewportExclusiveScissorStateCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineViewportExclusiveScissorStateCreateInfoNV));
#endif
#ifdef VK_NV_corner_sampled_image
    exports["VkPhysicalDeviceCornerSampledImageFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCornerSampledImageFeaturesNV, sType));
#endif
#ifdef VK_NV_corner_sampled_image
    exports["VkPhysicalDeviceCornerSampledImageFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCornerSampledImageFeaturesNV, pNext));
#endif
#ifdef VK_NV_corner_sampled_image
    exports["VkPhysicalDeviceCornerSampledImageFeaturesNV_cornerSampledImage_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCornerSampledImageFeaturesNV, cornerSampledImage));
#endif
#ifdef VK_NV_corner_sampled_image
    exports["VkPhysicalDeviceCornerSampledImageFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceCornerSampledImageFeaturesNV));
#endif
#ifdef VK_NV_compute_shader_derivatives
    exports["VkPhysicalDeviceComputeShaderDerivativesFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, sType));
#endif
#ifdef VK_NV_compute_shader_derivatives
    exports["VkPhysicalDeviceComputeShaderDerivativesFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, pNext));
#endif
#ifdef VK_NV_compute_shader_derivatives
    exports["VkPhysicalDeviceComputeShaderDerivativesFeaturesNV_computeDerivativeGroupQuads_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, computeDerivativeGroupQuads));
#endif
#ifdef VK_NV_compute_shader_derivatives
    exports["VkPhysicalDeviceComputeShaderDerivativesFeaturesNV_computeDerivativeGroupLinear_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, computeDerivativeGroupLinear));
#endif
#ifdef VK_NV_compute_shader_derivatives
    exports["VkPhysicalDeviceComputeShaderDerivativesFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV));
#endif
#ifdef VK_NV_fragment_shader_barycentric
    exports["VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV));
#endif
#ifdef VK_NV_shader_image_footprint
    exports["VkPhysicalDeviceShaderImageFootprintFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderImageFootprintFeaturesNV, sType));
#endif
#ifdef VK_NV_shader_image_footprint
    exports["VkPhysicalDeviceShaderImageFootprintFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderImageFootprintFeaturesNV, pNext));
#endif
#ifdef VK_NV_shader_image_footprint
    exports["VkPhysicalDeviceShaderImageFootprintFeaturesNV_imageFootprint_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderImageFootprintFeaturesNV, imageFootprint));
#endif
#ifdef VK_NV_shader_image_footprint
    exports["VkPhysicalDeviceShaderImageFootprintFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderImageFootprintFeaturesNV));
#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
    exports["VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, sType));
#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
    exports["VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, pNext));
#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
    exports["VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV_dedicatedAllocationImageAliasing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, dedicatedAllocationImageAliasing));
#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
    exports["VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkPhysicalDeviceCopyMemoryIndirectFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV, sType));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkPhysicalDeviceCopyMemoryIndirectFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV, pNext));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkPhysicalDeviceCopyMemoryIndirectFeaturesNV_indirectCopy_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV, indirectCopy));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkPhysicalDeviceCopyMemoryIndirectFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkPhysicalDeviceCopyMemoryIndirectPropertiesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV, sType));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkPhysicalDeviceCopyMemoryIndirectPropertiesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV, pNext));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkPhysicalDeviceCopyMemoryIndirectPropertiesNV_supportedQueues_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV, supportedQueues));
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["VkPhysicalDeviceCopyMemoryIndirectPropertiesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV));
#endif
#ifdef VK_NV_memory_decompression
    exports["VkPhysicalDeviceMemoryDecompressionFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryDecompressionFeaturesNV, sType));
#endif
#ifdef VK_NV_memory_decompression
    exports["VkPhysicalDeviceMemoryDecompressionFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryDecompressionFeaturesNV, pNext));
#endif
#ifdef VK_NV_memory_decompression
    exports["VkPhysicalDeviceMemoryDecompressionFeaturesNV_memoryDecompression_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryDecompressionFeaturesNV, memoryDecompression));
#endif
#ifdef VK_NV_memory_decompression
    exports["VkPhysicalDeviceMemoryDecompressionFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMemoryDecompressionFeaturesNV));
#endif
#ifdef VK_NV_memory_decompression
    exports["VkPhysicalDeviceMemoryDecompressionPropertiesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryDecompressionPropertiesNV, sType));
#endif
#ifdef VK_NV_memory_decompression
    exports["VkPhysicalDeviceMemoryDecompressionPropertiesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryDecompressionPropertiesNV, pNext));
#endif
#ifdef VK_NV_memory_decompression
    exports["VkPhysicalDeviceMemoryDecompressionPropertiesNV_decompressionMethods_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryDecompressionPropertiesNV, decompressionMethods));
#endif
#ifdef VK_NV_memory_decompression
    exports["VkPhysicalDeviceMemoryDecompressionPropertiesNV_maxDecompressionIndirectCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryDecompressionPropertiesNV, maxDecompressionIndirectCount));
#endif
#ifdef VK_NV_memory_decompression
    exports["VkPhysicalDeviceMemoryDecompressionPropertiesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMemoryDecompressionPropertiesNV));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkShadingRatePaletteNV_shadingRatePaletteEntryCount_offsetof"] = Napi::Number::New(env, offsetof(VkShadingRatePaletteNV, shadingRatePaletteEntryCount));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkShadingRatePaletteNV_pShadingRatePaletteEntries_offsetof"] = Napi::Number::New(env, offsetof(VkShadingRatePaletteNV, pShadingRatePaletteEntries));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkShadingRatePaletteNV_sizeof"] = Napi::Number::New(env, sizeof(VkShadingRatePaletteNV));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPipelineViewportShadingRateImageStateCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportShadingRateImageStateCreateInfoNV, sType));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPipelineViewportShadingRateImageStateCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportShadingRateImageStateCreateInfoNV, pNext));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPipelineViewportShadingRateImageStateCreateInfoNV_shadingRateImageEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportShadingRateImageStateCreateInfoNV, shadingRateImageEnable));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPipelineViewportShadingRateImageStateCreateInfoNV_viewportCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportShadingRateImageStateCreateInfoNV, viewportCount));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPipelineViewportShadingRateImageStateCreateInfoNV_pShadingRatePalettes_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportShadingRateImageStateCreateInfoNV, pShadingRatePalettes));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPipelineViewportShadingRateImageStateCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineViewportShadingRateImageStateCreateInfoNV));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPhysicalDeviceShadingRateImageFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShadingRateImageFeaturesNV, sType));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPhysicalDeviceShadingRateImageFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShadingRateImageFeaturesNV, pNext));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPhysicalDeviceShadingRateImageFeaturesNV_shadingRateImage_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShadingRateImageFeaturesNV, shadingRateImage));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPhysicalDeviceShadingRateImageFeaturesNV_shadingRateCoarseSampleOrder_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShadingRateImageFeaturesNV, shadingRateCoarseSampleOrder));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPhysicalDeviceShadingRateImageFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShadingRateImageFeaturesNV));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPhysicalDeviceShadingRateImagePropertiesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShadingRateImagePropertiesNV, sType));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPhysicalDeviceShadingRateImagePropertiesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShadingRateImagePropertiesNV, pNext));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPhysicalDeviceShadingRateImagePropertiesNV_shadingRateTexelSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShadingRateImagePropertiesNV, shadingRateTexelSize));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPhysicalDeviceShadingRateImagePropertiesNV_shadingRatePaletteSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShadingRateImagePropertiesNV, shadingRatePaletteSize));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPhysicalDeviceShadingRateImagePropertiesNV_shadingRateMaxCoarseSamples_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShadingRateImagePropertiesNV, shadingRateMaxCoarseSamples));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPhysicalDeviceShadingRateImagePropertiesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShadingRateImagePropertiesNV));
#endif
#ifdef VK_HUAWEI_invocation_mask
    exports["VkPhysicalDeviceInvocationMaskFeaturesHUAWEI_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI, sType));
#endif
#ifdef VK_HUAWEI_invocation_mask
    exports["VkPhysicalDeviceInvocationMaskFeaturesHUAWEI_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI, pNext));
#endif
#ifdef VK_HUAWEI_invocation_mask
    exports["VkPhysicalDeviceInvocationMaskFeaturesHUAWEI_invocationMask_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI, invocationMask));
#endif
#ifdef VK_HUAWEI_invocation_mask
    exports["VkPhysicalDeviceInvocationMaskFeaturesHUAWEI_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkCoarseSampleLocationNV_pixelX_offsetof"] = Napi::Number::New(env, offsetof(VkCoarseSampleLocationNV, pixelX));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkCoarseSampleLocationNV_pixelY_offsetof"] = Napi::Number::New(env, offsetof(VkCoarseSampleLocationNV, pixelY));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkCoarseSampleLocationNV_sample_offsetof"] = Napi::Number::New(env, offsetof(VkCoarseSampleLocationNV, sample));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkCoarseSampleLocationNV_sizeof"] = Napi::Number::New(env, sizeof(VkCoarseSampleLocationNV));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkCoarseSampleOrderCustomNV_shadingRate_offsetof"] = Napi::Number::New(env, offsetof(VkCoarseSampleOrderCustomNV, shadingRate));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkCoarseSampleOrderCustomNV_sampleCount_offsetof"] = Napi::Number::New(env, offsetof(VkCoarseSampleOrderCustomNV, sampleCount));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkCoarseSampleOrderCustomNV_sampleLocationCount_offsetof"] = Napi::Number::New(env, offsetof(VkCoarseSampleOrderCustomNV, sampleLocationCount));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkCoarseSampleOrderCustomNV_pSampleLocations_offsetof"] = Napi::Number::New(env, offsetof(VkCoarseSampleOrderCustomNV, pSampleLocations));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkCoarseSampleOrderCustomNV_sizeof"] = Napi::Number::New(env, sizeof(VkCoarseSampleOrderCustomNV));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPipelineViewportCoarseSampleOrderStateCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, sType));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPipelineViewportCoarseSampleOrderStateCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, pNext));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPipelineViewportCoarseSampleOrderStateCreateInfoNV_sampleOrderType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, sampleOrderType));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPipelineViewportCoarseSampleOrderStateCreateInfoNV_customSampleOrderCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, customSampleOrderCount));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPipelineViewportCoarseSampleOrderStateCreateInfoNV_pCustomSampleOrders_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, pCustomSampleOrders));
#endif
#ifdef VK_NV_shading_rate_image
    exports["VkPipelineViewportCoarseSampleOrderStateCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderFeaturesNV, sType));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderFeaturesNV, pNext));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderFeaturesNV_taskShader_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderFeaturesNV, taskShader));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderFeaturesNV_meshShader_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderFeaturesNV, meshShader));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMeshShaderFeaturesNV));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, sType));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, pNext));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesNV_maxDrawMeshTasksCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxDrawMeshTasksCount));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesNV_maxTaskWorkGroupInvocations_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxTaskWorkGroupInvocations));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesNV_maxTaskWorkGroupSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxTaskWorkGroupSize));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesNV_maxTaskTotalMemorySize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxTaskTotalMemorySize));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesNV_maxTaskOutputCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxTaskOutputCount));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesNV_maxMeshWorkGroupInvocations_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxMeshWorkGroupInvocations));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesNV_maxMeshWorkGroupSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxMeshWorkGroupSize));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesNV_maxMeshTotalMemorySize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxMeshTotalMemorySize));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesNV_maxMeshOutputVertices_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxMeshOutputVertices));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesNV_maxMeshOutputPrimitives_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxMeshOutputPrimitives));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesNV_maxMeshMultiviewViewCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, maxMeshMultiviewViewCount));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesNV_meshOutputPerVertexGranularity_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, meshOutputPerVertexGranularity));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesNV_meshOutputPerPrimitiveGranularity_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesNV, meshOutputPerPrimitiveGranularity));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMeshShaderPropertiesNV));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkDrawMeshTasksIndirectCommandNV_taskCount_offsetof"] = Napi::Number::New(env, offsetof(VkDrawMeshTasksIndirectCommandNV, taskCount));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkDrawMeshTasksIndirectCommandNV_firstTask_offsetof"] = Napi::Number::New(env, offsetof(VkDrawMeshTasksIndirectCommandNV, firstTask));
#endif
#ifdef VK_NV_mesh_shader
    exports["VkDrawMeshTasksIndirectCommandNV_sizeof"] = Napi::Number::New(env, sizeof(VkDrawMeshTasksIndirectCommandNV));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderFeaturesEXT, sType));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderFeaturesEXT_taskShader_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderFeaturesEXT, taskShader));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderFeaturesEXT_meshShader_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderFeaturesEXT, meshShader));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderFeaturesEXT_multiviewMeshShader_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderFeaturesEXT, multiviewMeshShader));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderFeaturesEXT_primitiveFragmentShadingRateMeshShader_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderFeaturesEXT, primitiveFragmentShadingRateMeshShader));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderFeaturesEXT_meshShaderQueries_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderFeaturesEXT, meshShaderQueries));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMeshShaderFeaturesEXT));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, sType));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxTaskWorkGroupTotalCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxTaskWorkGroupTotalCount));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxTaskWorkGroupCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxTaskWorkGroupCount));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxTaskWorkGroupInvocations_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxTaskWorkGroupInvocations));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxTaskWorkGroupSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxTaskWorkGroupSize));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxTaskPayloadSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxTaskPayloadSize));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxTaskSharedMemorySize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxTaskSharedMemorySize));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxTaskPayloadAndSharedMemorySize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxTaskPayloadAndSharedMemorySize));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxMeshWorkGroupTotalCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxMeshWorkGroupTotalCount));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxMeshWorkGroupCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxMeshWorkGroupCount));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxMeshWorkGroupInvocations_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxMeshWorkGroupInvocations));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxMeshWorkGroupSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxMeshWorkGroupSize));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxMeshSharedMemorySize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxMeshSharedMemorySize));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxMeshPayloadAndSharedMemorySize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxMeshPayloadAndSharedMemorySize));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxMeshOutputMemorySize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxMeshOutputMemorySize));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxMeshPayloadAndOutputMemorySize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxMeshPayloadAndOutputMemorySize));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxMeshOutputComponents_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxMeshOutputComponents));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxMeshOutputVertices_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxMeshOutputVertices));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxMeshOutputPrimitives_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxMeshOutputPrimitives));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxMeshOutputLayers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxMeshOutputLayers));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxMeshMultiviewViewCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxMeshMultiviewViewCount));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_meshOutputPerVertexGranularity_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, meshOutputPerVertexGranularity));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_meshOutputPerPrimitiveGranularity_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, meshOutputPerPrimitiveGranularity));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxPreferredTaskWorkGroupInvocations_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxPreferredTaskWorkGroupInvocations));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_maxPreferredMeshWorkGroupInvocations_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, maxPreferredMeshWorkGroupInvocations));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_prefersLocalInvocationVertexOutput_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, prefersLocalInvocationVertexOutput));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_prefersLocalInvocationPrimitiveOutput_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, prefersLocalInvocationPrimitiveOutput));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_prefersCompactVertexOutput_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, prefersCompactVertexOutput));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_prefersCompactPrimitiveOutput_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMeshShaderPropertiesEXT, prefersCompactPrimitiveOutput));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkPhysicalDeviceMeshShaderPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMeshShaderPropertiesEXT));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkDrawMeshTasksIndirectCommandEXT_groupCountX_offsetof"] = Napi::Number::New(env, offsetof(VkDrawMeshTasksIndirectCommandEXT, groupCountX));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkDrawMeshTasksIndirectCommandEXT_groupCountY_offsetof"] = Napi::Number::New(env, offsetof(VkDrawMeshTasksIndirectCommandEXT, groupCountY));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkDrawMeshTasksIndirectCommandEXT_groupCountZ_offsetof"] = Napi::Number::New(env, offsetof(VkDrawMeshTasksIndirectCommandEXT, groupCountZ));
#endif
#ifdef VK_EXT_mesh_shader
    exports["VkDrawMeshTasksIndirectCommandEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDrawMeshTasksIndirectCommandEXT));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingShaderGroupCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingShaderGroupCreateInfoNV, sType));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingShaderGroupCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingShaderGroupCreateInfoNV, pNext));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingShaderGroupCreateInfoNV_type_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingShaderGroupCreateInfoNV, type));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingShaderGroupCreateInfoNV_generalShader_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingShaderGroupCreateInfoNV, generalShader));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingShaderGroupCreateInfoNV_closestHitShader_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingShaderGroupCreateInfoNV, closestHitShader));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingShaderGroupCreateInfoNV_anyHitShader_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingShaderGroupCreateInfoNV, anyHitShader));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingShaderGroupCreateInfoNV_intersectionShader_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingShaderGroupCreateInfoNV, intersectionShader));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingShaderGroupCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkRayTracingShaderGroupCreateInfoNV));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingShaderGroupCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingShaderGroupCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingShaderGroupCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingShaderGroupCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingShaderGroupCreateInfoKHR_type_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingShaderGroupCreateInfoKHR, type));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingShaderGroupCreateInfoKHR_generalShader_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingShaderGroupCreateInfoKHR, generalShader));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingShaderGroupCreateInfoKHR_closestHitShader_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingShaderGroupCreateInfoKHR, closestHitShader));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingShaderGroupCreateInfoKHR_anyHitShader_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingShaderGroupCreateInfoKHR, anyHitShader));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingShaderGroupCreateInfoKHR_intersectionShader_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingShaderGroupCreateInfoKHR, intersectionShader));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingShaderGroupCreateInfoKHR_pShaderGroupCaptureReplayHandle_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingShaderGroupCreateInfoKHR, pShaderGroupCaptureReplayHandle));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingShaderGroupCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkRayTracingShaderGroupCreateInfoKHR));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingPipelineCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoNV, sType));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingPipelineCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoNV, pNext));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingPipelineCreateInfoNV_flags_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoNV, flags));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingPipelineCreateInfoNV_stageCount_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoNV, stageCount));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingPipelineCreateInfoNV_pStages_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoNV, pStages));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingPipelineCreateInfoNV_groupCount_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoNV, groupCount));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingPipelineCreateInfoNV_pGroups_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoNV, pGroups));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingPipelineCreateInfoNV_maxRecursionDepth_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoNV, maxRecursionDepth));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingPipelineCreateInfoNV_layout_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoNV, layout));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingPipelineCreateInfoNV_basePipelineHandle_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoNV, basePipelineHandle));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingPipelineCreateInfoNV_basePipelineIndex_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoNV, basePipelineIndex));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkRayTracingPipelineCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkRayTracingPipelineCreateInfoNV));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineCreateInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoKHR, flags));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineCreateInfoKHR_stageCount_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoKHR, stageCount));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineCreateInfoKHR_pStages_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoKHR, pStages));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineCreateInfoKHR_groupCount_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoKHR, groupCount));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineCreateInfoKHR_pGroups_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoKHR, pGroups));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineCreateInfoKHR_maxPipelineRayRecursionDepth_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoKHR, maxPipelineRayRecursionDepth));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineCreateInfoKHR_pLibraryInfo_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoKHR, pLibraryInfo));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineCreateInfoKHR_pLibraryInterface_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoKHR, pLibraryInterface));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineCreateInfoKHR_pDynamicState_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoKHR, pDynamicState));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineCreateInfoKHR_layout_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoKHR, layout));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineCreateInfoKHR_basePipelineHandle_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoKHR, basePipelineHandle));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineCreateInfoKHR_basePipelineIndex_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineCreateInfoKHR, basePipelineIndex));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkRayTracingPipelineCreateInfoKHR));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryTrianglesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryTrianglesNV, sType));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryTrianglesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryTrianglesNV, pNext));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryTrianglesNV_vertexData_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryTrianglesNV, vertexData));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryTrianglesNV_vertexOffset_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryTrianglesNV, vertexOffset));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryTrianglesNV_vertexCount_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryTrianglesNV, vertexCount));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryTrianglesNV_vertexStride_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryTrianglesNV, vertexStride));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryTrianglesNV_vertexFormat_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryTrianglesNV, vertexFormat));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryTrianglesNV_indexData_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryTrianglesNV, indexData));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryTrianglesNV_indexOffset_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryTrianglesNV, indexOffset));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryTrianglesNV_indexCount_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryTrianglesNV, indexCount));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryTrianglesNV_indexType_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryTrianglesNV, indexType));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryTrianglesNV_transformData_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryTrianglesNV, transformData));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryTrianglesNV_transformOffset_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryTrianglesNV, transformOffset));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryTrianglesNV_sizeof"] = Napi::Number::New(env, sizeof(VkGeometryTrianglesNV));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryAABBNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryAABBNV, sType));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryAABBNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryAABBNV, pNext));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryAABBNV_aabbData_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryAABBNV, aabbData));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryAABBNV_numAABBs_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryAABBNV, numAABBs));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryAABBNV_stride_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryAABBNV, stride));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryAABBNV_offset_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryAABBNV, offset));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryAABBNV_sizeof"] = Napi::Number::New(env, sizeof(VkGeometryAABBNV));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryDataNV_triangles_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryDataNV, triangles));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryDataNV_aabbs_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryDataNV, aabbs));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryDataNV_sizeof"] = Napi::Number::New(env, sizeof(VkGeometryDataNV));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryNV, sType));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryNV, pNext));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryNV_geometryType_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryNV, geometryType));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryNV_geometry_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryNV, geometry));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryNV_flags_offsetof"] = Napi::Number::New(env, offsetof(VkGeometryNV, flags));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkGeometryNV_sizeof"] = Napi::Number::New(env, sizeof(VkGeometryNV));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureInfoNV, sType));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureInfoNV, pNext));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureInfoNV_type_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureInfoNV, type));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureInfoNV_flags_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureInfoNV, flags));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureInfoNV_instanceCount_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureInfoNV, instanceCount));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureInfoNV_geometryCount_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureInfoNV, geometryCount));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureInfoNV_pGeometries_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureInfoNV, pGeometries));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureInfoNV));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureCreateInfoNV, sType));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureCreateInfoNV, pNext));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureCreateInfoNV_compactedSize_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureCreateInfoNV, compactedSize));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureCreateInfoNV_info_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureCreateInfoNV, info));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureCreateInfoNV));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkBindAccelerationStructureMemoryInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBindAccelerationStructureMemoryInfoNV, sType));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkBindAccelerationStructureMemoryInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBindAccelerationStructureMemoryInfoNV, pNext));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkBindAccelerationStructureMemoryInfoNV_accelerationStructure_offsetof"] = Napi::Number::New(env, offsetof(VkBindAccelerationStructureMemoryInfoNV, accelerationStructure));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkBindAccelerationStructureMemoryInfoNV_memory_offsetof"] = Napi::Number::New(env, offsetof(VkBindAccelerationStructureMemoryInfoNV, memory));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkBindAccelerationStructureMemoryInfoNV_memoryOffset_offsetof"] = Napi::Number::New(env, offsetof(VkBindAccelerationStructureMemoryInfoNV, memoryOffset));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkBindAccelerationStructureMemoryInfoNV_deviceIndexCount_offsetof"] = Napi::Number::New(env, offsetof(VkBindAccelerationStructureMemoryInfoNV, deviceIndexCount));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkBindAccelerationStructureMemoryInfoNV_pDeviceIndices_offsetof"] = Napi::Number::New(env, offsetof(VkBindAccelerationStructureMemoryInfoNV, pDeviceIndices));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkBindAccelerationStructureMemoryInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkBindAccelerationStructureMemoryInfoNV));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkWriteDescriptorSetAccelerationStructureKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSetAccelerationStructureKHR, sType));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkWriteDescriptorSetAccelerationStructureKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSetAccelerationStructureKHR, pNext));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkWriteDescriptorSetAccelerationStructureKHR_accelerationStructureCount_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSetAccelerationStructureKHR, accelerationStructureCount));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkWriteDescriptorSetAccelerationStructureKHR_pAccelerationStructures_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSetAccelerationStructureKHR, pAccelerationStructures));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkWriteDescriptorSetAccelerationStructureKHR_sizeof"] = Napi::Number::New(env, sizeof(VkWriteDescriptorSetAccelerationStructureKHR));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkWriteDescriptorSetAccelerationStructureNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSetAccelerationStructureNV, sType));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkWriteDescriptorSetAccelerationStructureNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSetAccelerationStructureNV, pNext));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkWriteDescriptorSetAccelerationStructureNV_accelerationStructureCount_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSetAccelerationStructureNV, accelerationStructureCount));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkWriteDescriptorSetAccelerationStructureNV_pAccelerationStructures_offsetof"] = Napi::Number::New(env, offsetof(VkWriteDescriptorSetAccelerationStructureNV, pAccelerationStructures));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkWriteDescriptorSetAccelerationStructureNV_sizeof"] = Napi::Number::New(env, sizeof(VkWriteDescriptorSetAccelerationStructureNV));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureMemoryRequirementsInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureMemoryRequirementsInfoNV, sType));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureMemoryRequirementsInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureMemoryRequirementsInfoNV, pNext));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureMemoryRequirementsInfoNV_type_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureMemoryRequirementsInfoNV, type));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureMemoryRequirementsInfoNV_accelerationStructure_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureMemoryRequirementsInfoNV, accelerationStructure));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureMemoryRequirementsInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureMemoryRequirementsInfoNV));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructureFeaturesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAccelerationStructureFeaturesKHR, sType));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructureFeaturesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAccelerationStructureFeaturesKHR, pNext));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructureFeaturesKHR_accelerationStructure_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAccelerationStructureFeaturesKHR, accelerationStructure));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructureFeaturesKHR_accelerationStructureCaptureReplay_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAccelerationStructureFeaturesKHR, accelerationStructureCaptureReplay));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructureFeaturesKHR_accelerationStructureIndirectBuild_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAccelerationStructureFeaturesKHR, accelerationStructureIndirectBuild));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructureFeaturesKHR_accelerationStructureHostCommands_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAccelerationStructureFeaturesKHR, accelerationStructureHostCommands));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructureFeaturesKHR_descriptorBindingAccelerationStructureUpdateAfterBind_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAccelerationStructureFeaturesKHR, descriptorBindingAccelerationStructureUpdateAfterBind));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructureFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceAccelerationStructureFeaturesKHR));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelineFeaturesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPipelineFeaturesKHR, sType));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelineFeaturesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPipelineFeaturesKHR, pNext));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelineFeaturesKHR_rayTracingPipeline_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPipelineFeaturesKHR, rayTracingPipeline));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelineFeaturesKHR_rayTracingPipelineShaderGroupHandleCaptureReplay_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPipelineFeaturesKHR, rayTracingPipelineShaderGroupHandleCaptureReplay));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelineFeaturesKHR_rayTracingPipelineShaderGroupHandleCaptureReplayMixed_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPipelineFeaturesKHR, rayTracingPipelineShaderGroupHandleCaptureReplayMixed));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelineFeaturesKHR_rayTracingPipelineTraceRaysIndirect_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPipelineFeaturesKHR, rayTracingPipelineTraceRaysIndirect));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelineFeaturesKHR_rayTraversalPrimitiveCulling_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPipelineFeaturesKHR, rayTraversalPrimitiveCulling));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelineFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceRayTracingPipelineFeaturesKHR));
#endif
#ifdef VK_KHR_ray_query
    exports["VkPhysicalDeviceRayQueryFeaturesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayQueryFeaturesKHR, sType));
#endif
#ifdef VK_KHR_ray_query
    exports["VkPhysicalDeviceRayQueryFeaturesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayQueryFeaturesKHR, pNext));
#endif
#ifdef VK_KHR_ray_query
    exports["VkPhysicalDeviceRayQueryFeaturesKHR_rayQuery_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayQueryFeaturesKHR, rayQuery));
#endif
#ifdef VK_KHR_ray_query
    exports["VkPhysicalDeviceRayQueryFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceRayQueryFeaturesKHR));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructurePropertiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAccelerationStructurePropertiesKHR, sType));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructurePropertiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAccelerationStructurePropertiesKHR, pNext));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructurePropertiesKHR_maxGeometryCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAccelerationStructurePropertiesKHR, maxGeometryCount));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructurePropertiesKHR_maxInstanceCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAccelerationStructurePropertiesKHR, maxInstanceCount));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructurePropertiesKHR_maxPrimitiveCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAccelerationStructurePropertiesKHR, maxPrimitiveCount));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructurePropertiesKHR_maxPerStageDescriptorAccelerationStructures_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAccelerationStructurePropertiesKHR, maxPerStageDescriptorAccelerationStructures));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructurePropertiesKHR_maxPerStageDescriptorUpdateAfterBindAccelerationStructures_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAccelerationStructurePropertiesKHR, maxPerStageDescriptorUpdateAfterBindAccelerationStructures));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructurePropertiesKHR_maxDescriptorSetAccelerationStructures_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAccelerationStructurePropertiesKHR, maxDescriptorSetAccelerationStructures));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructurePropertiesKHR_maxDescriptorSetUpdateAfterBindAccelerationStructures_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAccelerationStructurePropertiesKHR, maxDescriptorSetUpdateAfterBindAccelerationStructures));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructurePropertiesKHR_minAccelerationStructureScratchOffsetAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAccelerationStructurePropertiesKHR, minAccelerationStructureScratchOffsetAlignment));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkPhysicalDeviceAccelerationStructurePropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceAccelerationStructurePropertiesKHR));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelinePropertiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR, sType));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelinePropertiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR, pNext));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelinePropertiesKHR_shaderGroupHandleSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR, shaderGroupHandleSize));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelinePropertiesKHR_maxRayRecursionDepth_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR, maxRayRecursionDepth));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelinePropertiesKHR_maxShaderGroupStride_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR, maxShaderGroupStride));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelinePropertiesKHR_shaderGroupBaseAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR, shaderGroupBaseAlignment));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelinePropertiesKHR_shaderGroupHandleCaptureReplaySize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR, shaderGroupHandleCaptureReplaySize));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelinePropertiesKHR_maxRayDispatchInvocationCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR, maxRayDispatchInvocationCount));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelinePropertiesKHR_shaderGroupHandleAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR, shaderGroupHandleAlignment));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelinePropertiesKHR_maxRayHitAttributeSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR, maxRayHitAttributeSize));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkPhysicalDeviceRayTracingPipelinePropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkPhysicalDeviceRayTracingPropertiesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPropertiesNV, sType));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkPhysicalDeviceRayTracingPropertiesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPropertiesNV, pNext));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkPhysicalDeviceRayTracingPropertiesNV_shaderGroupHandleSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPropertiesNV, shaderGroupHandleSize));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkPhysicalDeviceRayTracingPropertiesNV_maxRecursionDepth_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPropertiesNV, maxRecursionDepth));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkPhysicalDeviceRayTracingPropertiesNV_maxShaderGroupStride_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPropertiesNV, maxShaderGroupStride));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkPhysicalDeviceRayTracingPropertiesNV_shaderGroupBaseAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPropertiesNV, shaderGroupBaseAlignment));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkPhysicalDeviceRayTracingPropertiesNV_maxGeometryCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPropertiesNV, maxGeometryCount));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkPhysicalDeviceRayTracingPropertiesNV_maxInstanceCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPropertiesNV, maxInstanceCount));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkPhysicalDeviceRayTracingPropertiesNV_maxTriangleCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPropertiesNV, maxTriangleCount));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkPhysicalDeviceRayTracingPropertiesNV_maxDescriptorSetAccelerationStructures_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingPropertiesNV, maxDescriptorSetAccelerationStructures));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkPhysicalDeviceRayTracingPropertiesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceRayTracingPropertiesNV));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkStridedDeviceAddressRegionKHR_deviceAddress_offsetof"] = Napi::Number::New(env, offsetof(VkStridedDeviceAddressRegionKHR, deviceAddress));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkStridedDeviceAddressRegionKHR_stride_offsetof"] = Napi::Number::New(env, offsetof(VkStridedDeviceAddressRegionKHR, stride));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkStridedDeviceAddressRegionKHR_size_offsetof"] = Napi::Number::New(env, offsetof(VkStridedDeviceAddressRegionKHR, size));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkStridedDeviceAddressRegionKHR_sizeof"] = Napi::Number::New(env, sizeof(VkStridedDeviceAddressRegionKHR));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkTraceRaysIndirectCommandKHR_width_offsetof"] = Napi::Number::New(env, offsetof(VkTraceRaysIndirectCommandKHR, width));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkTraceRaysIndirectCommandKHR_height_offsetof"] = Napi::Number::New(env, offsetof(VkTraceRaysIndirectCommandKHR, height));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkTraceRaysIndirectCommandKHR_depth_offsetof"] = Napi::Number::New(env, offsetof(VkTraceRaysIndirectCommandKHR, depth));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkTraceRaysIndirectCommandKHR_sizeof"] = Napi::Number::New(env, sizeof(VkTraceRaysIndirectCommandKHR));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkTraceRaysIndirectCommand2KHR_raygenShaderRecordAddress_offsetof"] = Napi::Number::New(env, offsetof(VkTraceRaysIndirectCommand2KHR, raygenShaderRecordAddress));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkTraceRaysIndirectCommand2KHR_raygenShaderRecordSize_offsetof"] = Napi::Number::New(env, offsetof(VkTraceRaysIndirectCommand2KHR, raygenShaderRecordSize));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkTraceRaysIndirectCommand2KHR_missShaderBindingTableAddress_offsetof"] = Napi::Number::New(env, offsetof(VkTraceRaysIndirectCommand2KHR, missShaderBindingTableAddress));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkTraceRaysIndirectCommand2KHR_missShaderBindingTableSize_offsetof"] = Napi::Number::New(env, offsetof(VkTraceRaysIndirectCommand2KHR, missShaderBindingTableSize));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkTraceRaysIndirectCommand2KHR_missShaderBindingTableStride_offsetof"] = Napi::Number::New(env, offsetof(VkTraceRaysIndirectCommand2KHR, missShaderBindingTableStride));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkTraceRaysIndirectCommand2KHR_hitShaderBindingTableAddress_offsetof"] = Napi::Number::New(env, offsetof(VkTraceRaysIndirectCommand2KHR, hitShaderBindingTableAddress));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkTraceRaysIndirectCommand2KHR_hitShaderBindingTableSize_offsetof"] = Napi::Number::New(env, offsetof(VkTraceRaysIndirectCommand2KHR, hitShaderBindingTableSize));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkTraceRaysIndirectCommand2KHR_hitShaderBindingTableStride_offsetof"] = Napi::Number::New(env, offsetof(VkTraceRaysIndirectCommand2KHR, hitShaderBindingTableStride));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkTraceRaysIndirectCommand2KHR_callableShaderBindingTableAddress_offsetof"] = Napi::Number::New(env, offsetof(VkTraceRaysIndirectCommand2KHR, callableShaderBindingTableAddress));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkTraceRaysIndirectCommand2KHR_callableShaderBindingTableSize_offsetof"] = Napi::Number::New(env, offsetof(VkTraceRaysIndirectCommand2KHR, callableShaderBindingTableSize));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkTraceRaysIndirectCommand2KHR_callableShaderBindingTableStride_offsetof"] = Napi::Number::New(env, offsetof(VkTraceRaysIndirectCommand2KHR, callableShaderBindingTableStride));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkTraceRaysIndirectCommand2KHR_width_offsetof"] = Napi::Number::New(env, offsetof(VkTraceRaysIndirectCommand2KHR, width));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkTraceRaysIndirectCommand2KHR_height_offsetof"] = Napi::Number::New(env, offsetof(VkTraceRaysIndirectCommand2KHR, height));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkTraceRaysIndirectCommand2KHR_depth_offsetof"] = Napi::Number::New(env, offsetof(VkTraceRaysIndirectCommand2KHR, depth));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkTraceRaysIndirectCommand2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkTraceRaysIndirectCommand2KHR));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR, sType));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR, pNext));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR_rayTracingMaintenance1_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR, rayTracingMaintenance1));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR_rayTracingPipelineTraceRaysIndirect2_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR, rayTracingPipelineTraceRaysIndirect2));
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierPropertiesListEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDrmFormatModifierPropertiesListEXT, sType));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierPropertiesListEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDrmFormatModifierPropertiesListEXT, pNext));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierPropertiesListEXT_drmFormatModifierCount_offsetof"] = Napi::Number::New(env, offsetof(VkDrmFormatModifierPropertiesListEXT, drmFormatModifierCount));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierPropertiesListEXT_pDrmFormatModifierProperties_offsetof"] = Napi::Number::New(env, offsetof(VkDrmFormatModifierPropertiesListEXT, pDrmFormatModifierProperties));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierPropertiesListEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDrmFormatModifierPropertiesListEXT));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierPropertiesEXT_drmFormatModifier_offsetof"] = Napi::Number::New(env, offsetof(VkDrmFormatModifierPropertiesEXT, drmFormatModifier));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierPropertiesEXT_drmFormatModifierPlaneCount_offsetof"] = Napi::Number::New(env, offsetof(VkDrmFormatModifierPropertiesEXT, drmFormatModifierPlaneCount));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierPropertiesEXT_drmFormatModifierTilingFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkDrmFormatModifierPropertiesEXT, drmFormatModifierTilingFeatures));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDrmFormatModifierPropertiesEXT));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkPhysicalDeviceImageDrmFormatModifierInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageDrmFormatModifierInfoEXT, sType));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkPhysicalDeviceImageDrmFormatModifierInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageDrmFormatModifierInfoEXT, pNext));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkPhysicalDeviceImageDrmFormatModifierInfoEXT_drmFormatModifier_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageDrmFormatModifierInfoEXT, drmFormatModifier));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkPhysicalDeviceImageDrmFormatModifierInfoEXT_sharingMode_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageDrmFormatModifierInfoEXT, sharingMode));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkPhysicalDeviceImageDrmFormatModifierInfoEXT_queueFamilyIndexCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageDrmFormatModifierInfoEXT, queueFamilyIndexCount));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkPhysicalDeviceImageDrmFormatModifierInfoEXT_pQueueFamilyIndices_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageDrmFormatModifierInfoEXT, pQueueFamilyIndices));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkPhysicalDeviceImageDrmFormatModifierInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceImageDrmFormatModifierInfoEXT));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkImageDrmFormatModifierListCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageDrmFormatModifierListCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkImageDrmFormatModifierListCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageDrmFormatModifierListCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkImageDrmFormatModifierListCreateInfoEXT_drmFormatModifierCount_offsetof"] = Napi::Number::New(env, offsetof(VkImageDrmFormatModifierListCreateInfoEXT, drmFormatModifierCount));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkImageDrmFormatModifierListCreateInfoEXT_pDrmFormatModifiers_offsetof"] = Napi::Number::New(env, offsetof(VkImageDrmFormatModifierListCreateInfoEXT, pDrmFormatModifiers));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkImageDrmFormatModifierListCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkImageDrmFormatModifierListCreateInfoEXT));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkImageDrmFormatModifierExplicitCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageDrmFormatModifierExplicitCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkImageDrmFormatModifierExplicitCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageDrmFormatModifierExplicitCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkImageDrmFormatModifierExplicitCreateInfoEXT_drmFormatModifier_offsetof"] = Napi::Number::New(env, offsetof(VkImageDrmFormatModifierExplicitCreateInfoEXT, drmFormatModifier));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkImageDrmFormatModifierExplicitCreateInfoEXT_drmFormatModifierPlaneCount_offsetof"] = Napi::Number::New(env, offsetof(VkImageDrmFormatModifierExplicitCreateInfoEXT, drmFormatModifierPlaneCount));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkImageDrmFormatModifierExplicitCreateInfoEXT_pPlaneLayouts_offsetof"] = Napi::Number::New(env, offsetof(VkImageDrmFormatModifierExplicitCreateInfoEXT, pPlaneLayouts));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkImageDrmFormatModifierExplicitCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkImageDrmFormatModifierExplicitCreateInfoEXT));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkImageDrmFormatModifierPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageDrmFormatModifierPropertiesEXT, sType));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkImageDrmFormatModifierPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageDrmFormatModifierPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkImageDrmFormatModifierPropertiesEXT_drmFormatModifier_offsetof"] = Napi::Number::New(env, offsetof(VkImageDrmFormatModifierPropertiesEXT, drmFormatModifier));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkImageDrmFormatModifierPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkImageDrmFormatModifierPropertiesEXT));
#endif
    exports["VkImageStencilUsageCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageStencilUsageCreateInfo, sType));
    exports["VkImageStencilUsageCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageStencilUsageCreateInfo, pNext));
    exports["VkImageStencilUsageCreateInfo_stencilUsage_offsetof"] = Napi::Number::New(env, offsetof(VkImageStencilUsageCreateInfo, stencilUsage));
    exports["VkImageStencilUsageCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkImageStencilUsageCreateInfo));
#ifdef VK_EXT_separate_stencil_usage
    exports["VkImageStencilUsageCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkImageStencilUsageCreateInfoEXT));
#endif
#ifdef VK_AMD_memory_overallocation_behavior
    exports["VkDeviceMemoryOverallocationCreateInfoAMD_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceMemoryOverallocationCreateInfoAMD, sType));
#endif
#ifdef VK_AMD_memory_overallocation_behavior
    exports["VkDeviceMemoryOverallocationCreateInfoAMD_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceMemoryOverallocationCreateInfoAMD, pNext));
#endif
#ifdef VK_AMD_memory_overallocation_behavior
    exports["VkDeviceMemoryOverallocationCreateInfoAMD_overallocationBehavior_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceMemoryOverallocationCreateInfoAMD, overallocationBehavior));
#endif
#ifdef VK_AMD_memory_overallocation_behavior
    exports["VkDeviceMemoryOverallocationCreateInfoAMD_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceMemoryOverallocationCreateInfoAMD));
#endif
#ifdef VK_EXT_fragment_density_map
    exports["VkPhysicalDeviceFragmentDensityMapFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMapFeaturesEXT, sType));
#endif
#ifdef VK_EXT_fragment_density_map
    exports["VkPhysicalDeviceFragmentDensityMapFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMapFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_fragment_density_map
    exports["VkPhysicalDeviceFragmentDensityMapFeaturesEXT_fragmentDensityMap_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMapFeaturesEXT, fragmentDensityMap));
#endif
#ifdef VK_EXT_fragment_density_map
    exports["VkPhysicalDeviceFragmentDensityMapFeaturesEXT_fragmentDensityMapDynamic_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMapFeaturesEXT, fragmentDensityMapDynamic));
#endif
#ifdef VK_EXT_fragment_density_map
    exports["VkPhysicalDeviceFragmentDensityMapFeaturesEXT_fragmentDensityMapNonSubsampledImages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMapFeaturesEXT, fragmentDensityMapNonSubsampledImages));
#endif
#ifdef VK_EXT_fragment_density_map
    exports["VkPhysicalDeviceFragmentDensityMapFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFragmentDensityMapFeaturesEXT));
#endif
#ifdef VK_EXT_fragment_density_map2
    exports["VkPhysicalDeviceFragmentDensityMap2FeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, sType));
#endif
#ifdef VK_EXT_fragment_density_map2
    exports["VkPhysicalDeviceFragmentDensityMap2FeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, pNext));
#endif
#ifdef VK_EXT_fragment_density_map2
    exports["VkPhysicalDeviceFragmentDensityMap2FeaturesEXT_fragmentDensityMapDeferred_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, fragmentDensityMapDeferred));
#endif
#ifdef VK_EXT_fragment_density_map2
    exports["VkPhysicalDeviceFragmentDensityMap2FeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT));
#endif
#ifdef VK_QCOM_fragment_density_map_offset
    exports["VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM, sType));
#endif
#ifdef VK_QCOM_fragment_density_map_offset
    exports["VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM, pNext));
#endif
#ifdef VK_QCOM_fragment_density_map_offset
    exports["VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM_fragmentDensityMapOffset_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM, fragmentDensityMapOffset));
#endif
#ifdef VK_QCOM_fragment_density_map_offset
    exports["VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM));
#endif
#ifdef VK_EXT_fragment_density_map
    exports["VkPhysicalDeviceFragmentDensityMapPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMapPropertiesEXT, sType));
#endif
#ifdef VK_EXT_fragment_density_map
    exports["VkPhysicalDeviceFragmentDensityMapPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMapPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_fragment_density_map
    exports["VkPhysicalDeviceFragmentDensityMapPropertiesEXT_minFragmentDensityTexelSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMapPropertiesEXT, minFragmentDensityTexelSize));
#endif
#ifdef VK_EXT_fragment_density_map
    exports["VkPhysicalDeviceFragmentDensityMapPropertiesEXT_maxFragmentDensityTexelSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMapPropertiesEXT, maxFragmentDensityTexelSize));
#endif
#ifdef VK_EXT_fragment_density_map
    exports["VkPhysicalDeviceFragmentDensityMapPropertiesEXT_fragmentDensityInvocations_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMapPropertiesEXT, fragmentDensityInvocations));
#endif
#ifdef VK_EXT_fragment_density_map
    exports["VkPhysicalDeviceFragmentDensityMapPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFragmentDensityMapPropertiesEXT));
#endif
#ifdef VK_EXT_fragment_density_map2
    exports["VkPhysicalDeviceFragmentDensityMap2PropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, sType));
#endif
#ifdef VK_EXT_fragment_density_map2
    exports["VkPhysicalDeviceFragmentDensityMap2PropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, pNext));
#endif
#ifdef VK_EXT_fragment_density_map2
    exports["VkPhysicalDeviceFragmentDensityMap2PropertiesEXT_subsampledLoads_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, subsampledLoads));
#endif
#ifdef VK_EXT_fragment_density_map2
    exports["VkPhysicalDeviceFragmentDensityMap2PropertiesEXT_subsampledCoarseReconstructionEarlyAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, subsampledCoarseReconstructionEarlyAccess));
#endif
#ifdef VK_EXT_fragment_density_map2
    exports["VkPhysicalDeviceFragmentDensityMap2PropertiesEXT_maxSubsampledArrayLayers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, maxSubsampledArrayLayers));
#endif
#ifdef VK_EXT_fragment_density_map2
    exports["VkPhysicalDeviceFragmentDensityMap2PropertiesEXT_maxDescriptorSetSubsampledSamplers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, maxDescriptorSetSubsampledSamplers));
#endif
#ifdef VK_EXT_fragment_density_map2
    exports["VkPhysicalDeviceFragmentDensityMap2PropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT));
#endif
#ifdef VK_QCOM_fragment_density_map_offset
    exports["VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM, sType));
#endif
#ifdef VK_QCOM_fragment_density_map_offset
    exports["VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM, pNext));
#endif
#ifdef VK_QCOM_fragment_density_map_offset
    exports["VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM_fragmentDensityOffsetGranularity_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM, fragmentDensityOffsetGranularity));
#endif
#ifdef VK_QCOM_fragment_density_map_offset
    exports["VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM));
#endif
#ifdef VK_EXT_fragment_density_map
    exports["VkRenderPassFragmentDensityMapCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassFragmentDensityMapCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_fragment_density_map
    exports["VkRenderPassFragmentDensityMapCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassFragmentDensityMapCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_fragment_density_map
    exports["VkRenderPassFragmentDensityMapCreateInfoEXT_fragmentDensityMapAttachment_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassFragmentDensityMapCreateInfoEXT, fragmentDensityMapAttachment));
#endif
#ifdef VK_EXT_fragment_density_map
    exports["VkRenderPassFragmentDensityMapCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassFragmentDensityMapCreateInfoEXT));
#endif
#ifdef VK_QCOM_fragment_density_map_offset
    exports["VkSubpassFragmentDensityMapOffsetEndInfoQCOM_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassFragmentDensityMapOffsetEndInfoQCOM, sType));
#endif
#ifdef VK_QCOM_fragment_density_map_offset
    exports["VkSubpassFragmentDensityMapOffsetEndInfoQCOM_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassFragmentDensityMapOffsetEndInfoQCOM, pNext));
#endif
#ifdef VK_QCOM_fragment_density_map_offset
    exports["VkSubpassFragmentDensityMapOffsetEndInfoQCOM_fragmentDensityOffsetCount_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassFragmentDensityMapOffsetEndInfoQCOM, fragmentDensityOffsetCount));
#endif
#ifdef VK_QCOM_fragment_density_map_offset
    exports["VkSubpassFragmentDensityMapOffsetEndInfoQCOM_pFragmentDensityOffsets_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassFragmentDensityMapOffsetEndInfoQCOM, pFragmentDensityOffsets));
#endif
#ifdef VK_QCOM_fragment_density_map_offset
    exports["VkSubpassFragmentDensityMapOffsetEndInfoQCOM_sizeof"] = Napi::Number::New(env, sizeof(VkSubpassFragmentDensityMapOffsetEndInfoQCOM));
#endif
    exports["VkPhysicalDeviceScalarBlockLayoutFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceScalarBlockLayoutFeatures, sType));
    exports["VkPhysicalDeviceScalarBlockLayoutFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceScalarBlockLayoutFeatures, pNext));
    exports["VkPhysicalDeviceScalarBlockLayoutFeatures_scalarBlockLayout_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceScalarBlockLayoutFeatures, scalarBlockLayout));
    exports["VkPhysicalDeviceScalarBlockLayoutFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceScalarBlockLayoutFeatures));
#ifdef VK_EXT_scalar_block_layout
    exports["VkPhysicalDeviceScalarBlockLayoutFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceScalarBlockLayoutFeaturesEXT));
#endif
#ifdef VK_KHR_surface_protected_capabilities
    exports["VkSurfaceProtectedCapabilitiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceProtectedCapabilitiesKHR, sType));
#endif
#ifdef VK_KHR_surface_protected_capabilities
    exports["VkSurfaceProtectedCapabilitiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceProtectedCapabilitiesKHR, pNext));
#endif
#ifdef VK_KHR_surface_protected_capabilities
    exports["VkSurfaceProtectedCapabilitiesKHR_supportsProtected_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceProtectedCapabilitiesKHR, supportsProtected));
#endif
#ifdef VK_KHR_surface_protected_capabilities
    exports["VkSurfaceProtectedCapabilitiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkSurfaceProtectedCapabilitiesKHR));
#endif
    exports["VkPhysicalDeviceUniformBufferStandardLayoutFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceUniformBufferStandardLayoutFeatures, sType));
    exports["VkPhysicalDeviceUniformBufferStandardLayoutFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceUniformBufferStandardLayoutFeatures, pNext));
    exports["VkPhysicalDeviceUniformBufferStandardLayoutFeatures_uniformBufferStandardLayout_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceUniformBufferStandardLayoutFeatures, uniformBufferStandardLayout));
    exports["VkPhysicalDeviceUniformBufferStandardLayoutFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceUniformBufferStandardLayoutFeatures));
#ifdef VK_KHR_uniform_buffer_standard_layout
    exports["VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR));
#endif
#ifdef VK_EXT_depth_clip_enable
    exports["VkPhysicalDeviceDepthClipEnableFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDepthClipEnableFeaturesEXT, sType));
#endif
#ifdef VK_EXT_depth_clip_enable
    exports["VkPhysicalDeviceDepthClipEnableFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDepthClipEnableFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_depth_clip_enable
    exports["VkPhysicalDeviceDepthClipEnableFeaturesEXT_depthClipEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDepthClipEnableFeaturesEXT, depthClipEnable));
#endif
#ifdef VK_EXT_depth_clip_enable
    exports["VkPhysicalDeviceDepthClipEnableFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDepthClipEnableFeaturesEXT));
#endif
#ifdef VK_EXT_depth_clip_enable
    exports["VkPipelineRasterizationDepthClipStateCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationDepthClipStateCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_depth_clip_enable
    exports["VkPipelineRasterizationDepthClipStateCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationDepthClipStateCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_depth_clip_enable
    exports["VkPipelineRasterizationDepthClipStateCreateInfoEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationDepthClipStateCreateInfoEXT, flags));
#endif
#ifdef VK_EXT_depth_clip_enable
    exports["VkPipelineRasterizationDepthClipStateCreateInfoEXT_depthClipEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationDepthClipStateCreateInfoEXT, depthClipEnable));
#endif
#ifdef VK_EXT_depth_clip_enable
    exports["VkPipelineRasterizationDepthClipStateCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineRasterizationDepthClipStateCreateInfoEXT));
#endif
#ifdef VK_EXT_memory_budget
    exports["VkPhysicalDeviceMemoryBudgetPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryBudgetPropertiesEXT, sType));
#endif
#ifdef VK_EXT_memory_budget
    exports["VkPhysicalDeviceMemoryBudgetPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryBudgetPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_memory_budget
    exports["VkPhysicalDeviceMemoryBudgetPropertiesEXT_heapBudget_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryBudgetPropertiesEXT, heapBudget));
#endif
#ifdef VK_EXT_memory_budget
    exports["VkPhysicalDeviceMemoryBudgetPropertiesEXT_heapUsage_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryBudgetPropertiesEXT, heapUsage));
#endif
#ifdef VK_EXT_memory_budget
    exports["VkPhysicalDeviceMemoryBudgetPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMemoryBudgetPropertiesEXT));
#endif
#ifdef VK_EXT_memory_priority
    exports["VkPhysicalDeviceMemoryPriorityFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryPriorityFeaturesEXT, sType));
#endif
#ifdef VK_EXT_memory_priority
    exports["VkPhysicalDeviceMemoryPriorityFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryPriorityFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_memory_priority
    exports["VkPhysicalDeviceMemoryPriorityFeaturesEXT_memoryPriority_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMemoryPriorityFeaturesEXT, memoryPriority));
#endif
#ifdef VK_EXT_memory_priority
    exports["VkPhysicalDeviceMemoryPriorityFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMemoryPriorityFeaturesEXT));
#endif
#ifdef VK_EXT_memory_priority
    exports["VkMemoryPriorityAllocateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryPriorityAllocateInfoEXT, sType));
#endif
#ifdef VK_EXT_memory_priority
    exports["VkMemoryPriorityAllocateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryPriorityAllocateInfoEXT, pNext));
#endif
#ifdef VK_EXT_memory_priority
    exports["VkMemoryPriorityAllocateInfoEXT_priority_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryPriorityAllocateInfoEXT, priority));
#endif
#ifdef VK_EXT_memory_priority
    exports["VkMemoryPriorityAllocateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryPriorityAllocateInfoEXT));
#endif
#ifdef VK_EXT_pageable_device_local_memory
    exports["VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT, sType));
#endif
#ifdef VK_EXT_pageable_device_local_memory
    exports["VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_pageable_device_local_memory
    exports["VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT_pageableDeviceLocalMemory_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT, pageableDeviceLocalMemory));
#endif
#ifdef VK_EXT_pageable_device_local_memory
    exports["VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT));
#endif
    exports["VkPhysicalDeviceBufferDeviceAddressFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBufferDeviceAddressFeatures, sType));
    exports["VkPhysicalDeviceBufferDeviceAddressFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBufferDeviceAddressFeatures, pNext));
    exports["VkPhysicalDeviceBufferDeviceAddressFeatures_bufferDeviceAddress_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBufferDeviceAddressFeatures, bufferDeviceAddress));
    exports["VkPhysicalDeviceBufferDeviceAddressFeatures_bufferDeviceAddressCaptureReplay_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBufferDeviceAddressFeatures, bufferDeviceAddressCaptureReplay));
    exports["VkPhysicalDeviceBufferDeviceAddressFeatures_bufferDeviceAddressMultiDevice_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBufferDeviceAddressFeatures, bufferDeviceAddressMultiDevice));
    exports["VkPhysicalDeviceBufferDeviceAddressFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceBufferDeviceAddressFeatures));
#ifdef VK_KHR_buffer_device_address
    exports["VkPhysicalDeviceBufferDeviceAddressFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceBufferDeviceAddressFeaturesKHR));
#endif
#ifdef VK_EXT_buffer_device_address
    exports["VkPhysicalDeviceBufferDeviceAddressFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, sType));
#endif
#ifdef VK_EXT_buffer_device_address
    exports["VkPhysicalDeviceBufferDeviceAddressFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_buffer_device_address
    exports["VkPhysicalDeviceBufferDeviceAddressFeaturesEXT_bufferDeviceAddress_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, bufferDeviceAddress));
#endif
#ifdef VK_EXT_buffer_device_address
    exports["VkPhysicalDeviceBufferDeviceAddressFeaturesEXT_bufferDeviceAddressCaptureReplay_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, bufferDeviceAddressCaptureReplay));
#endif
#ifdef VK_EXT_buffer_device_address
    exports["VkPhysicalDeviceBufferDeviceAddressFeaturesEXT_bufferDeviceAddressMultiDevice_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, bufferDeviceAddressMultiDevice));
#endif
#ifdef VK_EXT_buffer_device_address
    exports["VkPhysicalDeviceBufferDeviceAddressFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT));
#endif
#ifdef VK_EXT_buffer_device_address
    exports["VkPhysicalDeviceBufferAddressFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceBufferAddressFeaturesEXT));
#endif
    exports["VkBufferDeviceAddressInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBufferDeviceAddressInfo, sType));
    exports["VkBufferDeviceAddressInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBufferDeviceAddressInfo, pNext));
    exports["VkBufferDeviceAddressInfo_buffer_offsetof"] = Napi::Number::New(env, offsetof(VkBufferDeviceAddressInfo, buffer));
    exports["VkBufferDeviceAddressInfo_sizeof"] = Napi::Number::New(env, sizeof(VkBufferDeviceAddressInfo));
#ifdef VK_KHR_buffer_device_address
    exports["VkBufferDeviceAddressInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkBufferDeviceAddressInfoKHR));
#endif
#ifdef VK_EXT_buffer_device_address
    exports["VkBufferDeviceAddressInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkBufferDeviceAddressInfoEXT));
#endif
    exports["VkBufferOpaqueCaptureAddressCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBufferOpaqueCaptureAddressCreateInfo, sType));
    exports["VkBufferOpaqueCaptureAddressCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBufferOpaqueCaptureAddressCreateInfo, pNext));
    exports["VkBufferOpaqueCaptureAddressCreateInfo_opaqueCaptureAddress_offsetof"] = Napi::Number::New(env, offsetof(VkBufferOpaqueCaptureAddressCreateInfo, opaqueCaptureAddress));
    exports["VkBufferOpaqueCaptureAddressCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkBufferOpaqueCaptureAddressCreateInfo));
#ifdef VK_KHR_buffer_device_address
    exports["VkBufferOpaqueCaptureAddressCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkBufferOpaqueCaptureAddressCreateInfoKHR));
#endif
#ifdef VK_EXT_buffer_device_address
    exports["VkBufferDeviceAddressCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBufferDeviceAddressCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_buffer_device_address
    exports["VkBufferDeviceAddressCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBufferDeviceAddressCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_buffer_device_address
    exports["VkBufferDeviceAddressCreateInfoEXT_deviceAddress_offsetof"] = Napi::Number::New(env, offsetof(VkBufferDeviceAddressCreateInfoEXT, deviceAddress));
#endif
#ifdef VK_EXT_buffer_device_address
    exports["VkBufferDeviceAddressCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkBufferDeviceAddressCreateInfoEXT));
#endif
#ifdef VK_EXT_filter_cubic
    exports["VkPhysicalDeviceImageViewImageFormatInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageViewImageFormatInfoEXT, sType));
#endif
#ifdef VK_EXT_filter_cubic
    exports["VkPhysicalDeviceImageViewImageFormatInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageViewImageFormatInfoEXT, pNext));
#endif
#ifdef VK_EXT_filter_cubic
    exports["VkPhysicalDeviceImageViewImageFormatInfoEXT_imageViewType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageViewImageFormatInfoEXT, imageViewType));
#endif
#ifdef VK_EXT_filter_cubic
    exports["VkPhysicalDeviceImageViewImageFormatInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceImageViewImageFormatInfoEXT));
#endif
#ifdef VK_EXT_filter_cubic
    exports["VkFilterCubicImageViewImageFormatPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkFilterCubicImageViewImageFormatPropertiesEXT, sType));
#endif
#ifdef VK_EXT_filter_cubic
    exports["VkFilterCubicImageViewImageFormatPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkFilterCubicImageViewImageFormatPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_filter_cubic
    exports["VkFilterCubicImageViewImageFormatPropertiesEXT_filterCubic_offsetof"] = Napi::Number::New(env, offsetof(VkFilterCubicImageViewImageFormatPropertiesEXT, filterCubic));
#endif
#ifdef VK_EXT_filter_cubic
    exports["VkFilterCubicImageViewImageFormatPropertiesEXT_filterCubicMinmax_offsetof"] = Napi::Number::New(env, offsetof(VkFilterCubicImageViewImageFormatPropertiesEXT, filterCubicMinmax));
#endif
#ifdef VK_EXT_filter_cubic
    exports["VkFilterCubicImageViewImageFormatPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkFilterCubicImageViewImageFormatPropertiesEXT));
#endif
    exports["VkPhysicalDeviceImagelessFramebufferFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImagelessFramebufferFeatures, sType));
    exports["VkPhysicalDeviceImagelessFramebufferFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImagelessFramebufferFeatures, pNext));
    exports["VkPhysicalDeviceImagelessFramebufferFeatures_imagelessFramebuffer_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImagelessFramebufferFeatures, imagelessFramebuffer));
    exports["VkPhysicalDeviceImagelessFramebufferFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceImagelessFramebufferFeatures));
#ifdef VK_KHR_imageless_framebuffer
    exports["VkPhysicalDeviceImagelessFramebufferFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceImagelessFramebufferFeaturesKHR));
#endif
    exports["VkFramebufferAttachmentsCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferAttachmentsCreateInfo, sType));
    exports["VkFramebufferAttachmentsCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferAttachmentsCreateInfo, pNext));
    exports["VkFramebufferAttachmentsCreateInfo_attachmentImageInfoCount_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferAttachmentsCreateInfo, attachmentImageInfoCount));
    exports["VkFramebufferAttachmentsCreateInfo_pAttachmentImageInfos_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferAttachmentsCreateInfo, pAttachmentImageInfos));
    exports["VkFramebufferAttachmentsCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkFramebufferAttachmentsCreateInfo));
#ifdef VK_KHR_imageless_framebuffer
    exports["VkFramebufferAttachmentsCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkFramebufferAttachmentsCreateInfoKHR));
#endif
    exports["VkFramebufferAttachmentImageInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferAttachmentImageInfo, sType));
    exports["VkFramebufferAttachmentImageInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferAttachmentImageInfo, pNext));
    exports["VkFramebufferAttachmentImageInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferAttachmentImageInfo, flags));
    exports["VkFramebufferAttachmentImageInfo_usage_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferAttachmentImageInfo, usage));
    exports["VkFramebufferAttachmentImageInfo_width_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferAttachmentImageInfo, width));
    exports["VkFramebufferAttachmentImageInfo_height_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferAttachmentImageInfo, height));
    exports["VkFramebufferAttachmentImageInfo_layerCount_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferAttachmentImageInfo, layerCount));
    exports["VkFramebufferAttachmentImageInfo_viewFormatCount_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferAttachmentImageInfo, viewFormatCount));
    exports["VkFramebufferAttachmentImageInfo_pViewFormats_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferAttachmentImageInfo, pViewFormats));
    exports["VkFramebufferAttachmentImageInfo_sizeof"] = Napi::Number::New(env, sizeof(VkFramebufferAttachmentImageInfo));
#ifdef VK_KHR_imageless_framebuffer
    exports["VkFramebufferAttachmentImageInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkFramebufferAttachmentImageInfoKHR));
#endif
    exports["VkRenderPassAttachmentBeginInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassAttachmentBeginInfo, sType));
    exports["VkRenderPassAttachmentBeginInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassAttachmentBeginInfo, pNext));
    exports["VkRenderPassAttachmentBeginInfo_attachmentCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassAttachmentBeginInfo, attachmentCount));
    exports["VkRenderPassAttachmentBeginInfo_pAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassAttachmentBeginInfo, pAttachments));
    exports["VkRenderPassAttachmentBeginInfo_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassAttachmentBeginInfo));
#ifdef VK_KHR_imageless_framebuffer
    exports["VkRenderPassAttachmentBeginInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassAttachmentBeginInfoKHR));
#endif
    exports["VkPhysicalDeviceTextureCompressionASTCHDRFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTextureCompressionASTCHDRFeatures, sType));
    exports["VkPhysicalDeviceTextureCompressionASTCHDRFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTextureCompressionASTCHDRFeatures, pNext));
    exports["VkPhysicalDeviceTextureCompressionASTCHDRFeatures_textureCompressionASTC_HDR_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTextureCompressionASTCHDRFeatures, textureCompressionASTC_HDR));
    exports["VkPhysicalDeviceTextureCompressionASTCHDRFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceTextureCompressionASTCHDRFeatures));
#ifdef VK_EXT_texture_compression_astc_hdr
    exports["VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkPhysicalDeviceCooperativeMatrixFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCooperativeMatrixFeaturesNV, sType));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkPhysicalDeviceCooperativeMatrixFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCooperativeMatrixFeaturesNV, pNext));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkPhysicalDeviceCooperativeMatrixFeaturesNV_cooperativeMatrix_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCooperativeMatrixFeaturesNV, cooperativeMatrix));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkPhysicalDeviceCooperativeMatrixFeaturesNV_cooperativeMatrixRobustBufferAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCooperativeMatrixFeaturesNV, cooperativeMatrixRobustBufferAccess));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkPhysicalDeviceCooperativeMatrixFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceCooperativeMatrixFeaturesNV));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkPhysicalDeviceCooperativeMatrixPropertiesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCooperativeMatrixPropertiesNV, sType));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkPhysicalDeviceCooperativeMatrixPropertiesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCooperativeMatrixPropertiesNV, pNext));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkPhysicalDeviceCooperativeMatrixPropertiesNV_cooperativeMatrixSupportedStages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCooperativeMatrixPropertiesNV, cooperativeMatrixSupportedStages));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkPhysicalDeviceCooperativeMatrixPropertiesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceCooperativeMatrixPropertiesNV));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkCooperativeMatrixPropertiesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCooperativeMatrixPropertiesNV, sType));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkCooperativeMatrixPropertiesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCooperativeMatrixPropertiesNV, pNext));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkCooperativeMatrixPropertiesNV_MSize_offsetof"] = Napi::Number::New(env, offsetof(VkCooperativeMatrixPropertiesNV, MSize));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkCooperativeMatrixPropertiesNV_NSize_offsetof"] = Napi::Number::New(env, offsetof(VkCooperativeMatrixPropertiesNV, NSize));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkCooperativeMatrixPropertiesNV_KSize_offsetof"] = Napi::Number::New(env, offsetof(VkCooperativeMatrixPropertiesNV, KSize));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkCooperativeMatrixPropertiesNV_AType_offsetof"] = Napi::Number::New(env, offsetof(VkCooperativeMatrixPropertiesNV, AType));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkCooperativeMatrixPropertiesNV_BType_offsetof"] = Napi::Number::New(env, offsetof(VkCooperativeMatrixPropertiesNV, BType));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkCooperativeMatrixPropertiesNV_CType_offsetof"] = Napi::Number::New(env, offsetof(VkCooperativeMatrixPropertiesNV, CType));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkCooperativeMatrixPropertiesNV_DType_offsetof"] = Napi::Number::New(env, offsetof(VkCooperativeMatrixPropertiesNV, DType));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkCooperativeMatrixPropertiesNV_scope_offsetof"] = Napi::Number::New(env, offsetof(VkCooperativeMatrixPropertiesNV, scope));
#endif
#ifdef VK_NV_cooperative_matrix
    exports["VkCooperativeMatrixPropertiesNV_sizeof"] = Napi::Number::New(env, sizeof(VkCooperativeMatrixPropertiesNV));
#endif
#ifdef VK_EXT_ycbcr_image_arrays
    exports["VkPhysicalDeviceYcbcrImageArraysFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, sType));
#endif
#ifdef VK_EXT_ycbcr_image_arrays
    exports["VkPhysicalDeviceYcbcrImageArraysFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_ycbcr_image_arrays
    exports["VkPhysicalDeviceYcbcrImageArraysFeaturesEXT_ycbcrImageArrays_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, ycbcrImageArrays));
#endif
#ifdef VK_EXT_ycbcr_image_arrays
    exports["VkPhysicalDeviceYcbcrImageArraysFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT));
#endif
#ifdef VK_NVX_image_view_handle
    exports["VkImageViewHandleInfoNVX_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewHandleInfoNVX, sType));
#endif
#ifdef VK_NVX_image_view_handle
    exports["VkImageViewHandleInfoNVX_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewHandleInfoNVX, pNext));
#endif
#ifdef VK_NVX_image_view_handle
    exports["VkImageViewHandleInfoNVX_imageView_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewHandleInfoNVX, imageView));
#endif
#ifdef VK_NVX_image_view_handle
    exports["VkImageViewHandleInfoNVX_descriptorType_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewHandleInfoNVX, descriptorType));
#endif
#ifdef VK_NVX_image_view_handle
    exports["VkImageViewHandleInfoNVX_sampler_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewHandleInfoNVX, sampler));
#endif
#ifdef VK_NVX_image_view_handle
    exports["VkImageViewHandleInfoNVX_sizeof"] = Napi::Number::New(env, sizeof(VkImageViewHandleInfoNVX));
#endif
#ifdef VK_NVX_image_view_handle
    exports["VkImageViewAddressPropertiesNVX_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewAddressPropertiesNVX, sType));
#endif
#ifdef VK_NVX_image_view_handle
    exports["VkImageViewAddressPropertiesNVX_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewAddressPropertiesNVX, pNext));
#endif
#ifdef VK_NVX_image_view_handle
    exports["VkImageViewAddressPropertiesNVX_deviceAddress_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewAddressPropertiesNVX, deviceAddress));
#endif
#ifdef VK_NVX_image_view_handle
    exports["VkImageViewAddressPropertiesNVX_size_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewAddressPropertiesNVX, size));
#endif
#ifdef VK_NVX_image_view_handle
    exports["VkImageViewAddressPropertiesNVX_sizeof"] = Napi::Number::New(env, sizeof(VkImageViewAddressPropertiesNVX));
#endif
#ifdef VK_GGP_frame_token
    exports["VkPresentFrameTokenGGP_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPresentFrameTokenGGP, sType));
#endif
#ifdef VK_GGP_frame_token
    exports["VkPresentFrameTokenGGP_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPresentFrameTokenGGP, pNext));
#endif
#ifdef VK_GGP_frame_token
    exports["VkPresentFrameTokenGGP_frameToken_offsetof"] = Napi::Number::New(env, offsetof(VkPresentFrameTokenGGP, frameToken));
#endif
#ifdef VK_GGP_frame_token
    exports["VkPresentFrameTokenGGP_sizeof"] = Napi::Number::New(env, sizeof(VkPresentFrameTokenGGP));
#endif
    exports["VkPipelineCreationFeedback_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCreationFeedback, flags));
    exports["VkPipelineCreationFeedback_duration_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCreationFeedback, duration));
    exports["VkPipelineCreationFeedback_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineCreationFeedback));
#ifdef VK_EXT_pipeline_creation_feedback
    exports["VkPipelineCreationFeedbackEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineCreationFeedbackEXT));
#endif
    exports["VkPipelineCreationFeedbackCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCreationFeedbackCreateInfo, sType));
    exports["VkPipelineCreationFeedbackCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCreationFeedbackCreateInfo, pNext));
    exports["VkPipelineCreationFeedbackCreateInfo_pPipelineCreationFeedback_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCreationFeedbackCreateInfo, pPipelineCreationFeedback));
    exports["VkPipelineCreationFeedbackCreateInfo_pipelineStageCreationFeedbackCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCreationFeedbackCreateInfo, pipelineStageCreationFeedbackCount));
    exports["VkPipelineCreationFeedbackCreateInfo_pPipelineStageCreationFeedbacks_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCreationFeedbackCreateInfo, pPipelineStageCreationFeedbacks));
    exports["VkPipelineCreationFeedbackCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineCreationFeedbackCreateInfo));
#ifdef VK_EXT_pipeline_creation_feedback
    exports["VkPipelineCreationFeedbackCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineCreationFeedbackCreateInfoEXT));
#endif
#ifdef VK_EXT_full_screen_exclusive
    exports["VkSurfaceFullScreenExclusiveInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceFullScreenExclusiveInfoEXT, sType));
#endif
#ifdef VK_EXT_full_screen_exclusive
    exports["VkSurfaceFullScreenExclusiveInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceFullScreenExclusiveInfoEXT, pNext));
#endif
#ifdef VK_EXT_full_screen_exclusive
    exports["VkSurfaceFullScreenExclusiveInfoEXT_fullScreenExclusive_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceFullScreenExclusiveInfoEXT, fullScreenExclusive));
#endif
#ifdef VK_EXT_full_screen_exclusive
    exports["VkSurfaceFullScreenExclusiveInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkSurfaceFullScreenExclusiveInfoEXT));
#endif
#ifdef VK_EXT_full_screen_exclusive
    exports["VkSurfaceFullScreenExclusiveWin32InfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceFullScreenExclusiveWin32InfoEXT, sType));
#endif
#ifdef VK_EXT_full_screen_exclusive
    exports["VkSurfaceFullScreenExclusiveWin32InfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceFullScreenExclusiveWin32InfoEXT, pNext));
#endif
#ifdef VK_EXT_full_screen_exclusive
    exports["VkSurfaceFullScreenExclusiveWin32InfoEXT_hmonitor_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceFullScreenExclusiveWin32InfoEXT, hmonitor));
#endif
#ifdef VK_EXT_full_screen_exclusive
    exports["VkSurfaceFullScreenExclusiveWin32InfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkSurfaceFullScreenExclusiveWin32InfoEXT));
#endif
#ifdef VK_EXT_full_screen_exclusive
    exports["VkSurfaceCapabilitiesFullScreenExclusiveEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilitiesFullScreenExclusiveEXT, sType));
#endif
#ifdef VK_EXT_full_screen_exclusive
    exports["VkSurfaceCapabilitiesFullScreenExclusiveEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilitiesFullScreenExclusiveEXT, pNext));
#endif
#ifdef VK_EXT_full_screen_exclusive
    exports["VkSurfaceCapabilitiesFullScreenExclusiveEXT_fullScreenExclusiveSupported_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilitiesFullScreenExclusiveEXT, fullScreenExclusiveSupported));
#endif
#ifdef VK_EXT_full_screen_exclusive
    exports["VkSurfaceCapabilitiesFullScreenExclusiveEXT_sizeof"] = Napi::Number::New(env, sizeof(VkSurfaceCapabilitiesFullScreenExclusiveEXT));
#endif
#ifdef VK_NV_present_barrier
    exports["VkPhysicalDevicePresentBarrierFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePresentBarrierFeaturesNV, sType));
#endif
#ifdef VK_NV_present_barrier
    exports["VkPhysicalDevicePresentBarrierFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePresentBarrierFeaturesNV, pNext));
#endif
#ifdef VK_NV_present_barrier
    exports["VkPhysicalDevicePresentBarrierFeaturesNV_presentBarrier_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePresentBarrierFeaturesNV, presentBarrier));
#endif
#ifdef VK_NV_present_barrier
    exports["VkPhysicalDevicePresentBarrierFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePresentBarrierFeaturesNV));
#endif
#ifdef VK_NV_present_barrier
    exports["VkSurfaceCapabilitiesPresentBarrierNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilitiesPresentBarrierNV, sType));
#endif
#ifdef VK_NV_present_barrier
    exports["VkSurfaceCapabilitiesPresentBarrierNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilitiesPresentBarrierNV, pNext));
#endif
#ifdef VK_NV_present_barrier
    exports["VkSurfaceCapabilitiesPresentBarrierNV_presentBarrierSupported_offsetof"] = Napi::Number::New(env, offsetof(VkSurfaceCapabilitiesPresentBarrierNV, presentBarrierSupported));
#endif
#ifdef VK_NV_present_barrier
    exports["VkSurfaceCapabilitiesPresentBarrierNV_sizeof"] = Napi::Number::New(env, sizeof(VkSurfaceCapabilitiesPresentBarrierNV));
#endif
#ifdef VK_NV_present_barrier
    exports["VkSwapchainPresentBarrierCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainPresentBarrierCreateInfoNV, sType));
#endif
#ifdef VK_NV_present_barrier
    exports["VkSwapchainPresentBarrierCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainPresentBarrierCreateInfoNV, pNext));
#endif
#ifdef VK_NV_present_barrier
    exports["VkSwapchainPresentBarrierCreateInfoNV_presentBarrierEnable_offsetof"] = Napi::Number::New(env, offsetof(VkSwapchainPresentBarrierCreateInfoNV, presentBarrierEnable));
#endif
#ifdef VK_NV_present_barrier
    exports["VkSwapchainPresentBarrierCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkSwapchainPresentBarrierCreateInfoNV));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPhysicalDevicePerformanceQueryFeaturesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePerformanceQueryFeaturesKHR, sType));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPhysicalDevicePerformanceQueryFeaturesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePerformanceQueryFeaturesKHR, pNext));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPhysicalDevicePerformanceQueryFeaturesKHR_performanceCounterQueryPools_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePerformanceQueryFeaturesKHR, performanceCounterQueryPools));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPhysicalDevicePerformanceQueryFeaturesKHR_performanceCounterMultipleQueryPools_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePerformanceQueryFeaturesKHR, performanceCounterMultipleQueryPools));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPhysicalDevicePerformanceQueryFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePerformanceQueryFeaturesKHR));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPhysicalDevicePerformanceQueryPropertiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePerformanceQueryPropertiesKHR, sType));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPhysicalDevicePerformanceQueryPropertiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePerformanceQueryPropertiesKHR, pNext));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPhysicalDevicePerformanceQueryPropertiesKHR_allowCommandBufferQueryCopies_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePerformanceQueryPropertiesKHR, allowCommandBufferQueryCopies));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPhysicalDevicePerformanceQueryPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePerformanceQueryPropertiesKHR));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceCounterKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceCounterKHR, sType));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceCounterKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceCounterKHR, pNext));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceCounterKHR_unit_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceCounterKHR, unit));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceCounterKHR_scope_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceCounterKHR, scope));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceCounterKHR_storage_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceCounterKHR, storage));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceCounterKHR_uuid_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceCounterKHR, uuid));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceCounterKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPerformanceCounterKHR));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceCounterDescriptionKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceCounterDescriptionKHR, sType));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceCounterDescriptionKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceCounterDescriptionKHR, pNext));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceCounterDescriptionKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceCounterDescriptionKHR, flags));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceCounterDescriptionKHR_name_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceCounterDescriptionKHR, name));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceCounterDescriptionKHR_category_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceCounterDescriptionKHR, category));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceCounterDescriptionKHR_description_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceCounterDescriptionKHR, description));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceCounterDescriptionKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPerformanceCounterDescriptionKHR));
#endif
#ifdef VK_KHR_performance_query
    exports["VkQueryPoolPerformanceCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkQueryPoolPerformanceCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_performance_query
    exports["VkQueryPoolPerformanceCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkQueryPoolPerformanceCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_performance_query
    exports["VkQueryPoolPerformanceCreateInfoKHR_queueFamilyIndex_offsetof"] = Napi::Number::New(env, offsetof(VkQueryPoolPerformanceCreateInfoKHR, queueFamilyIndex));
#endif
#ifdef VK_KHR_performance_query
    exports["VkQueryPoolPerformanceCreateInfoKHR_counterIndexCount_offsetof"] = Napi::Number::New(env, offsetof(VkQueryPoolPerformanceCreateInfoKHR, counterIndexCount));
#endif
#ifdef VK_KHR_performance_query
    exports["VkQueryPoolPerformanceCreateInfoKHR_pCounterIndices_offsetof"] = Napi::Number::New(env, offsetof(VkQueryPoolPerformanceCreateInfoKHR, pCounterIndices));
#endif
#ifdef VK_KHR_performance_query
    exports["VkQueryPoolPerformanceCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkQueryPoolPerformanceCreateInfoKHR));
#endif
#ifdef VK_KHR_performance_query
    exports["VkAcquireProfilingLockInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAcquireProfilingLockInfoKHR, sType));
#endif
#ifdef VK_KHR_performance_query
    exports["VkAcquireProfilingLockInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAcquireProfilingLockInfoKHR, pNext));
#endif
#ifdef VK_KHR_performance_query
    exports["VkAcquireProfilingLockInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkAcquireProfilingLockInfoKHR, flags));
#endif
#ifdef VK_KHR_performance_query
    exports["VkAcquireProfilingLockInfoKHR_timeout_offsetof"] = Napi::Number::New(env, offsetof(VkAcquireProfilingLockInfoKHR, timeout));
#endif
#ifdef VK_KHR_performance_query
    exports["VkAcquireProfilingLockInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkAcquireProfilingLockInfoKHR));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceQuerySubmitInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceQuerySubmitInfoKHR, sType));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceQuerySubmitInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceQuerySubmitInfoKHR, pNext));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceQuerySubmitInfoKHR_counterPassIndex_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceQuerySubmitInfoKHR, counterPassIndex));
#endif
#ifdef VK_KHR_performance_query
    exports["VkPerformanceQuerySubmitInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPerformanceQuerySubmitInfoKHR));
#endif
#ifdef VK_EXT_headless_surface
    exports["VkHeadlessSurfaceCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkHeadlessSurfaceCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_headless_surface
    exports["VkHeadlessSurfaceCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkHeadlessSurfaceCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_headless_surface
    exports["VkHeadlessSurfaceCreateInfoEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkHeadlessSurfaceCreateInfoEXT, flags));
#endif
#ifdef VK_EXT_headless_surface
    exports["VkHeadlessSurfaceCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkHeadlessSurfaceCreateInfoEXT));
#endif
#ifdef VK_NV_coverage_reduction_mode
    exports["VkPhysicalDeviceCoverageReductionModeFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCoverageReductionModeFeaturesNV, sType));
#endif
#ifdef VK_NV_coverage_reduction_mode
    exports["VkPhysicalDeviceCoverageReductionModeFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCoverageReductionModeFeaturesNV, pNext));
#endif
#ifdef VK_NV_coverage_reduction_mode
    exports["VkPhysicalDeviceCoverageReductionModeFeaturesNV_coverageReductionMode_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCoverageReductionModeFeaturesNV, coverageReductionMode));
#endif
#ifdef VK_NV_coverage_reduction_mode
    exports["VkPhysicalDeviceCoverageReductionModeFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceCoverageReductionModeFeaturesNV));
#endif
#ifdef VK_NV_coverage_reduction_mode
    exports["VkPipelineCoverageReductionStateCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCoverageReductionStateCreateInfoNV, sType));
#endif
#ifdef VK_NV_coverage_reduction_mode
    exports["VkPipelineCoverageReductionStateCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCoverageReductionStateCreateInfoNV, pNext));
#endif
#ifdef VK_NV_coverage_reduction_mode
    exports["VkPipelineCoverageReductionStateCreateInfoNV_flags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCoverageReductionStateCreateInfoNV, flags));
#endif
#ifdef VK_NV_coverage_reduction_mode
    exports["VkPipelineCoverageReductionStateCreateInfoNV_coverageReductionMode_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCoverageReductionStateCreateInfoNV, coverageReductionMode));
#endif
#ifdef VK_NV_coverage_reduction_mode
    exports["VkPipelineCoverageReductionStateCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineCoverageReductionStateCreateInfoNV));
#endif
#ifdef VK_NV_coverage_reduction_mode
    exports["VkFramebufferMixedSamplesCombinationNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferMixedSamplesCombinationNV, sType));
#endif
#ifdef VK_NV_coverage_reduction_mode
    exports["VkFramebufferMixedSamplesCombinationNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferMixedSamplesCombinationNV, pNext));
#endif
#ifdef VK_NV_coverage_reduction_mode
    exports["VkFramebufferMixedSamplesCombinationNV_coverageReductionMode_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferMixedSamplesCombinationNV, coverageReductionMode));
#endif
#ifdef VK_NV_coverage_reduction_mode
    exports["VkFramebufferMixedSamplesCombinationNV_rasterizationSamples_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferMixedSamplesCombinationNV, rasterizationSamples));
#endif
#ifdef VK_NV_coverage_reduction_mode
    exports["VkFramebufferMixedSamplesCombinationNV_depthStencilSamples_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferMixedSamplesCombinationNV, depthStencilSamples));
#endif
#ifdef VK_NV_coverage_reduction_mode
    exports["VkFramebufferMixedSamplesCombinationNV_colorSamples_offsetof"] = Napi::Number::New(env, offsetof(VkFramebufferMixedSamplesCombinationNV, colorSamples));
#endif
#ifdef VK_NV_coverage_reduction_mode
    exports["VkFramebufferMixedSamplesCombinationNV_sizeof"] = Napi::Number::New(env, sizeof(VkFramebufferMixedSamplesCombinationNV));
#endif
#ifdef VK_INTEL_shader_integer_functions2
    exports["VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, sType));
#endif
#ifdef VK_INTEL_shader_integer_functions2
    exports["VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, pNext));
#endif
#ifdef VK_INTEL_shader_integer_functions2
    exports["VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL_shaderIntegerFunctions2_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, shaderIntegerFunctions2));
#endif
#ifdef VK_INTEL_shader_integer_functions2
    exports["VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceValueINTEL_type_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceValueINTEL, type));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceValueINTEL_data_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceValueINTEL, data));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceValueINTEL_sizeof"] = Napi::Number::New(env, sizeof(VkPerformanceValueINTEL));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkInitializePerformanceApiInfoINTEL_sType_offsetof"] = Napi::Number::New(env, offsetof(VkInitializePerformanceApiInfoINTEL, sType));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkInitializePerformanceApiInfoINTEL_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkInitializePerformanceApiInfoINTEL, pNext));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkInitializePerformanceApiInfoINTEL_pUserData_offsetof"] = Napi::Number::New(env, offsetof(VkInitializePerformanceApiInfoINTEL, pUserData));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkInitializePerformanceApiInfoINTEL_sizeof"] = Napi::Number::New(env, sizeof(VkInitializePerformanceApiInfoINTEL));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkQueryPoolPerformanceQueryCreateInfoINTEL_sType_offsetof"] = Napi::Number::New(env, offsetof(VkQueryPoolPerformanceQueryCreateInfoINTEL, sType));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkQueryPoolPerformanceQueryCreateInfoINTEL_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkQueryPoolPerformanceQueryCreateInfoINTEL, pNext));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkQueryPoolPerformanceQueryCreateInfoINTEL_performanceCountersSampling_offsetof"] = Napi::Number::New(env, offsetof(VkQueryPoolPerformanceQueryCreateInfoINTEL, performanceCountersSampling));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkQueryPoolPerformanceQueryCreateInfoINTEL_sizeof"] = Napi::Number::New(env, sizeof(VkQueryPoolPerformanceQueryCreateInfoINTEL));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkQueryPoolCreateInfoINTEL_sizeof"] = Napi::Number::New(env, sizeof(VkQueryPoolCreateInfoINTEL));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceMarkerInfoINTEL_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceMarkerInfoINTEL, sType));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceMarkerInfoINTEL_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceMarkerInfoINTEL, pNext));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceMarkerInfoINTEL_marker_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceMarkerInfoINTEL, marker));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceMarkerInfoINTEL_sizeof"] = Napi::Number::New(env, sizeof(VkPerformanceMarkerInfoINTEL));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceStreamMarkerInfoINTEL_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceStreamMarkerInfoINTEL, sType));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceStreamMarkerInfoINTEL_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceStreamMarkerInfoINTEL, pNext));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceStreamMarkerInfoINTEL_marker_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceStreamMarkerInfoINTEL, marker));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceStreamMarkerInfoINTEL_sizeof"] = Napi::Number::New(env, sizeof(VkPerformanceStreamMarkerInfoINTEL));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceOverrideInfoINTEL_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceOverrideInfoINTEL, sType));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceOverrideInfoINTEL_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceOverrideInfoINTEL, pNext));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceOverrideInfoINTEL_type_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceOverrideInfoINTEL, type));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceOverrideInfoINTEL_enable_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceOverrideInfoINTEL, enable));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceOverrideInfoINTEL_parameter_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceOverrideInfoINTEL, parameter));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceOverrideInfoINTEL_sizeof"] = Napi::Number::New(env, sizeof(VkPerformanceOverrideInfoINTEL));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceConfigurationAcquireInfoINTEL_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceConfigurationAcquireInfoINTEL, sType));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceConfigurationAcquireInfoINTEL_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceConfigurationAcquireInfoINTEL, pNext));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceConfigurationAcquireInfoINTEL_type_offsetof"] = Napi::Number::New(env, offsetof(VkPerformanceConfigurationAcquireInfoINTEL, type));
#endif
#ifdef VK_INTEL_performance_query
    exports["VkPerformanceConfigurationAcquireInfoINTEL_sizeof"] = Napi::Number::New(env, sizeof(VkPerformanceConfigurationAcquireInfoINTEL));
#endif
#ifdef VK_KHR_shader_clock
    exports["VkPhysicalDeviceShaderClockFeaturesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderClockFeaturesKHR, sType));
#endif
#ifdef VK_KHR_shader_clock
    exports["VkPhysicalDeviceShaderClockFeaturesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderClockFeaturesKHR, pNext));
#endif
#ifdef VK_KHR_shader_clock
    exports["VkPhysicalDeviceShaderClockFeaturesKHR_shaderSubgroupClock_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderClockFeaturesKHR, shaderSubgroupClock));
#endif
#ifdef VK_KHR_shader_clock
    exports["VkPhysicalDeviceShaderClockFeaturesKHR_shaderDeviceClock_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderClockFeaturesKHR, shaderDeviceClock));
#endif
#ifdef VK_KHR_shader_clock
    exports["VkPhysicalDeviceShaderClockFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderClockFeaturesKHR));
#endif
#ifdef VK_EXT_index_type_uint8
    exports["VkPhysicalDeviceIndexTypeUint8FeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceIndexTypeUint8FeaturesEXT, sType));
#endif
#ifdef VK_EXT_index_type_uint8
    exports["VkPhysicalDeviceIndexTypeUint8FeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceIndexTypeUint8FeaturesEXT, pNext));
#endif
#ifdef VK_EXT_index_type_uint8
    exports["VkPhysicalDeviceIndexTypeUint8FeaturesEXT_indexTypeUint8_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceIndexTypeUint8FeaturesEXT, indexTypeUint8));
#endif
#ifdef VK_EXT_index_type_uint8
    exports["VkPhysicalDeviceIndexTypeUint8FeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceIndexTypeUint8FeaturesEXT));
#endif
#ifdef VK_NV_shader_sm_builtins
    exports["VkPhysicalDeviceShaderSMBuiltinsPropertiesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV, sType));
#endif
#ifdef VK_NV_shader_sm_builtins
    exports["VkPhysicalDeviceShaderSMBuiltinsPropertiesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV, pNext));
#endif
#ifdef VK_NV_shader_sm_builtins
    exports["VkPhysicalDeviceShaderSMBuiltinsPropertiesNV_shaderSMCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV, shaderSMCount));
#endif
#ifdef VK_NV_shader_sm_builtins
    exports["VkPhysicalDeviceShaderSMBuiltinsPropertiesNV_shaderWarpsPerSM_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV, shaderWarpsPerSM));
#endif
#ifdef VK_NV_shader_sm_builtins
    exports["VkPhysicalDeviceShaderSMBuiltinsPropertiesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV));
#endif
#ifdef VK_NV_shader_sm_builtins
    exports["VkPhysicalDeviceShaderSMBuiltinsFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV, sType));
#endif
#ifdef VK_NV_shader_sm_builtins
    exports["VkPhysicalDeviceShaderSMBuiltinsFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV, pNext));
#endif
#ifdef VK_NV_shader_sm_builtins
    exports["VkPhysicalDeviceShaderSMBuiltinsFeaturesNV_shaderSMBuiltins_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV, shaderSMBuiltins));
#endif
#ifdef VK_NV_shader_sm_builtins
    exports["VkPhysicalDeviceShaderSMBuiltinsFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV));
#endif
#ifdef VK_EXT_fragment_shader_interlock
    exports["VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, sType));
#endif
#ifdef VK_EXT_fragment_shader_interlock
    exports["VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_fragment_shader_interlock
    exports["VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT_fragmentShaderSampleInterlock_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, fragmentShaderSampleInterlock));
#endif
#ifdef VK_EXT_fragment_shader_interlock
    exports["VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT_fragmentShaderPixelInterlock_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, fragmentShaderPixelInterlock));
#endif
#ifdef VK_EXT_fragment_shader_interlock
    exports["VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT_fragmentShaderShadingRateInterlock_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, fragmentShaderShadingRateInterlock));
#endif
#ifdef VK_EXT_fragment_shader_interlock
    exports["VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT));
#endif
    exports["VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, sType));
    exports["VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, pNext));
    exports["VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures_separateDepthStencilLayouts_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, separateDepthStencilLayouts));
    exports["VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures));
#ifdef VK_KHR_separate_depth_stencil_layouts
    exports["VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR));
#endif
    exports["VkAttachmentReferenceStencilLayout_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentReferenceStencilLayout, sType));
    exports["VkAttachmentReferenceStencilLayout_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentReferenceStencilLayout, pNext));
    exports["VkAttachmentReferenceStencilLayout_stencilLayout_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentReferenceStencilLayout, stencilLayout));
    exports["VkAttachmentReferenceStencilLayout_sizeof"] = Napi::Number::New(env, sizeof(VkAttachmentReferenceStencilLayout));
#ifdef VK_EXT_primitive_topology_list_restart
    exports["VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT, sType));
#endif
#ifdef VK_EXT_primitive_topology_list_restart
    exports["VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_primitive_topology_list_restart
    exports["VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT_primitiveTopologyListRestart_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT, primitiveTopologyListRestart));
#endif
#ifdef VK_EXT_primitive_topology_list_restart
    exports["VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT_primitiveTopologyPatchListRestart_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT, primitiveTopologyPatchListRestart));
#endif
#ifdef VK_EXT_primitive_topology_list_restart
    exports["VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT));
#endif
#ifdef VK_KHR_separate_depth_stencil_layouts
    exports["VkAttachmentReferenceStencilLayoutKHR_sizeof"] = Napi::Number::New(env, sizeof(VkAttachmentReferenceStencilLayoutKHR));
#endif
    exports["VkAttachmentDescriptionStencilLayout_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescriptionStencilLayout, sType));
    exports["VkAttachmentDescriptionStencilLayout_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescriptionStencilLayout, pNext));
    exports["VkAttachmentDescriptionStencilLayout_stencilInitialLayout_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescriptionStencilLayout, stencilInitialLayout));
    exports["VkAttachmentDescriptionStencilLayout_stencilFinalLayout_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentDescriptionStencilLayout, stencilFinalLayout));
    exports["VkAttachmentDescriptionStencilLayout_sizeof"] = Napi::Number::New(env, sizeof(VkAttachmentDescriptionStencilLayout));
#ifdef VK_KHR_separate_depth_stencil_layouts
    exports["VkAttachmentDescriptionStencilLayoutKHR_sizeof"] = Napi::Number::New(env, sizeof(VkAttachmentDescriptionStencilLayoutKHR));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, sType));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, pNext));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR_pipelineExecutableInfo_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, pipelineExecutableInfo));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineInfoKHR, sType));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineInfoKHR, pNext));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineInfoKHR_pipeline_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineInfoKHR, pipeline));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineInfoKHR));
#endif
#ifdef VK_EXT_pipeline_properties
    exports["VkPipelineInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineInfoEXT));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutablePropertiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutablePropertiesKHR, sType));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutablePropertiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutablePropertiesKHR, pNext));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutablePropertiesKHR_stages_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutablePropertiesKHR, stages));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutablePropertiesKHR_name_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutablePropertiesKHR, name));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutablePropertiesKHR_description_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutablePropertiesKHR, description));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutablePropertiesKHR_subgroupSize_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutablePropertiesKHR, subgroupSize));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutablePropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineExecutablePropertiesKHR));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutableInfoKHR, sType));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutableInfoKHR, pNext));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableInfoKHR_pipeline_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutableInfoKHR, pipeline));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableInfoKHR_executableIndex_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutableInfoKHR, executableIndex));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineExecutableInfoKHR));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableStatisticKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutableStatisticKHR, sType));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableStatisticKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutableStatisticKHR, pNext));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableStatisticKHR_name_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutableStatisticKHR, name));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableStatisticKHR_description_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutableStatisticKHR, description));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableStatisticKHR_format_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutableStatisticKHR, format));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableStatisticKHR_value_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutableStatisticKHR, value));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableStatisticKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineExecutableStatisticKHR));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableInternalRepresentationKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutableInternalRepresentationKHR, sType));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableInternalRepresentationKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutableInternalRepresentationKHR, pNext));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableInternalRepresentationKHR_name_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutableInternalRepresentationKHR, name));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableInternalRepresentationKHR_description_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutableInternalRepresentationKHR, description));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableInternalRepresentationKHR_isText_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutableInternalRepresentationKHR, isText));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableInternalRepresentationKHR_dataSize_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutableInternalRepresentationKHR, dataSize));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableInternalRepresentationKHR_pData_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineExecutableInternalRepresentationKHR, pData));
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["VkPipelineExecutableInternalRepresentationKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineExecutableInternalRepresentationKHR));
#endif
    exports["VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures, sType));
    exports["VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures, pNext));
    exports["VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures_shaderDemoteToHelperInvocation_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures, shaderDemoteToHelperInvocation));
    exports["VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures));
#ifdef VK_EXT_shader_demote_to_helper_invocation
    exports["VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT));
#endif
#ifdef VK_EXT_texel_buffer_alignment
    exports["VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, sType));
#endif
#ifdef VK_EXT_texel_buffer_alignment
    exports["VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_texel_buffer_alignment
    exports["VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT_texelBufferAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, texelBufferAlignment));
#endif
#ifdef VK_EXT_texel_buffer_alignment
    exports["VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT));
#endif
    exports["VkPhysicalDeviceTexelBufferAlignmentProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTexelBufferAlignmentProperties, sType));
    exports["VkPhysicalDeviceTexelBufferAlignmentProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTexelBufferAlignmentProperties, pNext));
    exports["VkPhysicalDeviceTexelBufferAlignmentProperties_storageTexelBufferOffsetAlignmentBytes_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTexelBufferAlignmentProperties, storageTexelBufferOffsetAlignmentBytes));
    exports["VkPhysicalDeviceTexelBufferAlignmentProperties_storageTexelBufferOffsetSingleTexelAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTexelBufferAlignmentProperties, storageTexelBufferOffsetSingleTexelAlignment));
    exports["VkPhysicalDeviceTexelBufferAlignmentProperties_uniformTexelBufferOffsetAlignmentBytes_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTexelBufferAlignmentProperties, uniformTexelBufferOffsetAlignmentBytes));
    exports["VkPhysicalDeviceTexelBufferAlignmentProperties_uniformTexelBufferOffsetSingleTexelAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTexelBufferAlignmentProperties, uniformTexelBufferOffsetSingleTexelAlignment));
    exports["VkPhysicalDeviceTexelBufferAlignmentProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceTexelBufferAlignmentProperties));
#ifdef VK_EXT_texel_buffer_alignment
    exports["VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT));
#endif
    exports["VkPhysicalDeviceSubgroupSizeControlFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubgroupSizeControlFeatures, sType));
    exports["VkPhysicalDeviceSubgroupSizeControlFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubgroupSizeControlFeatures, pNext));
    exports["VkPhysicalDeviceSubgroupSizeControlFeatures_subgroupSizeControl_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubgroupSizeControlFeatures, subgroupSizeControl));
    exports["VkPhysicalDeviceSubgroupSizeControlFeatures_computeFullSubgroups_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubgroupSizeControlFeatures, computeFullSubgroups));
    exports["VkPhysicalDeviceSubgroupSizeControlFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSubgroupSizeControlFeatures));
#ifdef VK_EXT_subgroup_size_control
    exports["VkPhysicalDeviceSubgroupSizeControlFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSubgroupSizeControlFeaturesEXT));
#endif
    exports["VkPhysicalDeviceSubgroupSizeControlProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubgroupSizeControlProperties, sType));
    exports["VkPhysicalDeviceSubgroupSizeControlProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubgroupSizeControlProperties, pNext));
    exports["VkPhysicalDeviceSubgroupSizeControlProperties_minSubgroupSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubgroupSizeControlProperties, minSubgroupSize));
    exports["VkPhysicalDeviceSubgroupSizeControlProperties_maxSubgroupSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubgroupSizeControlProperties, maxSubgroupSize));
    exports["VkPhysicalDeviceSubgroupSizeControlProperties_maxComputeWorkgroupSubgroups_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubgroupSizeControlProperties, maxComputeWorkgroupSubgroups));
    exports["VkPhysicalDeviceSubgroupSizeControlProperties_requiredSubgroupSizeStages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubgroupSizeControlProperties, requiredSubgroupSizeStages));
    exports["VkPhysicalDeviceSubgroupSizeControlProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSubgroupSizeControlProperties));
#ifdef VK_EXT_subgroup_size_control
    exports["VkPhysicalDeviceSubgroupSizeControlPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT));
#endif
    exports["VkPipelineShaderStageRequiredSubgroupSizeCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineShaderStageRequiredSubgroupSizeCreateInfo, sType));
    exports["VkPipelineShaderStageRequiredSubgroupSizeCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineShaderStageRequiredSubgroupSizeCreateInfo, pNext));
    exports["VkPipelineShaderStageRequiredSubgroupSizeCreateInfo_requiredSubgroupSize_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineShaderStageRequiredSubgroupSizeCreateInfo, requiredSubgroupSize));
    exports["VkPipelineShaderStageRequiredSubgroupSizeCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineShaderStageRequiredSubgroupSizeCreateInfo));
#ifdef VK_EXT_subgroup_size_control
    exports["VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT));
#endif
#ifdef VK_HUAWEI_subpass_shading
    exports["VkSubpassShadingPipelineCreateInfoHUAWEI_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassShadingPipelineCreateInfoHUAWEI, sType));
#endif
#ifdef VK_HUAWEI_subpass_shading
    exports["VkSubpassShadingPipelineCreateInfoHUAWEI_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassShadingPipelineCreateInfoHUAWEI, pNext));
#endif
#ifdef VK_HUAWEI_subpass_shading
    exports["VkSubpassShadingPipelineCreateInfoHUAWEI_renderPass_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassShadingPipelineCreateInfoHUAWEI, renderPass));
#endif
#ifdef VK_HUAWEI_subpass_shading
    exports["VkSubpassShadingPipelineCreateInfoHUAWEI_subpass_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassShadingPipelineCreateInfoHUAWEI, subpass));
#endif
#ifdef VK_HUAWEI_subpass_shading
    exports["VkSubpassShadingPipelineCreateInfoHUAWEI_sizeof"] = Napi::Number::New(env, sizeof(VkSubpassShadingPipelineCreateInfoHUAWEI));
#endif
#ifdef VK_HUAWEI_subpass_shading
    exports["VkPhysicalDeviceSubpassShadingPropertiesHUAWEI_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI, sType));
#endif
#ifdef VK_HUAWEI_subpass_shading
    exports["VkPhysicalDeviceSubpassShadingPropertiesHUAWEI_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI, pNext));
#endif
#ifdef VK_HUAWEI_subpass_shading
    exports["VkPhysicalDeviceSubpassShadingPropertiesHUAWEI_maxSubpassShadingWorkgroupSizeAspectRatio_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI, maxSubpassShadingWorkgroupSizeAspectRatio));
#endif
#ifdef VK_HUAWEI_subpass_shading
    exports["VkPhysicalDeviceSubpassShadingPropertiesHUAWEI_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI));
#endif
    exports["VkMemoryOpaqueCaptureAddressAllocateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryOpaqueCaptureAddressAllocateInfo, sType));
    exports["VkMemoryOpaqueCaptureAddressAllocateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryOpaqueCaptureAddressAllocateInfo, pNext));
    exports["VkMemoryOpaqueCaptureAddressAllocateInfo_opaqueCaptureAddress_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryOpaqueCaptureAddressAllocateInfo, opaqueCaptureAddress));
    exports["VkMemoryOpaqueCaptureAddressAllocateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryOpaqueCaptureAddressAllocateInfo));
#ifdef VK_KHR_buffer_device_address
    exports["VkMemoryOpaqueCaptureAddressAllocateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryOpaqueCaptureAddressAllocateInfoKHR));
#endif
    exports["VkDeviceMemoryOpaqueCaptureAddressInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceMemoryOpaqueCaptureAddressInfo, sType));
    exports["VkDeviceMemoryOpaqueCaptureAddressInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceMemoryOpaqueCaptureAddressInfo, pNext));
    exports["VkDeviceMemoryOpaqueCaptureAddressInfo_memory_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceMemoryOpaqueCaptureAddressInfo, memory));
    exports["VkDeviceMemoryOpaqueCaptureAddressInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceMemoryOpaqueCaptureAddressInfo));
#ifdef VK_KHR_buffer_device_address
    exports["VkDeviceMemoryOpaqueCaptureAddressInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceMemoryOpaqueCaptureAddressInfoKHR));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPhysicalDeviceLineRasterizationFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLineRasterizationFeaturesEXT, sType));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPhysicalDeviceLineRasterizationFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLineRasterizationFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPhysicalDeviceLineRasterizationFeaturesEXT_rectangularLines_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLineRasterizationFeaturesEXT, rectangularLines));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPhysicalDeviceLineRasterizationFeaturesEXT_bresenhamLines_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLineRasterizationFeaturesEXT, bresenhamLines));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPhysicalDeviceLineRasterizationFeaturesEXT_smoothLines_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLineRasterizationFeaturesEXT, smoothLines));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPhysicalDeviceLineRasterizationFeaturesEXT_stippledRectangularLines_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLineRasterizationFeaturesEXT, stippledRectangularLines));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPhysicalDeviceLineRasterizationFeaturesEXT_stippledBresenhamLines_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLineRasterizationFeaturesEXT, stippledBresenhamLines));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPhysicalDeviceLineRasterizationFeaturesEXT_stippledSmoothLines_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLineRasterizationFeaturesEXT, stippledSmoothLines));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPhysicalDeviceLineRasterizationFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceLineRasterizationFeaturesEXT));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPhysicalDeviceLineRasterizationPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLineRasterizationPropertiesEXT, sType));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPhysicalDeviceLineRasterizationPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLineRasterizationPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPhysicalDeviceLineRasterizationPropertiesEXT_lineSubPixelPrecisionBits_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLineRasterizationPropertiesEXT, lineSubPixelPrecisionBits));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPhysicalDeviceLineRasterizationPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceLineRasterizationPropertiesEXT));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPipelineRasterizationLineStateCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationLineStateCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPipelineRasterizationLineStateCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationLineStateCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPipelineRasterizationLineStateCreateInfoEXT_lineRasterizationMode_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationLineStateCreateInfoEXT, lineRasterizationMode));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPipelineRasterizationLineStateCreateInfoEXT_stippledLineEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationLineStateCreateInfoEXT, stippledLineEnable));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPipelineRasterizationLineStateCreateInfoEXT_lineStippleFactor_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationLineStateCreateInfoEXT, lineStippleFactor));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPipelineRasterizationLineStateCreateInfoEXT_lineStipplePattern_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationLineStateCreateInfoEXT, lineStipplePattern));
#endif
#ifdef VK_EXT_line_rasterization
    exports["VkPipelineRasterizationLineStateCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineRasterizationLineStateCreateInfoEXT));
#endif
    exports["VkPhysicalDevicePipelineCreationCacheControlFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineCreationCacheControlFeatures, sType));
    exports["VkPhysicalDevicePipelineCreationCacheControlFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineCreationCacheControlFeatures, pNext));
    exports["VkPhysicalDevicePipelineCreationCacheControlFeatures_pipelineCreationCacheControl_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineCreationCacheControlFeatures, pipelineCreationCacheControl));
    exports["VkPhysicalDevicePipelineCreationCacheControlFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePipelineCreationCacheControlFeatures));
#ifdef VK_EXT_pipeline_creation_cache_control
    exports["VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT));
#endif
    exports["VkPhysicalDeviceVulkan11Features_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Features, sType));
    exports["VkPhysicalDeviceVulkan11Features_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Features, pNext));
    exports["VkPhysicalDeviceVulkan11Features_storageBuffer16BitAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Features, storageBuffer16BitAccess));
    exports["VkPhysicalDeviceVulkan11Features_uniformAndStorageBuffer16BitAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Features, uniformAndStorageBuffer16BitAccess));
    exports["VkPhysicalDeviceVulkan11Features_storagePushConstant16_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Features, storagePushConstant16));
    exports["VkPhysicalDeviceVulkan11Features_storageInputOutput16_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Features, storageInputOutput16));
    exports["VkPhysicalDeviceVulkan11Features_multiview_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Features, multiview));
    exports["VkPhysicalDeviceVulkan11Features_multiviewGeometryShader_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Features, multiviewGeometryShader));
    exports["VkPhysicalDeviceVulkan11Features_multiviewTessellationShader_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Features, multiviewTessellationShader));
    exports["VkPhysicalDeviceVulkan11Features_variablePointersStorageBuffer_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Features, variablePointersStorageBuffer));
    exports["VkPhysicalDeviceVulkan11Features_variablePointers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Features, variablePointers));
    exports["VkPhysicalDeviceVulkan11Features_protectedMemory_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Features, protectedMemory));
    exports["VkPhysicalDeviceVulkan11Features_samplerYcbcrConversion_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Features, samplerYcbcrConversion));
    exports["VkPhysicalDeviceVulkan11Features_shaderDrawParameters_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Features, shaderDrawParameters));
    exports["VkPhysicalDeviceVulkan11Features_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceVulkan11Features));
    exports["VkPhysicalDeviceVulkan11Properties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Properties, sType));
    exports["VkPhysicalDeviceVulkan11Properties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Properties, pNext));
    exports["VkPhysicalDeviceVulkan11Properties_deviceUUID_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Properties, deviceUUID));
    exports["VkPhysicalDeviceVulkan11Properties_driverUUID_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Properties, driverUUID));
    exports["VkPhysicalDeviceVulkan11Properties_deviceLUID_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Properties, deviceLUID));
    exports["VkPhysicalDeviceVulkan11Properties_deviceNodeMask_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Properties, deviceNodeMask));
    exports["VkPhysicalDeviceVulkan11Properties_deviceLUIDValid_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Properties, deviceLUIDValid));
    exports["VkPhysicalDeviceVulkan11Properties_subgroupSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Properties, subgroupSize));
    exports["VkPhysicalDeviceVulkan11Properties_subgroupSupportedStages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Properties, subgroupSupportedStages));
    exports["VkPhysicalDeviceVulkan11Properties_subgroupSupportedOperations_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Properties, subgroupSupportedOperations));
    exports["VkPhysicalDeviceVulkan11Properties_subgroupQuadOperationsInAllStages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Properties, subgroupQuadOperationsInAllStages));
    exports["VkPhysicalDeviceVulkan11Properties_pointClippingBehavior_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Properties, pointClippingBehavior));
    exports["VkPhysicalDeviceVulkan11Properties_maxMultiviewViewCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Properties, maxMultiviewViewCount));
    exports["VkPhysicalDeviceVulkan11Properties_maxMultiviewInstanceIndex_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Properties, maxMultiviewInstanceIndex));
    exports["VkPhysicalDeviceVulkan11Properties_protectedNoFault_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Properties, protectedNoFault));
    exports["VkPhysicalDeviceVulkan11Properties_maxPerSetDescriptors_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Properties, maxPerSetDescriptors));
    exports["VkPhysicalDeviceVulkan11Properties_maxMemoryAllocationSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan11Properties, maxMemoryAllocationSize));
    exports["VkPhysicalDeviceVulkan11Properties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceVulkan11Properties));
    exports["VkPhysicalDeviceVulkan12Features_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, sType));
    exports["VkPhysicalDeviceVulkan12Features_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, pNext));
    exports["VkPhysicalDeviceVulkan12Features_samplerMirrorClampToEdge_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, samplerMirrorClampToEdge));
    exports["VkPhysicalDeviceVulkan12Features_drawIndirectCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, drawIndirectCount));
    exports["VkPhysicalDeviceVulkan12Features_storageBuffer8BitAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, storageBuffer8BitAccess));
    exports["VkPhysicalDeviceVulkan12Features_uniformAndStorageBuffer8BitAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, uniformAndStorageBuffer8BitAccess));
    exports["VkPhysicalDeviceVulkan12Features_storagePushConstant8_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, storagePushConstant8));
    exports["VkPhysicalDeviceVulkan12Features_shaderBufferInt64Atomics_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, shaderBufferInt64Atomics));
    exports["VkPhysicalDeviceVulkan12Features_shaderSharedInt64Atomics_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, shaderSharedInt64Atomics));
    exports["VkPhysicalDeviceVulkan12Features_shaderFloat16_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, shaderFloat16));
    exports["VkPhysicalDeviceVulkan12Features_shaderInt8_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, shaderInt8));
    exports["VkPhysicalDeviceVulkan12Features_descriptorIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, descriptorIndexing));
    exports["VkPhysicalDeviceVulkan12Features_shaderInputAttachmentArrayDynamicIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, shaderInputAttachmentArrayDynamicIndexing));
    exports["VkPhysicalDeviceVulkan12Features_shaderUniformTexelBufferArrayDynamicIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, shaderUniformTexelBufferArrayDynamicIndexing));
    exports["VkPhysicalDeviceVulkan12Features_shaderStorageTexelBufferArrayDynamicIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, shaderStorageTexelBufferArrayDynamicIndexing));
    exports["VkPhysicalDeviceVulkan12Features_shaderUniformBufferArrayNonUniformIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, shaderUniformBufferArrayNonUniformIndexing));
    exports["VkPhysicalDeviceVulkan12Features_shaderSampledImageArrayNonUniformIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, shaderSampledImageArrayNonUniformIndexing));
    exports["VkPhysicalDeviceVulkan12Features_shaderStorageBufferArrayNonUniformIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, shaderStorageBufferArrayNonUniformIndexing));
    exports["VkPhysicalDeviceVulkan12Features_shaderStorageImageArrayNonUniformIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, shaderStorageImageArrayNonUniformIndexing));
    exports["VkPhysicalDeviceVulkan12Features_shaderInputAttachmentArrayNonUniformIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, shaderInputAttachmentArrayNonUniformIndexing));
    exports["VkPhysicalDeviceVulkan12Features_shaderUniformTexelBufferArrayNonUniformIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, shaderUniformTexelBufferArrayNonUniformIndexing));
    exports["VkPhysicalDeviceVulkan12Features_shaderStorageTexelBufferArrayNonUniformIndexing_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, shaderStorageTexelBufferArrayNonUniformIndexing));
    exports["VkPhysicalDeviceVulkan12Features_descriptorBindingUniformBufferUpdateAfterBind_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, descriptorBindingUniformBufferUpdateAfterBind));
    exports["VkPhysicalDeviceVulkan12Features_descriptorBindingSampledImageUpdateAfterBind_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, descriptorBindingSampledImageUpdateAfterBind));
    exports["VkPhysicalDeviceVulkan12Features_descriptorBindingStorageImageUpdateAfterBind_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, descriptorBindingStorageImageUpdateAfterBind));
    exports["VkPhysicalDeviceVulkan12Features_descriptorBindingStorageBufferUpdateAfterBind_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, descriptorBindingStorageBufferUpdateAfterBind));
    exports["VkPhysicalDeviceVulkan12Features_descriptorBindingUniformTexelBufferUpdateAfterBind_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, descriptorBindingUniformTexelBufferUpdateAfterBind));
    exports["VkPhysicalDeviceVulkan12Features_descriptorBindingStorageTexelBufferUpdateAfterBind_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, descriptorBindingStorageTexelBufferUpdateAfterBind));
    exports["VkPhysicalDeviceVulkan12Features_descriptorBindingUpdateUnusedWhilePending_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, descriptorBindingUpdateUnusedWhilePending));
    exports["VkPhysicalDeviceVulkan12Features_descriptorBindingPartiallyBound_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, descriptorBindingPartiallyBound));
    exports["VkPhysicalDeviceVulkan12Features_descriptorBindingVariableDescriptorCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, descriptorBindingVariableDescriptorCount));
    exports["VkPhysicalDeviceVulkan12Features_runtimeDescriptorArray_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, runtimeDescriptorArray));
    exports["VkPhysicalDeviceVulkan12Features_samplerFilterMinmax_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, samplerFilterMinmax));
    exports["VkPhysicalDeviceVulkan12Features_scalarBlockLayout_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, scalarBlockLayout));
    exports["VkPhysicalDeviceVulkan12Features_imagelessFramebuffer_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, imagelessFramebuffer));
    exports["VkPhysicalDeviceVulkan12Features_uniformBufferStandardLayout_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, uniformBufferStandardLayout));
    exports["VkPhysicalDeviceVulkan12Features_shaderSubgroupExtendedTypes_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, shaderSubgroupExtendedTypes));
    exports["VkPhysicalDeviceVulkan12Features_separateDepthStencilLayouts_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, separateDepthStencilLayouts));
    exports["VkPhysicalDeviceVulkan12Features_hostQueryReset_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, hostQueryReset));
    exports["VkPhysicalDeviceVulkan12Features_timelineSemaphore_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, timelineSemaphore));
    exports["VkPhysicalDeviceVulkan12Features_bufferDeviceAddress_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, bufferDeviceAddress));
    exports["VkPhysicalDeviceVulkan12Features_bufferDeviceAddressCaptureReplay_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, bufferDeviceAddressCaptureReplay));
    exports["VkPhysicalDeviceVulkan12Features_bufferDeviceAddressMultiDevice_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, bufferDeviceAddressMultiDevice));
    exports["VkPhysicalDeviceVulkan12Features_vulkanMemoryModel_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, vulkanMemoryModel));
    exports["VkPhysicalDeviceVulkan12Features_vulkanMemoryModelDeviceScope_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, vulkanMemoryModelDeviceScope));
    exports["VkPhysicalDeviceVulkan12Features_vulkanMemoryModelAvailabilityVisibilityChains_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, vulkanMemoryModelAvailabilityVisibilityChains));
    exports["VkPhysicalDeviceVulkan12Features_shaderOutputViewportIndex_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, shaderOutputViewportIndex));
    exports["VkPhysicalDeviceVulkan12Features_shaderOutputLayer_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, shaderOutputLayer));
    exports["VkPhysicalDeviceVulkan12Features_subgroupBroadcastDynamicId_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Features, subgroupBroadcastDynamicId));
    exports["VkPhysicalDeviceVulkan12Features_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceVulkan12Features));
    exports["VkPhysicalDeviceVulkan12Properties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, sType));
    exports["VkPhysicalDeviceVulkan12Properties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, pNext));
    exports["VkPhysicalDeviceVulkan12Properties_driverID_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, driverID));
    exports["VkPhysicalDeviceVulkan12Properties_driverName_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, driverName));
    exports["VkPhysicalDeviceVulkan12Properties_driverInfo_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, driverInfo));
    exports["VkPhysicalDeviceVulkan12Properties_conformanceVersion_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, conformanceVersion));
    exports["VkPhysicalDeviceVulkan12Properties_denormBehaviorIndependence_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, denormBehaviorIndependence));
    exports["VkPhysicalDeviceVulkan12Properties_roundingModeIndependence_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, roundingModeIndependence));
    exports["VkPhysicalDeviceVulkan12Properties_shaderSignedZeroInfNanPreserveFloat16_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderSignedZeroInfNanPreserveFloat16));
    exports["VkPhysicalDeviceVulkan12Properties_shaderSignedZeroInfNanPreserveFloat32_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderSignedZeroInfNanPreserveFloat32));
    exports["VkPhysicalDeviceVulkan12Properties_shaderSignedZeroInfNanPreserveFloat64_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderSignedZeroInfNanPreserveFloat64));
    exports["VkPhysicalDeviceVulkan12Properties_shaderDenormPreserveFloat16_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderDenormPreserveFloat16));
    exports["VkPhysicalDeviceVulkan12Properties_shaderDenormPreserveFloat32_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderDenormPreserveFloat32));
    exports["VkPhysicalDeviceVulkan12Properties_shaderDenormPreserveFloat64_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderDenormPreserveFloat64));
    exports["VkPhysicalDeviceVulkan12Properties_shaderDenormFlushToZeroFloat16_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderDenormFlushToZeroFloat16));
    exports["VkPhysicalDeviceVulkan12Properties_shaderDenormFlushToZeroFloat32_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderDenormFlushToZeroFloat32));
    exports["VkPhysicalDeviceVulkan12Properties_shaderDenormFlushToZeroFloat64_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderDenormFlushToZeroFloat64));
    exports["VkPhysicalDeviceVulkan12Properties_shaderRoundingModeRTEFloat16_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderRoundingModeRTEFloat16));
    exports["VkPhysicalDeviceVulkan12Properties_shaderRoundingModeRTEFloat32_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderRoundingModeRTEFloat32));
    exports["VkPhysicalDeviceVulkan12Properties_shaderRoundingModeRTEFloat64_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderRoundingModeRTEFloat64));
    exports["VkPhysicalDeviceVulkan12Properties_shaderRoundingModeRTZFloat16_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderRoundingModeRTZFloat16));
    exports["VkPhysicalDeviceVulkan12Properties_shaderRoundingModeRTZFloat32_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderRoundingModeRTZFloat32));
    exports["VkPhysicalDeviceVulkan12Properties_shaderRoundingModeRTZFloat64_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderRoundingModeRTZFloat64));
    exports["VkPhysicalDeviceVulkan12Properties_maxUpdateAfterBindDescriptorsInAllPools_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, maxUpdateAfterBindDescriptorsInAllPools));
    exports["VkPhysicalDeviceVulkan12Properties_shaderUniformBufferArrayNonUniformIndexingNative_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderUniformBufferArrayNonUniformIndexingNative));
    exports["VkPhysicalDeviceVulkan12Properties_shaderSampledImageArrayNonUniformIndexingNative_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderSampledImageArrayNonUniformIndexingNative));
    exports["VkPhysicalDeviceVulkan12Properties_shaderStorageBufferArrayNonUniformIndexingNative_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderStorageBufferArrayNonUniformIndexingNative));
    exports["VkPhysicalDeviceVulkan12Properties_shaderStorageImageArrayNonUniformIndexingNative_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderStorageImageArrayNonUniformIndexingNative));
    exports["VkPhysicalDeviceVulkan12Properties_shaderInputAttachmentArrayNonUniformIndexingNative_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, shaderInputAttachmentArrayNonUniformIndexingNative));
    exports["VkPhysicalDeviceVulkan12Properties_robustBufferAccessUpdateAfterBind_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, robustBufferAccessUpdateAfterBind));
    exports["VkPhysicalDeviceVulkan12Properties_quadDivergentImplicitLod_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, quadDivergentImplicitLod));
    exports["VkPhysicalDeviceVulkan12Properties_maxPerStageDescriptorUpdateAfterBindSamplers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, maxPerStageDescriptorUpdateAfterBindSamplers));
    exports["VkPhysicalDeviceVulkan12Properties_maxPerStageDescriptorUpdateAfterBindUniformBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, maxPerStageDescriptorUpdateAfterBindUniformBuffers));
    exports["VkPhysicalDeviceVulkan12Properties_maxPerStageDescriptorUpdateAfterBindStorageBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, maxPerStageDescriptorUpdateAfterBindStorageBuffers));
    exports["VkPhysicalDeviceVulkan12Properties_maxPerStageDescriptorUpdateAfterBindSampledImages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, maxPerStageDescriptorUpdateAfterBindSampledImages));
    exports["VkPhysicalDeviceVulkan12Properties_maxPerStageDescriptorUpdateAfterBindStorageImages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, maxPerStageDescriptorUpdateAfterBindStorageImages));
    exports["VkPhysicalDeviceVulkan12Properties_maxPerStageDescriptorUpdateAfterBindInputAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, maxPerStageDescriptorUpdateAfterBindInputAttachments));
    exports["VkPhysicalDeviceVulkan12Properties_maxPerStageUpdateAfterBindResources_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, maxPerStageUpdateAfterBindResources));
    exports["VkPhysicalDeviceVulkan12Properties_maxDescriptorSetUpdateAfterBindSamplers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, maxDescriptorSetUpdateAfterBindSamplers));
    exports["VkPhysicalDeviceVulkan12Properties_maxDescriptorSetUpdateAfterBindUniformBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, maxDescriptorSetUpdateAfterBindUniformBuffers));
    exports["VkPhysicalDeviceVulkan12Properties_maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, maxDescriptorSetUpdateAfterBindUniformBuffersDynamic));
    exports["VkPhysicalDeviceVulkan12Properties_maxDescriptorSetUpdateAfterBindStorageBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, maxDescriptorSetUpdateAfterBindStorageBuffers));
    exports["VkPhysicalDeviceVulkan12Properties_maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, maxDescriptorSetUpdateAfterBindStorageBuffersDynamic));
    exports["VkPhysicalDeviceVulkan12Properties_maxDescriptorSetUpdateAfterBindSampledImages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, maxDescriptorSetUpdateAfterBindSampledImages));
    exports["VkPhysicalDeviceVulkan12Properties_maxDescriptorSetUpdateAfterBindStorageImages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, maxDescriptorSetUpdateAfterBindStorageImages));
    exports["VkPhysicalDeviceVulkan12Properties_maxDescriptorSetUpdateAfterBindInputAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, maxDescriptorSetUpdateAfterBindInputAttachments));
    exports["VkPhysicalDeviceVulkan12Properties_supportedDepthResolveModes_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, supportedDepthResolveModes));
    exports["VkPhysicalDeviceVulkan12Properties_supportedStencilResolveModes_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, supportedStencilResolveModes));
    exports["VkPhysicalDeviceVulkan12Properties_independentResolveNone_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, independentResolveNone));
    exports["VkPhysicalDeviceVulkan12Properties_independentResolve_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, independentResolve));
    exports["VkPhysicalDeviceVulkan12Properties_filterMinmaxSingleComponentFormats_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, filterMinmaxSingleComponentFormats));
    exports["VkPhysicalDeviceVulkan12Properties_filterMinmaxImageComponentMapping_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, filterMinmaxImageComponentMapping));
    exports["VkPhysicalDeviceVulkan12Properties_maxTimelineSemaphoreValueDifference_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, maxTimelineSemaphoreValueDifference));
    exports["VkPhysicalDeviceVulkan12Properties_framebufferIntegerColorSampleCounts_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan12Properties, framebufferIntegerColorSampleCounts));
    exports["VkPhysicalDeviceVulkan12Properties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceVulkan12Properties));
    exports["VkPhysicalDeviceVulkan13Features_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Features, sType));
    exports["VkPhysicalDeviceVulkan13Features_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Features, pNext));
    exports["VkPhysicalDeviceVulkan13Features_robustImageAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Features, robustImageAccess));
    exports["VkPhysicalDeviceVulkan13Features_inlineUniformBlock_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Features, inlineUniformBlock));
    exports["VkPhysicalDeviceVulkan13Features_descriptorBindingInlineUniformBlockUpdateAfterBind_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Features, descriptorBindingInlineUniformBlockUpdateAfterBind));
    exports["VkPhysicalDeviceVulkan13Features_pipelineCreationCacheControl_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Features, pipelineCreationCacheControl));
    exports["VkPhysicalDeviceVulkan13Features_privateData_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Features, privateData));
    exports["VkPhysicalDeviceVulkan13Features_shaderDemoteToHelperInvocation_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Features, shaderDemoteToHelperInvocation));
    exports["VkPhysicalDeviceVulkan13Features_shaderTerminateInvocation_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Features, shaderTerminateInvocation));
    exports["VkPhysicalDeviceVulkan13Features_subgroupSizeControl_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Features, subgroupSizeControl));
    exports["VkPhysicalDeviceVulkan13Features_computeFullSubgroups_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Features, computeFullSubgroups));
    exports["VkPhysicalDeviceVulkan13Features_synchronization2_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Features, synchronization2));
    exports["VkPhysicalDeviceVulkan13Features_textureCompressionASTC_HDR_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Features, textureCompressionASTC_HDR));
    exports["VkPhysicalDeviceVulkan13Features_shaderZeroInitializeWorkgroupMemory_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Features, shaderZeroInitializeWorkgroupMemory));
    exports["VkPhysicalDeviceVulkan13Features_dynamicRendering_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Features, dynamicRendering));
    exports["VkPhysicalDeviceVulkan13Features_shaderIntegerDotProduct_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Features, shaderIntegerDotProduct));
    exports["VkPhysicalDeviceVulkan13Features_maintenance4_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Features, maintenance4));
    exports["VkPhysicalDeviceVulkan13Features_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceVulkan13Features));
    exports["VkPhysicalDeviceVulkan13Properties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, sType));
    exports["VkPhysicalDeviceVulkan13Properties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, pNext));
    exports["VkPhysicalDeviceVulkan13Properties_minSubgroupSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, minSubgroupSize));
    exports["VkPhysicalDeviceVulkan13Properties_maxSubgroupSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, maxSubgroupSize));
    exports["VkPhysicalDeviceVulkan13Properties_maxComputeWorkgroupSubgroups_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, maxComputeWorkgroupSubgroups));
    exports["VkPhysicalDeviceVulkan13Properties_requiredSubgroupSizeStages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, requiredSubgroupSizeStages));
    exports["VkPhysicalDeviceVulkan13Properties_maxInlineUniformBlockSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, maxInlineUniformBlockSize));
    exports["VkPhysicalDeviceVulkan13Properties_maxPerStageDescriptorInlineUniformBlocks_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, maxPerStageDescriptorInlineUniformBlocks));
    exports["VkPhysicalDeviceVulkan13Properties_maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks));
    exports["VkPhysicalDeviceVulkan13Properties_maxDescriptorSetInlineUniformBlocks_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, maxDescriptorSetInlineUniformBlocks));
    exports["VkPhysicalDeviceVulkan13Properties_maxDescriptorSetUpdateAfterBindInlineUniformBlocks_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, maxDescriptorSetUpdateAfterBindInlineUniformBlocks));
    exports["VkPhysicalDeviceVulkan13Properties_maxInlineUniformTotalSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, maxInlineUniformTotalSize));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProduct8BitUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProduct8BitUnsignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProduct8BitSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProduct8BitSignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProduct8BitMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProduct8BitMixedSignednessAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProduct4x8BitPackedUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProduct4x8BitPackedUnsignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProduct4x8BitPackedSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProduct4x8BitPackedSignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProduct4x8BitPackedMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProduct4x8BitPackedMixedSignednessAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProduct16BitUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProduct16BitUnsignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProduct16BitSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProduct16BitSignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProduct16BitMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProduct16BitMixedSignednessAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProduct32BitUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProduct32BitUnsignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProduct32BitSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProduct32BitSignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProduct32BitMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProduct32BitMixedSignednessAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProduct64BitUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProduct64BitUnsignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProduct64BitSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProduct64BitSignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProduct64BitMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProduct64BitMixedSignednessAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProductAccumulatingSaturating8BitUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProductAccumulatingSaturating8BitUnsignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProductAccumulatingSaturating8BitSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProductAccumulatingSaturating8BitSignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProductAccumulatingSaturating16BitUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProductAccumulatingSaturating16BitUnsignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProductAccumulatingSaturating16BitSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProductAccumulatingSaturating16BitSignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProductAccumulatingSaturating32BitUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProductAccumulatingSaturating32BitUnsignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProductAccumulatingSaturating32BitSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProductAccumulatingSaturating32BitSignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProductAccumulatingSaturating64BitUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProductAccumulatingSaturating64BitUnsignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProductAccumulatingSaturating64BitSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProductAccumulatingSaturating64BitSignedAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated));
    exports["VkPhysicalDeviceVulkan13Properties_storageTexelBufferOffsetAlignmentBytes_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, storageTexelBufferOffsetAlignmentBytes));
    exports["VkPhysicalDeviceVulkan13Properties_storageTexelBufferOffsetSingleTexelAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, storageTexelBufferOffsetSingleTexelAlignment));
    exports["VkPhysicalDeviceVulkan13Properties_uniformTexelBufferOffsetAlignmentBytes_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, uniformTexelBufferOffsetAlignmentBytes));
    exports["VkPhysicalDeviceVulkan13Properties_uniformTexelBufferOffsetSingleTexelAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, uniformTexelBufferOffsetSingleTexelAlignment));
    exports["VkPhysicalDeviceVulkan13Properties_maxBufferSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVulkan13Properties, maxBufferSize));
    exports["VkPhysicalDeviceVulkan13Properties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceVulkan13Properties));
#ifdef VK_AMD_pipeline_compiler_control
    exports["VkPipelineCompilerControlCreateInfoAMD_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCompilerControlCreateInfoAMD, sType));
#endif
#ifdef VK_AMD_pipeline_compiler_control
    exports["VkPipelineCompilerControlCreateInfoAMD_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCompilerControlCreateInfoAMD, pNext));
#endif
#ifdef VK_AMD_pipeline_compiler_control
    exports["VkPipelineCompilerControlCreateInfoAMD_compilerControlFlags_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineCompilerControlCreateInfoAMD, compilerControlFlags));
#endif
#ifdef VK_AMD_pipeline_compiler_control
    exports["VkPipelineCompilerControlCreateInfoAMD_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineCompilerControlCreateInfoAMD));
#endif
#ifdef VK_AMD_device_coherent_memory
    exports["VkPhysicalDeviceCoherentMemoryFeaturesAMD_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCoherentMemoryFeaturesAMD, sType));
#endif
#ifdef VK_AMD_device_coherent_memory
    exports["VkPhysicalDeviceCoherentMemoryFeaturesAMD_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCoherentMemoryFeaturesAMD, pNext));
#endif
#ifdef VK_AMD_device_coherent_memory
    exports["VkPhysicalDeviceCoherentMemoryFeaturesAMD_deviceCoherentMemory_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCoherentMemoryFeaturesAMD, deviceCoherentMemory));
#endif
#ifdef VK_AMD_device_coherent_memory
    exports["VkPhysicalDeviceCoherentMemoryFeaturesAMD_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceCoherentMemoryFeaturesAMD));
#endif
    exports["VkPhysicalDeviceToolProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceToolProperties, sType));
    exports["VkPhysicalDeviceToolProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceToolProperties, pNext));
    exports["VkPhysicalDeviceToolProperties_name_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceToolProperties, name));
    exports["VkPhysicalDeviceToolProperties_version_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceToolProperties, version));
    exports["VkPhysicalDeviceToolProperties_purposes_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceToolProperties, purposes));
    exports["VkPhysicalDeviceToolProperties_description_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceToolProperties, description));
    exports["VkPhysicalDeviceToolProperties_layer_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceToolProperties, layer));
    exports["VkPhysicalDeviceToolProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceToolProperties));
#ifdef VK_EXT_tooling_info
    exports["VkPhysicalDeviceToolPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceToolPropertiesEXT));
#endif
#ifdef VK_EXT_custom_border_color
    exports["VkSamplerCustomBorderColorCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCustomBorderColorCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_custom_border_color
    exports["VkSamplerCustomBorderColorCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCustomBorderColorCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_custom_border_color
    exports["VkSamplerCustomBorderColorCreateInfoEXT_customBorderColor_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCustomBorderColorCreateInfoEXT, customBorderColor));
#endif
#ifdef VK_EXT_custom_border_color
    exports["VkSamplerCustomBorderColorCreateInfoEXT_format_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCustomBorderColorCreateInfoEXT, format));
#endif
#ifdef VK_EXT_custom_border_color
    exports["VkSamplerCustomBorderColorCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkSamplerCustomBorderColorCreateInfoEXT));
#endif
#ifdef VK_EXT_custom_border_color
    exports["VkPhysicalDeviceCustomBorderColorPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCustomBorderColorPropertiesEXT, sType));
#endif
#ifdef VK_EXT_custom_border_color
    exports["VkPhysicalDeviceCustomBorderColorPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCustomBorderColorPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_custom_border_color
    exports["VkPhysicalDeviceCustomBorderColorPropertiesEXT_maxCustomBorderColorSamplers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCustomBorderColorPropertiesEXT, maxCustomBorderColorSamplers));
#endif
#ifdef VK_EXT_custom_border_color
    exports["VkPhysicalDeviceCustomBorderColorPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceCustomBorderColorPropertiesEXT));
#endif
#ifdef VK_EXT_custom_border_color
    exports["VkPhysicalDeviceCustomBorderColorFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCustomBorderColorFeaturesEXT, sType));
#endif
#ifdef VK_EXT_custom_border_color
    exports["VkPhysicalDeviceCustomBorderColorFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCustomBorderColorFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_custom_border_color
    exports["VkPhysicalDeviceCustomBorderColorFeaturesEXT_customBorderColors_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCustomBorderColorFeaturesEXT, customBorderColors));
#endif
#ifdef VK_EXT_custom_border_color
    exports["VkPhysicalDeviceCustomBorderColorFeaturesEXT_customBorderColorWithoutFormat_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceCustomBorderColorFeaturesEXT, customBorderColorWithoutFormat));
#endif
#ifdef VK_EXT_custom_border_color
    exports["VkPhysicalDeviceCustomBorderColorFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceCustomBorderColorFeaturesEXT));
#endif
#ifdef VK_EXT_border_color_swizzle
    exports["VkSamplerBorderColorComponentMappingCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerBorderColorComponentMappingCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_border_color_swizzle
    exports["VkSamplerBorderColorComponentMappingCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerBorderColorComponentMappingCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_border_color_swizzle
    exports["VkSamplerBorderColorComponentMappingCreateInfoEXT_components_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerBorderColorComponentMappingCreateInfoEXT, components));
#endif
#ifdef VK_EXT_border_color_swizzle
    exports["VkSamplerBorderColorComponentMappingCreateInfoEXT_srgb_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerBorderColorComponentMappingCreateInfoEXT, srgb));
#endif
#ifdef VK_EXT_border_color_swizzle
    exports["VkSamplerBorderColorComponentMappingCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkSamplerBorderColorComponentMappingCreateInfoEXT));
#endif
#ifdef VK_EXT_border_color_swizzle
    exports["VkPhysicalDeviceBorderColorSwizzleFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT, sType));
#endif
#ifdef VK_EXT_border_color_swizzle
    exports["VkPhysicalDeviceBorderColorSwizzleFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_border_color_swizzle
    exports["VkPhysicalDeviceBorderColorSwizzleFeaturesEXT_borderColorSwizzle_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT, borderColorSwizzle));
#endif
#ifdef VK_EXT_border_color_swizzle
    exports["VkPhysicalDeviceBorderColorSwizzleFeaturesEXT_borderColorSwizzleFromImage_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT, borderColorSwizzleFromImage));
#endif
#ifdef VK_EXT_border_color_swizzle
    exports["VkPhysicalDeviceBorderColorSwizzleFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryTrianglesDataKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryTrianglesDataKHR, sType));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryTrianglesDataKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryTrianglesDataKHR, pNext));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryTrianglesDataKHR_vertexFormat_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryTrianglesDataKHR, vertexFormat));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryTrianglesDataKHR_vertexData_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryTrianglesDataKHR, vertexData));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryTrianglesDataKHR_vertexStride_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryTrianglesDataKHR, vertexStride));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryTrianglesDataKHR_maxVertex_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryTrianglesDataKHR, maxVertex));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryTrianglesDataKHR_indexType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryTrianglesDataKHR, indexType));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryTrianglesDataKHR_indexData_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryTrianglesDataKHR, indexData));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryTrianglesDataKHR_transformData_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryTrianglesDataKHR, transformData));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryTrianglesDataKHR_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureGeometryTrianglesDataKHR));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryAabbsDataKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryAabbsDataKHR, sType));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryAabbsDataKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryAabbsDataKHR, pNext));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryAabbsDataKHR_data_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryAabbsDataKHR, data));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryAabbsDataKHR_stride_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryAabbsDataKHR, stride));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryAabbsDataKHR_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureGeometryAabbsDataKHR));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryInstancesDataKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryInstancesDataKHR, sType));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryInstancesDataKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryInstancesDataKHR, pNext));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryInstancesDataKHR_arrayOfPointers_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryInstancesDataKHR, arrayOfPointers));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryInstancesDataKHR_data_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryInstancesDataKHR, data));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryInstancesDataKHR_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureGeometryInstancesDataKHR));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryKHR, sType));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryKHR, pNext));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryKHR_geometryType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryKHR, geometryType));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryKHR_geometry_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryKHR, geometry));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryKHR, flags));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureGeometryKHR_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureGeometryKHR));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildGeometryInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildGeometryInfoKHR, sType));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildGeometryInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildGeometryInfoKHR, pNext));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildGeometryInfoKHR_type_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildGeometryInfoKHR, type));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildGeometryInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildGeometryInfoKHR, flags));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildGeometryInfoKHR_mode_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildGeometryInfoKHR, mode));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildGeometryInfoKHR_srcAccelerationStructure_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildGeometryInfoKHR, srcAccelerationStructure));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildGeometryInfoKHR_dstAccelerationStructure_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildGeometryInfoKHR, dstAccelerationStructure));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildGeometryInfoKHR_geometryCount_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildGeometryInfoKHR, geometryCount));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildGeometryInfoKHR_pGeometries_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildGeometryInfoKHR, pGeometries));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildGeometryInfoKHR_ppGeometries_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildGeometryInfoKHR, ppGeometries));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildGeometryInfoKHR_scratchData_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildGeometryInfoKHR, scratchData));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildGeometryInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureBuildGeometryInfoKHR));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildRangeInfoKHR_primitiveCount_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildRangeInfoKHR, primitiveCount));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildRangeInfoKHR_primitiveOffset_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildRangeInfoKHR, primitiveOffset));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildRangeInfoKHR_firstVertex_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildRangeInfoKHR, firstVertex));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildRangeInfoKHR_transformOffset_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildRangeInfoKHR, transformOffset));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildRangeInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureBuildRangeInfoKHR));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureCreateInfoKHR_createFlags_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureCreateInfoKHR, createFlags));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureCreateInfoKHR_buffer_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureCreateInfoKHR, buffer));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureCreateInfoKHR_offset_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureCreateInfoKHR, offset));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureCreateInfoKHR_size_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureCreateInfoKHR, size));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureCreateInfoKHR_type_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureCreateInfoKHR, type));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureCreateInfoKHR_deviceAddress_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureCreateInfoKHR, deviceAddress));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureCreateInfoKHR));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAabbPositionsKHR_minX_offsetof"] = Napi::Number::New(env, offsetof(VkAabbPositionsKHR, minX));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAabbPositionsKHR_minY_offsetof"] = Napi::Number::New(env, offsetof(VkAabbPositionsKHR, minY));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAabbPositionsKHR_minZ_offsetof"] = Napi::Number::New(env, offsetof(VkAabbPositionsKHR, minZ));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAabbPositionsKHR_maxX_offsetof"] = Napi::Number::New(env, offsetof(VkAabbPositionsKHR, maxX));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAabbPositionsKHR_maxY_offsetof"] = Napi::Number::New(env, offsetof(VkAabbPositionsKHR, maxY));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAabbPositionsKHR_maxZ_offsetof"] = Napi::Number::New(env, offsetof(VkAabbPositionsKHR, maxZ));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAabbPositionsKHR_sizeof"] = Napi::Number::New(env, sizeof(VkAabbPositionsKHR));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAabbPositionsNV_sizeof"] = Napi::Number::New(env, sizeof(VkAabbPositionsNV));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkTransformMatrixKHR_matrix_offsetof"] = Napi::Number::New(env, offsetof(VkTransformMatrixKHR, matrix));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkTransformMatrixKHR_sizeof"] = Napi::Number::New(env, sizeof(VkTransformMatrixKHR));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkTransformMatrixNV_sizeof"] = Napi::Number::New(env, sizeof(VkTransformMatrixNV));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureInstanceKHR_transform_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureInstanceKHR, transform));
#endif




#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureInstanceKHR_accelerationStructureReference_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureInstanceKHR, accelerationStructureReference));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureInstanceKHR_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureInstanceKHR));
#endif
#ifdef VK_NV_ray_tracing
    exports["VkAccelerationStructureInstanceNV_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureInstanceNV));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureDeviceAddressInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureDeviceAddressInfoKHR, sType));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureDeviceAddressInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureDeviceAddressInfoKHR, pNext));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureDeviceAddressInfoKHR_accelerationStructure_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureDeviceAddressInfoKHR, accelerationStructure));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureDeviceAddressInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureDeviceAddressInfoKHR));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureVersionInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureVersionInfoKHR, sType));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureVersionInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureVersionInfoKHR, pNext));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureVersionInfoKHR_pVersionData_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureVersionInfoKHR, pVersionData));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureVersionInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureVersionInfoKHR));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyAccelerationStructureInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCopyAccelerationStructureInfoKHR, sType));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyAccelerationStructureInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCopyAccelerationStructureInfoKHR, pNext));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyAccelerationStructureInfoKHR_src_offsetof"] = Napi::Number::New(env, offsetof(VkCopyAccelerationStructureInfoKHR, src));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyAccelerationStructureInfoKHR_dst_offsetof"] = Napi::Number::New(env, offsetof(VkCopyAccelerationStructureInfoKHR, dst));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyAccelerationStructureInfoKHR_mode_offsetof"] = Napi::Number::New(env, offsetof(VkCopyAccelerationStructureInfoKHR, mode));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyAccelerationStructureInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkCopyAccelerationStructureInfoKHR));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyAccelerationStructureToMemoryInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCopyAccelerationStructureToMemoryInfoKHR, sType));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyAccelerationStructureToMemoryInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCopyAccelerationStructureToMemoryInfoKHR, pNext));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyAccelerationStructureToMemoryInfoKHR_src_offsetof"] = Napi::Number::New(env, offsetof(VkCopyAccelerationStructureToMemoryInfoKHR, src));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyAccelerationStructureToMemoryInfoKHR_dst_offsetof"] = Napi::Number::New(env, offsetof(VkCopyAccelerationStructureToMemoryInfoKHR, dst));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyAccelerationStructureToMemoryInfoKHR_mode_offsetof"] = Napi::Number::New(env, offsetof(VkCopyAccelerationStructureToMemoryInfoKHR, mode));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyAccelerationStructureToMemoryInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkCopyAccelerationStructureToMemoryInfoKHR));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyMemoryToAccelerationStructureInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryToAccelerationStructureInfoKHR, sType));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyMemoryToAccelerationStructureInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryToAccelerationStructureInfoKHR, pNext));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyMemoryToAccelerationStructureInfoKHR_src_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryToAccelerationStructureInfoKHR, src));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyMemoryToAccelerationStructureInfoKHR_dst_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryToAccelerationStructureInfoKHR, dst));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyMemoryToAccelerationStructureInfoKHR_mode_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryToAccelerationStructureInfoKHR, mode));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkCopyMemoryToAccelerationStructureInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkCopyMemoryToAccelerationStructureInfoKHR));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineInterfaceCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineInterfaceCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineInterfaceCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineInterfaceCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineInterfaceCreateInfoKHR_maxPipelineRayPayloadSize_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineInterfaceCreateInfoKHR, maxPipelineRayPayloadSize));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineInterfaceCreateInfoKHR_maxPipelineRayHitAttributeSize_offsetof"] = Napi::Number::New(env, offsetof(VkRayTracingPipelineInterfaceCreateInfoKHR, maxPipelineRayHitAttributeSize));
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["VkRayTracingPipelineInterfaceCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkRayTracingPipelineInterfaceCreateInfoKHR));
#endif
#ifdef VK_KHR_pipeline_library
    exports["VkPipelineLibraryCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineLibraryCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_pipeline_library
    exports["VkPipelineLibraryCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineLibraryCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_pipeline_library
    exports["VkPipelineLibraryCreateInfoKHR_libraryCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineLibraryCreateInfoKHR, libraryCount));
#endif
#ifdef VK_KHR_pipeline_library
    exports["VkPipelineLibraryCreateInfoKHR_pLibraries_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineLibraryCreateInfoKHR, pLibraries));
#endif
#ifdef VK_KHR_pipeline_library
    exports["VkPipelineLibraryCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineLibraryCreateInfoKHR));
#endif
#ifdef VK_EXT_extended_dynamic_state
    exports["VkPhysicalDeviceExtendedDynamicStateFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, sType));
#endif
#ifdef VK_EXT_extended_dynamic_state
    exports["VkPhysicalDeviceExtendedDynamicStateFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_extended_dynamic_state
    exports["VkPhysicalDeviceExtendedDynamicStateFeaturesEXT_extendedDynamicState_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, extendedDynamicState));
#endif
#ifdef VK_EXT_extended_dynamic_state
    exports["VkPhysicalDeviceExtendedDynamicStateFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT));
#endif
#ifdef VK_EXT_extended_dynamic_state2
    exports["VkPhysicalDeviceExtendedDynamicState2FeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, sType));
#endif
#ifdef VK_EXT_extended_dynamic_state2
    exports["VkPhysicalDeviceExtendedDynamicState2FeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, pNext));
#endif
#ifdef VK_EXT_extended_dynamic_state2
    exports["VkPhysicalDeviceExtendedDynamicState2FeaturesEXT_extendedDynamicState2_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, extendedDynamicState2));
#endif
#ifdef VK_EXT_extended_dynamic_state2
    exports["VkPhysicalDeviceExtendedDynamicState2FeaturesEXT_extendedDynamicState2LogicOp_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, extendedDynamicState2LogicOp));
#endif
#ifdef VK_EXT_extended_dynamic_state2
    exports["VkPhysicalDeviceExtendedDynamicState2FeaturesEXT_extendedDynamicState2PatchControlPoints_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, extendedDynamicState2PatchControlPoints));
#endif
#ifdef VK_EXT_extended_dynamic_state2
    exports["VkPhysicalDeviceExtendedDynamicState2FeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, sType));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, pNext));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3TessellationDomainOrigin_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3TessellationDomainOrigin));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3DepthClampEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3DepthClampEnable));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3PolygonMode_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3PolygonMode));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3RasterizationSamples_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3RasterizationSamples));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3SampleMask_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3SampleMask));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3AlphaToCoverageEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3AlphaToCoverageEnable));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3AlphaToOneEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3AlphaToOneEnable));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3LogicOpEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3LogicOpEnable));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3ColorBlendEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ColorBlendEnable));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3ColorBlendEquation_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ColorBlendEquation));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3ColorWriteMask_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ColorWriteMask));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3RasterizationStream_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3RasterizationStream));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3ConservativeRasterizationMode_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ConservativeRasterizationMode));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3ExtraPrimitiveOverestimationSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ExtraPrimitiveOverestimationSize));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3DepthClipEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3DepthClipEnable));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3SampleLocationsEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3SampleLocationsEnable));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3ColorBlendAdvanced_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ColorBlendAdvanced));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3ProvokingVertexMode_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ProvokingVertexMode));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3LineRasterizationMode_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3LineRasterizationMode));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3LineStippleEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3LineStippleEnable));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3DepthClipNegativeOneToOne_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3DepthClipNegativeOneToOne));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3ViewportWScalingEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ViewportWScalingEnable));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3ViewportSwizzle_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ViewportSwizzle));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3CoverageToColorEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3CoverageToColorEnable));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3CoverageToColorLocation_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3CoverageToColorLocation));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3CoverageModulationMode_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3CoverageModulationMode));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3CoverageModulationTableEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3CoverageModulationTableEnable));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3CoverageModulationTable_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3CoverageModulationTable));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3CoverageReductionMode_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3CoverageReductionMode));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3RepresentativeFragmentTestEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3RepresentativeFragmentTestEnable));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_extendedDynamicState3ShadingRateImageEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ShadingRateImageEnable));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3FeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3PropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT, sType));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3PropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT, pNext));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3PropertiesEXT_dynamicPrimitiveTopologyUnrestricted_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT, dynamicPrimitiveTopologyUnrestricted));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkPhysicalDeviceExtendedDynamicState3PropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkColorBlendEquationEXT_srcColorBlendFactor_offsetof"] = Napi::Number::New(env, offsetof(VkColorBlendEquationEXT, srcColorBlendFactor));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkColorBlendEquationEXT_dstColorBlendFactor_offsetof"] = Napi::Number::New(env, offsetof(VkColorBlendEquationEXT, dstColorBlendFactor));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkColorBlendEquationEXT_colorBlendOp_offsetof"] = Napi::Number::New(env, offsetof(VkColorBlendEquationEXT, colorBlendOp));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkColorBlendEquationEXT_srcAlphaBlendFactor_offsetof"] = Napi::Number::New(env, offsetof(VkColorBlendEquationEXT, srcAlphaBlendFactor));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkColorBlendEquationEXT_dstAlphaBlendFactor_offsetof"] = Napi::Number::New(env, offsetof(VkColorBlendEquationEXT, dstAlphaBlendFactor));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkColorBlendEquationEXT_alphaBlendOp_offsetof"] = Napi::Number::New(env, offsetof(VkColorBlendEquationEXT, alphaBlendOp));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkColorBlendEquationEXT_sizeof"] = Napi::Number::New(env, sizeof(VkColorBlendEquationEXT));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkColorBlendAdvancedEXT_advancedBlendOp_offsetof"] = Napi::Number::New(env, offsetof(VkColorBlendAdvancedEXT, advancedBlendOp));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkColorBlendAdvancedEXT_srcPremultiplied_offsetof"] = Napi::Number::New(env, offsetof(VkColorBlendAdvancedEXT, srcPremultiplied));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkColorBlendAdvancedEXT_dstPremultiplied_offsetof"] = Napi::Number::New(env, offsetof(VkColorBlendAdvancedEXT, dstPremultiplied));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkColorBlendAdvancedEXT_blendOverlap_offsetof"] = Napi::Number::New(env, offsetof(VkColorBlendAdvancedEXT, blendOverlap));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkColorBlendAdvancedEXT_clampResults_offsetof"] = Napi::Number::New(env, offsetof(VkColorBlendAdvancedEXT, clampResults));
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["VkColorBlendAdvancedEXT_sizeof"] = Napi::Number::New(env, sizeof(VkColorBlendAdvancedEXT));
#endif
#ifdef VK_QCOM_render_pass_transform
    exports["VkRenderPassTransformBeginInfoQCOM_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassTransformBeginInfoQCOM, sType));
#endif
#ifdef VK_QCOM_render_pass_transform
    exports["VkRenderPassTransformBeginInfoQCOM_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassTransformBeginInfoQCOM, pNext));
#endif
#ifdef VK_QCOM_render_pass_transform
    exports["VkRenderPassTransformBeginInfoQCOM_transform_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassTransformBeginInfoQCOM, transform));
#endif
#ifdef VK_QCOM_render_pass_transform
    exports["VkRenderPassTransformBeginInfoQCOM_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassTransformBeginInfoQCOM));
#endif
#ifdef VK_QCOM_rotated_copy_commands
    exports["VkCopyCommandTransformInfoQCOM_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCopyCommandTransformInfoQCOM, sType));
#endif
#ifdef VK_QCOM_rotated_copy_commands
    exports["VkCopyCommandTransformInfoQCOM_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCopyCommandTransformInfoQCOM, pNext));
#endif
#ifdef VK_QCOM_rotated_copy_commands
    exports["VkCopyCommandTransformInfoQCOM_transform_offsetof"] = Napi::Number::New(env, offsetof(VkCopyCommandTransformInfoQCOM, transform));
#endif
#ifdef VK_QCOM_rotated_copy_commands
    exports["VkCopyCommandTransformInfoQCOM_sizeof"] = Napi::Number::New(env, sizeof(VkCopyCommandTransformInfoQCOM));
#endif
#ifdef VK_QCOM_render_pass_transform
    exports["VkCommandBufferInheritanceRenderPassTransformInfoQCOM_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceRenderPassTransformInfoQCOM, sType));
#endif
#ifdef VK_QCOM_render_pass_transform
    exports["VkCommandBufferInheritanceRenderPassTransformInfoQCOM_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceRenderPassTransformInfoQCOM, pNext));
#endif
#ifdef VK_QCOM_render_pass_transform
    exports["VkCommandBufferInheritanceRenderPassTransformInfoQCOM_transform_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceRenderPassTransformInfoQCOM, transform));
#endif
#ifdef VK_QCOM_render_pass_transform
    exports["VkCommandBufferInheritanceRenderPassTransformInfoQCOM_renderArea_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceRenderPassTransformInfoQCOM, renderArea));
#endif
#ifdef VK_QCOM_render_pass_transform
    exports["VkCommandBufferInheritanceRenderPassTransformInfoQCOM_sizeof"] = Napi::Number::New(env, sizeof(VkCommandBufferInheritanceRenderPassTransformInfoQCOM));
#endif
#ifdef VK_NV_device_diagnostics_config
    exports["VkPhysicalDeviceDiagnosticsConfigFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDiagnosticsConfigFeaturesNV, sType));
#endif
#ifdef VK_NV_device_diagnostics_config
    exports["VkPhysicalDeviceDiagnosticsConfigFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDiagnosticsConfigFeaturesNV, pNext));
#endif
#ifdef VK_NV_device_diagnostics_config
    exports["VkPhysicalDeviceDiagnosticsConfigFeaturesNV_diagnosticsConfig_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDiagnosticsConfigFeaturesNV, diagnosticsConfig));
#endif
#ifdef VK_NV_device_diagnostics_config
    exports["VkPhysicalDeviceDiagnosticsConfigFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDiagnosticsConfigFeaturesNV));
#endif
#ifdef VK_NV_device_diagnostics_config
    exports["VkDeviceDiagnosticsConfigCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceDiagnosticsConfigCreateInfoNV, sType));
#endif
#ifdef VK_NV_device_diagnostics_config
    exports["VkDeviceDiagnosticsConfigCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceDiagnosticsConfigCreateInfoNV, pNext));
#endif
#ifdef VK_NV_device_diagnostics_config
    exports["VkDeviceDiagnosticsConfigCreateInfoNV_flags_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceDiagnosticsConfigCreateInfoNV, flags));
#endif
#ifdef VK_NV_device_diagnostics_config
    exports["VkDeviceDiagnosticsConfigCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceDiagnosticsConfigCreateInfoNV));
#endif
    exports["VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures, sType));
    exports["VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures, pNext));
    exports["VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures_shaderZeroInitializeWorkgroupMemory_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures, shaderZeroInitializeWorkgroupMemory));
    exports["VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures));
#ifdef VK_KHR_zero_initialize_workgroup_memory
    exports["VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR));
#endif
#ifdef VK_KHR_shader_subgroup_uniform_control_flow
    exports["VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR, sType));
#endif
#ifdef VK_KHR_shader_subgroup_uniform_control_flow
    exports["VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR, pNext));
#endif
#ifdef VK_KHR_shader_subgroup_uniform_control_flow
    exports["VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR_shaderSubgroupUniformControlFlow_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR, shaderSubgroupUniformControlFlow));
#endif
#ifdef VK_KHR_shader_subgroup_uniform_control_flow
    exports["VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR));
#endif
#ifdef VK_EXT_robustness2
    exports["VkPhysicalDeviceRobustness2FeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRobustness2FeaturesEXT, sType));
#endif
#ifdef VK_EXT_robustness2
    exports["VkPhysicalDeviceRobustness2FeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRobustness2FeaturesEXT, pNext));
#endif
#ifdef VK_EXT_robustness2
    exports["VkPhysicalDeviceRobustness2FeaturesEXT_robustBufferAccess2_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRobustness2FeaturesEXT, robustBufferAccess2));
#endif
#ifdef VK_EXT_robustness2
    exports["VkPhysicalDeviceRobustness2FeaturesEXT_robustImageAccess2_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRobustness2FeaturesEXT, robustImageAccess2));
#endif
#ifdef VK_EXT_robustness2
    exports["VkPhysicalDeviceRobustness2FeaturesEXT_nullDescriptor_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRobustness2FeaturesEXT, nullDescriptor));
#endif
#ifdef VK_EXT_robustness2
    exports["VkPhysicalDeviceRobustness2FeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceRobustness2FeaturesEXT));
#endif
#ifdef VK_EXT_robustness2
    exports["VkPhysicalDeviceRobustness2PropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRobustness2PropertiesEXT, sType));
#endif
#ifdef VK_EXT_robustness2
    exports["VkPhysicalDeviceRobustness2PropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRobustness2PropertiesEXT, pNext));
#endif
#ifdef VK_EXT_robustness2
    exports["VkPhysicalDeviceRobustness2PropertiesEXT_robustStorageBufferAccessSizeAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRobustness2PropertiesEXT, robustStorageBufferAccessSizeAlignment));
#endif
#ifdef VK_EXT_robustness2
    exports["VkPhysicalDeviceRobustness2PropertiesEXT_robustUniformBufferAccessSizeAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRobustness2PropertiesEXT, robustUniformBufferAccessSizeAlignment));
#endif
#ifdef VK_EXT_robustness2
    exports["VkPhysicalDeviceRobustness2PropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceRobustness2PropertiesEXT));
#endif
    exports["VkPhysicalDeviceImageRobustnessFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageRobustnessFeatures, sType));
    exports["VkPhysicalDeviceImageRobustnessFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageRobustnessFeatures, pNext));
    exports["VkPhysicalDeviceImageRobustnessFeatures_robustImageAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageRobustnessFeatures, robustImageAccess));
    exports["VkPhysicalDeviceImageRobustnessFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceImageRobustnessFeatures));
#ifdef VK_EXT_image_robustness
    exports["VkPhysicalDeviceImageRobustnessFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceImageRobustnessFeaturesEXT));
#endif
#ifdef VK_KHR_workgroup_memory_explicit_layout
    exports["VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, sType));
#endif
#ifdef VK_KHR_workgroup_memory_explicit_layout
    exports["VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, pNext));
#endif
#ifdef VK_KHR_workgroup_memory_explicit_layout
    exports["VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR_workgroupMemoryExplicitLayout_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, workgroupMemoryExplicitLayout));
#endif
#ifdef VK_KHR_workgroup_memory_explicit_layout
    exports["VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR_workgroupMemoryExplicitLayoutScalarBlockLayout_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, workgroupMemoryExplicitLayoutScalarBlockLayout));
#endif
#ifdef VK_KHR_workgroup_memory_explicit_layout
    exports["VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR_workgroupMemoryExplicitLayout8BitAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, workgroupMemoryExplicitLayout8BitAccess));
#endif
#ifdef VK_KHR_workgroup_memory_explicit_layout
    exports["VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR_workgroupMemoryExplicitLayout16BitAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, workgroupMemoryExplicitLayout16BitAccess));
#endif
#ifdef VK_KHR_workgroup_memory_explicit_layout
    exports["VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetFeaturesKHR, sType));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetFeaturesKHR, pNext));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_constantAlphaColorBlendFactors_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetFeaturesKHR, constantAlphaColorBlendFactors));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_events_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetFeaturesKHR, events));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_imageViewFormatReinterpretation_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetFeaturesKHR, imageViewFormatReinterpretation));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_imageViewFormatSwizzle_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetFeaturesKHR, imageViewFormatSwizzle));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_imageView2DOn3DImage_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetFeaturesKHR, imageView2DOn3DImage));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_multisampleArrayImage_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetFeaturesKHR, multisampleArrayImage));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_mutableComparisonSamplers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetFeaturesKHR, mutableComparisonSamplers));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_pointPolygons_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetFeaturesKHR, pointPolygons));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_samplerMipLodBias_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetFeaturesKHR, samplerMipLodBias));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_separateStencilMaskRef_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetFeaturesKHR, separateStencilMaskRef));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_shaderSampleRateInterpolationFunctions_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetFeaturesKHR, shaderSampleRateInterpolationFunctions));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_tessellationIsolines_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetFeaturesKHR, tessellationIsolines));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_tessellationPointMode_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetFeaturesKHR, tessellationPointMode));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_triangleFans_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetFeaturesKHR, triangleFans));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_vertexAttributeAccessBeyondStride_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetFeaturesKHR, vertexAttributeAccessBeyondStride));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePortabilitySubsetFeaturesKHR));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetPropertiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetPropertiesKHR, sType));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetPropertiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetPropertiesKHR, pNext));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetPropertiesKHR_minVertexInputBindingStrideAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePortabilitySubsetPropertiesKHR, minVertexInputBindingStrideAlignment));
#endif
#ifdef VK_KHR_portability_subset
    exports["VkPhysicalDevicePortabilitySubsetPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePortabilitySubsetPropertiesKHR));
#endif
#ifdef VK_EXT_4444_formats
    exports["VkPhysicalDevice4444FormatsFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevice4444FormatsFeaturesEXT, sType));
#endif
#ifdef VK_EXT_4444_formats
    exports["VkPhysicalDevice4444FormatsFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevice4444FormatsFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_4444_formats
    exports["VkPhysicalDevice4444FormatsFeaturesEXT_formatA4R4G4B4_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevice4444FormatsFeaturesEXT, formatA4R4G4B4));
#endif
#ifdef VK_EXT_4444_formats
    exports["VkPhysicalDevice4444FormatsFeaturesEXT_formatA4B4G4R4_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevice4444FormatsFeaturesEXT, formatA4B4G4R4));
#endif
#ifdef VK_EXT_4444_formats
    exports["VkPhysicalDevice4444FormatsFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevice4444FormatsFeaturesEXT));
#endif
#ifdef VK_HUAWEI_subpass_shading
    exports["VkPhysicalDeviceSubpassShadingFeaturesHUAWEI_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI, sType));
#endif
#ifdef VK_HUAWEI_subpass_shading
    exports["VkPhysicalDeviceSubpassShadingFeaturesHUAWEI_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI, pNext));
#endif
#ifdef VK_HUAWEI_subpass_shading
    exports["VkPhysicalDeviceSubpassShadingFeaturesHUAWEI_subpassShading_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI, subpassShading));
#endif
#ifdef VK_HUAWEI_subpass_shading
    exports["VkPhysicalDeviceSubpassShadingFeaturesHUAWEI_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI));
#endif
    exports["VkBufferCopy2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCopy2, sType));
    exports["VkBufferCopy2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCopy2, pNext));
    exports["VkBufferCopy2_srcOffset_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCopy2, srcOffset));
    exports["VkBufferCopy2_dstOffset_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCopy2, dstOffset));
    exports["VkBufferCopy2_size_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCopy2, size));
    exports["VkBufferCopy2_sizeof"] = Napi::Number::New(env, sizeof(VkBufferCopy2));
#ifdef VK_KHR_copy_commands2
    exports["VkBufferCopy2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkBufferCopy2KHR));
#endif
    exports["VkImageCopy2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageCopy2, sType));
    exports["VkImageCopy2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageCopy2, pNext));
    exports["VkImageCopy2_srcSubresource_offsetof"] = Napi::Number::New(env, offsetof(VkImageCopy2, srcSubresource));
    exports["VkImageCopy2_srcOffset_offsetof"] = Napi::Number::New(env, offsetof(VkImageCopy2, srcOffset));
    exports["VkImageCopy2_dstSubresource_offsetof"] = Napi::Number::New(env, offsetof(VkImageCopy2, dstSubresource));
    exports["VkImageCopy2_dstOffset_offsetof"] = Napi::Number::New(env, offsetof(VkImageCopy2, dstOffset));
    exports["VkImageCopy2_extent_offsetof"] = Napi::Number::New(env, offsetof(VkImageCopy2, extent));
    exports["VkImageCopy2_sizeof"] = Napi::Number::New(env, sizeof(VkImageCopy2));
#ifdef VK_KHR_copy_commands2
    exports["VkImageCopy2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkImageCopy2KHR));
#endif
    exports["VkImageBlit2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageBlit2, sType));
    exports["VkImageBlit2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageBlit2, pNext));
    exports["VkImageBlit2_srcSubresource_offsetof"] = Napi::Number::New(env, offsetof(VkImageBlit2, srcSubresource));
    exports["VkImageBlit2_srcOffsets_offsetof"] = Napi::Number::New(env, offsetof(VkImageBlit2, srcOffsets));
    exports["VkImageBlit2_dstSubresource_offsetof"] = Napi::Number::New(env, offsetof(VkImageBlit2, dstSubresource));
    exports["VkImageBlit2_dstOffsets_offsetof"] = Napi::Number::New(env, offsetof(VkImageBlit2, dstOffsets));
    exports["VkImageBlit2_sizeof"] = Napi::Number::New(env, sizeof(VkImageBlit2));
#ifdef VK_KHR_copy_commands2
    exports["VkImageBlit2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkImageBlit2KHR));
#endif
    exports["VkBufferImageCopy2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBufferImageCopy2, sType));
    exports["VkBufferImageCopy2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBufferImageCopy2, pNext));
    exports["VkBufferImageCopy2_bufferOffset_offsetof"] = Napi::Number::New(env, offsetof(VkBufferImageCopy2, bufferOffset));
    exports["VkBufferImageCopy2_bufferRowLength_offsetof"] = Napi::Number::New(env, offsetof(VkBufferImageCopy2, bufferRowLength));
    exports["VkBufferImageCopy2_bufferImageHeight_offsetof"] = Napi::Number::New(env, offsetof(VkBufferImageCopy2, bufferImageHeight));
    exports["VkBufferImageCopy2_imageSubresource_offsetof"] = Napi::Number::New(env, offsetof(VkBufferImageCopy2, imageSubresource));
    exports["VkBufferImageCopy2_imageOffset_offsetof"] = Napi::Number::New(env, offsetof(VkBufferImageCopy2, imageOffset));
    exports["VkBufferImageCopy2_imageExtent_offsetof"] = Napi::Number::New(env, offsetof(VkBufferImageCopy2, imageExtent));
    exports["VkBufferImageCopy2_sizeof"] = Napi::Number::New(env, sizeof(VkBufferImageCopy2));
#ifdef VK_KHR_copy_commands2
    exports["VkBufferImageCopy2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkBufferImageCopy2KHR));
#endif
    exports["VkImageResolve2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageResolve2, sType));
    exports["VkImageResolve2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageResolve2, pNext));
    exports["VkImageResolve2_srcSubresource_offsetof"] = Napi::Number::New(env, offsetof(VkImageResolve2, srcSubresource));
    exports["VkImageResolve2_srcOffset_offsetof"] = Napi::Number::New(env, offsetof(VkImageResolve2, srcOffset));
    exports["VkImageResolve2_dstSubresource_offsetof"] = Napi::Number::New(env, offsetof(VkImageResolve2, dstSubresource));
    exports["VkImageResolve2_dstOffset_offsetof"] = Napi::Number::New(env, offsetof(VkImageResolve2, dstOffset));
    exports["VkImageResolve2_extent_offsetof"] = Napi::Number::New(env, offsetof(VkImageResolve2, extent));
    exports["VkImageResolve2_sizeof"] = Napi::Number::New(env, sizeof(VkImageResolve2));
#ifdef VK_KHR_copy_commands2
    exports["VkImageResolve2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkImageResolve2KHR));
#endif
    exports["VkCopyBufferInfo2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCopyBufferInfo2, sType));
    exports["VkCopyBufferInfo2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCopyBufferInfo2, pNext));
    exports["VkCopyBufferInfo2_srcBuffer_offsetof"] = Napi::Number::New(env, offsetof(VkCopyBufferInfo2, srcBuffer));
    exports["VkCopyBufferInfo2_dstBuffer_offsetof"] = Napi::Number::New(env, offsetof(VkCopyBufferInfo2, dstBuffer));
    exports["VkCopyBufferInfo2_regionCount_offsetof"] = Napi::Number::New(env, offsetof(VkCopyBufferInfo2, regionCount));
    exports["VkCopyBufferInfo2_pRegions_offsetof"] = Napi::Number::New(env, offsetof(VkCopyBufferInfo2, pRegions));
    exports["VkCopyBufferInfo2_sizeof"] = Napi::Number::New(env, sizeof(VkCopyBufferInfo2));
#ifdef VK_KHR_copy_commands2
    exports["VkCopyBufferInfo2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkCopyBufferInfo2KHR));
#endif
    exports["VkCopyImageInfo2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCopyImageInfo2, sType));
    exports["VkCopyImageInfo2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCopyImageInfo2, pNext));
    exports["VkCopyImageInfo2_srcImage_offsetof"] = Napi::Number::New(env, offsetof(VkCopyImageInfo2, srcImage));
    exports["VkCopyImageInfo2_srcImageLayout_offsetof"] = Napi::Number::New(env, offsetof(VkCopyImageInfo2, srcImageLayout));
    exports["VkCopyImageInfo2_dstImage_offsetof"] = Napi::Number::New(env, offsetof(VkCopyImageInfo2, dstImage));
    exports["VkCopyImageInfo2_dstImageLayout_offsetof"] = Napi::Number::New(env, offsetof(VkCopyImageInfo2, dstImageLayout));
    exports["VkCopyImageInfo2_regionCount_offsetof"] = Napi::Number::New(env, offsetof(VkCopyImageInfo2, regionCount));
    exports["VkCopyImageInfo2_pRegions_offsetof"] = Napi::Number::New(env, offsetof(VkCopyImageInfo2, pRegions));
    exports["VkCopyImageInfo2_sizeof"] = Napi::Number::New(env, sizeof(VkCopyImageInfo2));
#ifdef VK_KHR_copy_commands2
    exports["VkCopyImageInfo2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkCopyImageInfo2KHR));
#endif
    exports["VkBlitImageInfo2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBlitImageInfo2, sType));
    exports["VkBlitImageInfo2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBlitImageInfo2, pNext));
    exports["VkBlitImageInfo2_srcImage_offsetof"] = Napi::Number::New(env, offsetof(VkBlitImageInfo2, srcImage));
    exports["VkBlitImageInfo2_srcImageLayout_offsetof"] = Napi::Number::New(env, offsetof(VkBlitImageInfo2, srcImageLayout));
    exports["VkBlitImageInfo2_dstImage_offsetof"] = Napi::Number::New(env, offsetof(VkBlitImageInfo2, dstImage));
    exports["VkBlitImageInfo2_dstImageLayout_offsetof"] = Napi::Number::New(env, offsetof(VkBlitImageInfo2, dstImageLayout));
    exports["VkBlitImageInfo2_regionCount_offsetof"] = Napi::Number::New(env, offsetof(VkBlitImageInfo2, regionCount));
    exports["VkBlitImageInfo2_pRegions_offsetof"] = Napi::Number::New(env, offsetof(VkBlitImageInfo2, pRegions));
    exports["VkBlitImageInfo2_filter_offsetof"] = Napi::Number::New(env, offsetof(VkBlitImageInfo2, filter));
    exports["VkBlitImageInfo2_sizeof"] = Napi::Number::New(env, sizeof(VkBlitImageInfo2));
#ifdef VK_KHR_copy_commands2
    exports["VkBlitImageInfo2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkBlitImageInfo2KHR));
#endif
    exports["VkCopyBufferToImageInfo2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCopyBufferToImageInfo2, sType));
    exports["VkCopyBufferToImageInfo2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCopyBufferToImageInfo2, pNext));
    exports["VkCopyBufferToImageInfo2_srcBuffer_offsetof"] = Napi::Number::New(env, offsetof(VkCopyBufferToImageInfo2, srcBuffer));
    exports["VkCopyBufferToImageInfo2_dstImage_offsetof"] = Napi::Number::New(env, offsetof(VkCopyBufferToImageInfo2, dstImage));
    exports["VkCopyBufferToImageInfo2_dstImageLayout_offsetof"] = Napi::Number::New(env, offsetof(VkCopyBufferToImageInfo2, dstImageLayout));
    exports["VkCopyBufferToImageInfo2_regionCount_offsetof"] = Napi::Number::New(env, offsetof(VkCopyBufferToImageInfo2, regionCount));
    exports["VkCopyBufferToImageInfo2_pRegions_offsetof"] = Napi::Number::New(env, offsetof(VkCopyBufferToImageInfo2, pRegions));
    exports["VkCopyBufferToImageInfo2_sizeof"] = Napi::Number::New(env, sizeof(VkCopyBufferToImageInfo2));
#ifdef VK_KHR_copy_commands2
    exports["VkCopyBufferToImageInfo2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkCopyBufferToImageInfo2KHR));
#endif
    exports["VkCopyImageToBufferInfo2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCopyImageToBufferInfo2, sType));
    exports["VkCopyImageToBufferInfo2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCopyImageToBufferInfo2, pNext));
    exports["VkCopyImageToBufferInfo2_srcImage_offsetof"] = Napi::Number::New(env, offsetof(VkCopyImageToBufferInfo2, srcImage));
    exports["VkCopyImageToBufferInfo2_srcImageLayout_offsetof"] = Napi::Number::New(env, offsetof(VkCopyImageToBufferInfo2, srcImageLayout));
    exports["VkCopyImageToBufferInfo2_dstBuffer_offsetof"] = Napi::Number::New(env, offsetof(VkCopyImageToBufferInfo2, dstBuffer));
    exports["VkCopyImageToBufferInfo2_regionCount_offsetof"] = Napi::Number::New(env, offsetof(VkCopyImageToBufferInfo2, regionCount));
    exports["VkCopyImageToBufferInfo2_pRegions_offsetof"] = Napi::Number::New(env, offsetof(VkCopyImageToBufferInfo2, pRegions));
    exports["VkCopyImageToBufferInfo2_sizeof"] = Napi::Number::New(env, sizeof(VkCopyImageToBufferInfo2));
#ifdef VK_KHR_copy_commands2
    exports["VkCopyImageToBufferInfo2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkCopyImageToBufferInfo2KHR));
#endif
    exports["VkResolveImageInfo2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkResolveImageInfo2, sType));
    exports["VkResolveImageInfo2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkResolveImageInfo2, pNext));
    exports["VkResolveImageInfo2_srcImage_offsetof"] = Napi::Number::New(env, offsetof(VkResolveImageInfo2, srcImage));
    exports["VkResolveImageInfo2_srcImageLayout_offsetof"] = Napi::Number::New(env, offsetof(VkResolveImageInfo2, srcImageLayout));
    exports["VkResolveImageInfo2_dstImage_offsetof"] = Napi::Number::New(env, offsetof(VkResolveImageInfo2, dstImage));
    exports["VkResolveImageInfo2_dstImageLayout_offsetof"] = Napi::Number::New(env, offsetof(VkResolveImageInfo2, dstImageLayout));
    exports["VkResolveImageInfo2_regionCount_offsetof"] = Napi::Number::New(env, offsetof(VkResolveImageInfo2, regionCount));
    exports["VkResolveImageInfo2_pRegions_offsetof"] = Napi::Number::New(env, offsetof(VkResolveImageInfo2, pRegions));
    exports["VkResolveImageInfo2_sizeof"] = Napi::Number::New(env, sizeof(VkResolveImageInfo2));
#ifdef VK_KHR_copy_commands2
    exports["VkResolveImageInfo2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkResolveImageInfo2KHR));
#endif
#ifdef VK_EXT_shader_image_atomic_int64
    exports["VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, sType));
#endif
#ifdef VK_EXT_shader_image_atomic_int64
    exports["VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, pNext));
#endif
#ifdef VK_EXT_shader_image_atomic_int64
    exports["VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT_shaderImageInt64Atomics_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, shaderImageInt64Atomics));
#endif
#ifdef VK_EXT_shader_image_atomic_int64
    exports["VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT_sparseImageInt64Atomics_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, sparseImageInt64Atomics));
#endif
#ifdef VK_EXT_shader_image_atomic_int64
    exports["VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkFragmentShadingRateAttachmentInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkFragmentShadingRateAttachmentInfoKHR, sType));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkFragmentShadingRateAttachmentInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkFragmentShadingRateAttachmentInfoKHR, pNext));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkFragmentShadingRateAttachmentInfoKHR_pFragmentShadingRateAttachment_offsetof"] = Napi::Number::New(env, offsetof(VkFragmentShadingRateAttachmentInfoKHR, pFragmentShadingRateAttachment));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkFragmentShadingRateAttachmentInfoKHR_shadingRateAttachmentTexelSize_offsetof"] = Napi::Number::New(env, offsetof(VkFragmentShadingRateAttachmentInfoKHR, shadingRateAttachmentTexelSize));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkFragmentShadingRateAttachmentInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkFragmentShadingRateAttachmentInfoKHR));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPipelineFragmentShadingRateStateCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineFragmentShadingRateStateCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPipelineFragmentShadingRateStateCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineFragmentShadingRateStateCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPipelineFragmentShadingRateStateCreateInfoKHR_fragmentSize_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineFragmentShadingRateStateCreateInfoKHR, fragmentSize));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPipelineFragmentShadingRateStateCreateInfoKHR_combinerOps_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineFragmentShadingRateStateCreateInfoKHR, combinerOps));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPipelineFragmentShadingRateStateCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineFragmentShadingRateStateCreateInfoKHR));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRateFeaturesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRateFeaturesKHR, sType));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRateFeaturesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRateFeaturesKHR, pNext));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRateFeaturesKHR_pipelineFragmentShadingRate_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRateFeaturesKHR, pipelineFragmentShadingRate));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRateFeaturesKHR_primitiveFragmentShadingRate_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRateFeaturesKHR, primitiveFragmentShadingRate));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRateFeaturesKHR_attachmentFragmentShadingRate_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRateFeaturesKHR, attachmentFragmentShadingRate));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRateFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFragmentShadingRateFeaturesKHR));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, sType));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, pNext));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_minFragmentShadingRateAttachmentTexelSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, minFragmentShadingRateAttachmentTexelSize));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_maxFragmentShadingRateAttachmentTexelSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, maxFragmentShadingRateAttachmentTexelSize));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_maxFragmentShadingRateAttachmentTexelSizeAspectRatio_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, maxFragmentShadingRateAttachmentTexelSizeAspectRatio));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_primitiveFragmentShadingRateWithMultipleViewports_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, primitiveFragmentShadingRateWithMultipleViewports));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_layeredShadingRateAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, layeredShadingRateAttachments));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_fragmentShadingRateNonTrivialCombinerOps_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, fragmentShadingRateNonTrivialCombinerOps));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_maxFragmentSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, maxFragmentSize));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_maxFragmentSizeAspectRatio_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, maxFragmentSizeAspectRatio));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_maxFragmentShadingRateCoverageSamples_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, maxFragmentShadingRateCoverageSamples));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_maxFragmentShadingRateRasterizationSamples_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, maxFragmentShadingRateRasterizationSamples));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_fragmentShadingRateWithShaderDepthStencilWrites_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, fragmentShadingRateWithShaderDepthStencilWrites));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_fragmentShadingRateWithSampleMask_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, fragmentShadingRateWithSampleMask));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_fragmentShadingRateWithShaderSampleMask_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, fragmentShadingRateWithShaderSampleMask));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_fragmentShadingRateWithConservativeRasterization_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, fragmentShadingRateWithConservativeRasterization));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_fragmentShadingRateWithFragmentShaderInterlock_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, fragmentShadingRateWithFragmentShaderInterlock));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_fragmentShadingRateWithCustomSampleLocations_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, fragmentShadingRateWithCustomSampleLocations));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_fragmentShadingRateStrictMultiplyCombiner_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, fragmentShadingRateStrictMultiplyCombiner));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRatePropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRateKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRateKHR, sType));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRateKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRateKHR, pNext));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRateKHR_sampleCounts_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRateKHR, sampleCounts));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRateKHR_fragmentSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRateKHR, fragmentSize));
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["VkPhysicalDeviceFragmentShadingRateKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFragmentShadingRateKHR));
#endif
    exports["VkPhysicalDeviceShaderTerminateInvocationFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderTerminateInvocationFeatures, sType));
    exports["VkPhysicalDeviceShaderTerminateInvocationFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderTerminateInvocationFeatures, pNext));
    exports["VkPhysicalDeviceShaderTerminateInvocationFeatures_shaderTerminateInvocation_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderTerminateInvocationFeatures, shaderTerminateInvocation));
    exports["VkPhysicalDeviceShaderTerminateInvocationFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderTerminateInvocationFeatures));
#ifdef VK_KHR_shader_terminate_invocation
    exports["VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR));
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    exports["VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, sType));
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    exports["VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, pNext));
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    exports["VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV_fragmentShadingRateEnums_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, fragmentShadingRateEnums));
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    exports["VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV_supersampleFragmentShadingRates_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, supersampleFragmentShadingRates));
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    exports["VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV_noInvocationFragmentShadingRates_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, noInvocationFragmentShadingRates));
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    exports["VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV));
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    exports["VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV, sType));
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    exports["VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV, pNext));
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    exports["VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV_maxFragmentShadingRateInvocationCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV, maxFragmentShadingRateInvocationCount));
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    exports["VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV));
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    exports["VkPipelineFragmentShadingRateEnumStateCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineFragmentShadingRateEnumStateCreateInfoNV, sType));
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    exports["VkPipelineFragmentShadingRateEnumStateCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineFragmentShadingRateEnumStateCreateInfoNV, pNext));
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    exports["VkPipelineFragmentShadingRateEnumStateCreateInfoNV_shadingRateType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineFragmentShadingRateEnumStateCreateInfoNV, shadingRateType));
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    exports["VkPipelineFragmentShadingRateEnumStateCreateInfoNV_shadingRate_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineFragmentShadingRateEnumStateCreateInfoNV, shadingRate));
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    exports["VkPipelineFragmentShadingRateEnumStateCreateInfoNV_combinerOps_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineFragmentShadingRateEnumStateCreateInfoNV, combinerOps));
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    exports["VkPipelineFragmentShadingRateEnumStateCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineFragmentShadingRateEnumStateCreateInfoNV));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildSizesInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildSizesInfoKHR, sType));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildSizesInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildSizesInfoKHR, pNext));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildSizesInfoKHR_accelerationStructureSize_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildSizesInfoKHR, accelerationStructureSize));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildSizesInfoKHR_updateScratchSize_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildSizesInfoKHR, updateScratchSize));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildSizesInfoKHR_buildScratchSize_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureBuildSizesInfoKHR, buildScratchSize));
#endif
#ifdef VK_KHR_acceleration_structure
    exports["VkAccelerationStructureBuildSizesInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureBuildSizesInfoKHR));
#endif
#ifdef VK_EXT_image_2d_view_of_3d
    exports["VkPhysicalDeviceImage2DViewOf3DFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT, sType));
#endif
#ifdef VK_EXT_image_2d_view_of_3d
    exports["VkPhysicalDeviceImage2DViewOf3DFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_image_2d_view_of_3d
    exports["VkPhysicalDeviceImage2DViewOf3DFeaturesEXT_image2DViewOf3D_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT, image2DViewOf3D));
#endif
#ifdef VK_EXT_image_2d_view_of_3d
    exports["VkPhysicalDeviceImage2DViewOf3DFeaturesEXT_sampler2DViewOf3D_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT, sampler2DViewOf3D));
#endif
#ifdef VK_EXT_image_2d_view_of_3d
    exports["VkPhysicalDeviceImage2DViewOf3DFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT));
#endif
#ifdef VK_EXT_mutable_descriptor_type
    exports["VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT, sType));
#endif
#ifdef VK_EXT_mutable_descriptor_type
    exports["VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_mutable_descriptor_type
    exports["VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT_mutableDescriptorType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT, mutableDescriptorType));
#endif
#ifdef VK_EXT_mutable_descriptor_type
    exports["VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT));
#endif
#ifdef VK_VALVE_mutable_descriptor_type
    exports["VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE));
#endif
#ifdef VK_EXT_mutable_descriptor_type
    exports["VkMutableDescriptorTypeListEXT_descriptorTypeCount_offsetof"] = Napi::Number::New(env, offsetof(VkMutableDescriptorTypeListEXT, descriptorTypeCount));
#endif
#ifdef VK_EXT_mutable_descriptor_type
    exports["VkMutableDescriptorTypeListEXT_pDescriptorTypes_offsetof"] = Napi::Number::New(env, offsetof(VkMutableDescriptorTypeListEXT, pDescriptorTypes));
#endif
#ifdef VK_EXT_mutable_descriptor_type
    exports["VkMutableDescriptorTypeListEXT_sizeof"] = Napi::Number::New(env, sizeof(VkMutableDescriptorTypeListEXT));
#endif
#ifdef VK_VALVE_mutable_descriptor_type
    exports["VkMutableDescriptorTypeListVALVE_sizeof"] = Napi::Number::New(env, sizeof(VkMutableDescriptorTypeListVALVE));
#endif
#ifdef VK_EXT_mutable_descriptor_type
    exports["VkMutableDescriptorTypeCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMutableDescriptorTypeCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_mutable_descriptor_type
    exports["VkMutableDescriptorTypeCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMutableDescriptorTypeCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_mutable_descriptor_type
    exports["VkMutableDescriptorTypeCreateInfoEXT_mutableDescriptorTypeListCount_offsetof"] = Napi::Number::New(env, offsetof(VkMutableDescriptorTypeCreateInfoEXT, mutableDescriptorTypeListCount));
#endif
#ifdef VK_EXT_mutable_descriptor_type
    exports["VkMutableDescriptorTypeCreateInfoEXT_pMutableDescriptorTypeLists_offsetof"] = Napi::Number::New(env, offsetof(VkMutableDescriptorTypeCreateInfoEXT, pMutableDescriptorTypeLists));
#endif
#ifdef VK_EXT_mutable_descriptor_type
    exports["VkMutableDescriptorTypeCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkMutableDescriptorTypeCreateInfoEXT));
#endif
#ifdef VK_VALVE_mutable_descriptor_type
    exports["VkMutableDescriptorTypeCreateInfoVALVE_sizeof"] = Napi::Number::New(env, sizeof(VkMutableDescriptorTypeCreateInfoVALVE));
#endif
#ifdef VK_EXT_depth_clip_control
    exports["VkPhysicalDeviceDepthClipControlFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDepthClipControlFeaturesEXT, sType));
#endif
#ifdef VK_EXT_depth_clip_control
    exports["VkPhysicalDeviceDepthClipControlFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDepthClipControlFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_depth_clip_control
    exports["VkPhysicalDeviceDepthClipControlFeaturesEXT_depthClipControl_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDepthClipControlFeaturesEXT, depthClipControl));
#endif
#ifdef VK_EXT_depth_clip_control
    exports["VkPhysicalDeviceDepthClipControlFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDepthClipControlFeaturesEXT));
#endif
#ifdef VK_EXT_depth_clip_control
    exports["VkPipelineViewportDepthClipControlCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportDepthClipControlCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_depth_clip_control
    exports["VkPipelineViewportDepthClipControlCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportDepthClipControlCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_depth_clip_control
    exports["VkPipelineViewportDepthClipControlCreateInfoEXT_negativeOneToOne_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineViewportDepthClipControlCreateInfoEXT, negativeOneToOne));
#endif
#ifdef VK_EXT_depth_clip_control
    exports["VkPipelineViewportDepthClipControlCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineViewportDepthClipControlCreateInfoEXT));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT, sType));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT_vertexInputDynamicState_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT, vertexInputDynamicState));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT));
#endif
#ifdef VK_NV_external_memory_rdma
    exports["VkPhysicalDeviceExternalMemoryRDMAFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalMemoryRDMAFeaturesNV, sType));
#endif
#ifdef VK_NV_external_memory_rdma
    exports["VkPhysicalDeviceExternalMemoryRDMAFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalMemoryRDMAFeaturesNV, pNext));
#endif
#ifdef VK_NV_external_memory_rdma
    exports["VkPhysicalDeviceExternalMemoryRDMAFeaturesNV_externalMemoryRDMA_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceExternalMemoryRDMAFeaturesNV, externalMemoryRDMA));
#endif
#ifdef VK_NV_external_memory_rdma
    exports["VkPhysicalDeviceExternalMemoryRDMAFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceExternalMemoryRDMAFeaturesNV));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkVertexInputBindingDescription2EXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputBindingDescription2EXT, sType));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkVertexInputBindingDescription2EXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputBindingDescription2EXT, pNext));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkVertexInputBindingDescription2EXT_binding_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputBindingDescription2EXT, binding));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkVertexInputBindingDescription2EXT_stride_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputBindingDescription2EXT, stride));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkVertexInputBindingDescription2EXT_inputRate_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputBindingDescription2EXT, inputRate));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkVertexInputBindingDescription2EXT_divisor_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputBindingDescription2EXT, divisor));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkVertexInputBindingDescription2EXT_sizeof"] = Napi::Number::New(env, sizeof(VkVertexInputBindingDescription2EXT));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkVertexInputAttributeDescription2EXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputAttributeDescription2EXT, sType));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkVertexInputAttributeDescription2EXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputAttributeDescription2EXT, pNext));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkVertexInputAttributeDescription2EXT_location_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputAttributeDescription2EXT, location));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkVertexInputAttributeDescription2EXT_binding_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputAttributeDescription2EXT, binding));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkVertexInputAttributeDescription2EXT_format_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputAttributeDescription2EXT, format));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkVertexInputAttributeDescription2EXT_offset_offsetof"] = Napi::Number::New(env, offsetof(VkVertexInputAttributeDescription2EXT, offset));
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["VkVertexInputAttributeDescription2EXT_sizeof"] = Napi::Number::New(env, sizeof(VkVertexInputAttributeDescription2EXT));
#endif
#ifdef VK_EXT_color_write_enable
    exports["VkPhysicalDeviceColorWriteEnableFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceColorWriteEnableFeaturesEXT, sType));
#endif
#ifdef VK_EXT_color_write_enable
    exports["VkPhysicalDeviceColorWriteEnableFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceColorWriteEnableFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_color_write_enable
    exports["VkPhysicalDeviceColorWriteEnableFeaturesEXT_colorWriteEnable_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceColorWriteEnableFeaturesEXT, colorWriteEnable));
#endif
#ifdef VK_EXT_color_write_enable
    exports["VkPhysicalDeviceColorWriteEnableFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceColorWriteEnableFeaturesEXT));
#endif
#ifdef VK_EXT_color_write_enable
    exports["VkPipelineColorWriteCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorWriteCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_color_write_enable
    exports["VkPipelineColorWriteCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorWriteCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_color_write_enable
    exports["VkPipelineColorWriteCreateInfoEXT_attachmentCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorWriteCreateInfoEXT, attachmentCount));
#endif
#ifdef VK_EXT_color_write_enable
    exports["VkPipelineColorWriteCreateInfoEXT_pColorWriteEnables_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineColorWriteCreateInfoEXT, pColorWriteEnables));
#endif
#ifdef VK_EXT_color_write_enable
    exports["VkPipelineColorWriteCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineColorWriteCreateInfoEXT));
#endif
    exports["VkMemoryBarrier2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryBarrier2, sType));
    exports["VkMemoryBarrier2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryBarrier2, pNext));
    exports["VkMemoryBarrier2_srcStageMask_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryBarrier2, srcStageMask));
    exports["VkMemoryBarrier2_srcAccessMask_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryBarrier2, srcAccessMask));
    exports["VkMemoryBarrier2_dstStageMask_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryBarrier2, dstStageMask));
    exports["VkMemoryBarrier2_dstAccessMask_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryBarrier2, dstAccessMask));
    exports["VkMemoryBarrier2_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryBarrier2));
#ifdef VK_KHR_synchronization2
    exports["VkMemoryBarrier2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryBarrier2KHR));
#endif
    exports["VkImageMemoryBarrier2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier2, sType));
    exports["VkImageMemoryBarrier2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier2, pNext));
    exports["VkImageMemoryBarrier2_srcStageMask_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier2, srcStageMask));
    exports["VkImageMemoryBarrier2_srcAccessMask_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier2, srcAccessMask));
    exports["VkImageMemoryBarrier2_dstStageMask_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier2, dstStageMask));
    exports["VkImageMemoryBarrier2_dstAccessMask_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier2, dstAccessMask));
    exports["VkImageMemoryBarrier2_oldLayout_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier2, oldLayout));
    exports["VkImageMemoryBarrier2_newLayout_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier2, newLayout));
    exports["VkImageMemoryBarrier2_srcQueueFamilyIndex_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier2, srcQueueFamilyIndex));
    exports["VkImageMemoryBarrier2_dstQueueFamilyIndex_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier2, dstQueueFamilyIndex));
    exports["VkImageMemoryBarrier2_image_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier2, image));
    exports["VkImageMemoryBarrier2_subresourceRange_offsetof"] = Napi::Number::New(env, offsetof(VkImageMemoryBarrier2, subresourceRange));
    exports["VkImageMemoryBarrier2_sizeof"] = Napi::Number::New(env, sizeof(VkImageMemoryBarrier2));
#ifdef VK_KHR_synchronization2
    exports["VkImageMemoryBarrier2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkImageMemoryBarrier2KHR));
#endif
    exports["VkBufferMemoryBarrier2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier2, sType));
    exports["VkBufferMemoryBarrier2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier2, pNext));
    exports["VkBufferMemoryBarrier2_srcStageMask_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier2, srcStageMask));
    exports["VkBufferMemoryBarrier2_srcAccessMask_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier2, srcAccessMask));
    exports["VkBufferMemoryBarrier2_dstStageMask_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier2, dstStageMask));
    exports["VkBufferMemoryBarrier2_dstAccessMask_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier2, dstAccessMask));
    exports["VkBufferMemoryBarrier2_srcQueueFamilyIndex_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier2, srcQueueFamilyIndex));
    exports["VkBufferMemoryBarrier2_dstQueueFamilyIndex_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier2, dstQueueFamilyIndex));
    exports["VkBufferMemoryBarrier2_buffer_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier2, buffer));
    exports["VkBufferMemoryBarrier2_offset_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier2, offset));
    exports["VkBufferMemoryBarrier2_size_offsetof"] = Napi::Number::New(env, offsetof(VkBufferMemoryBarrier2, size));
    exports["VkBufferMemoryBarrier2_sizeof"] = Napi::Number::New(env, sizeof(VkBufferMemoryBarrier2));
#ifdef VK_KHR_synchronization2
    exports["VkBufferMemoryBarrier2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkBufferMemoryBarrier2KHR));
#endif
    exports["VkDependencyInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDependencyInfo, sType));
    exports["VkDependencyInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDependencyInfo, pNext));
    exports["VkDependencyInfo_dependencyFlags_offsetof"] = Napi::Number::New(env, offsetof(VkDependencyInfo, dependencyFlags));
    exports["VkDependencyInfo_memoryBarrierCount_offsetof"] = Napi::Number::New(env, offsetof(VkDependencyInfo, memoryBarrierCount));
    exports["VkDependencyInfo_pMemoryBarriers_offsetof"] = Napi::Number::New(env, offsetof(VkDependencyInfo, pMemoryBarriers));
    exports["VkDependencyInfo_bufferMemoryBarrierCount_offsetof"] = Napi::Number::New(env, offsetof(VkDependencyInfo, bufferMemoryBarrierCount));
    exports["VkDependencyInfo_pBufferMemoryBarriers_offsetof"] = Napi::Number::New(env, offsetof(VkDependencyInfo, pBufferMemoryBarriers));
    exports["VkDependencyInfo_imageMemoryBarrierCount_offsetof"] = Napi::Number::New(env, offsetof(VkDependencyInfo, imageMemoryBarrierCount));
    exports["VkDependencyInfo_pImageMemoryBarriers_offsetof"] = Napi::Number::New(env, offsetof(VkDependencyInfo, pImageMemoryBarriers));
    exports["VkDependencyInfo_sizeof"] = Napi::Number::New(env, sizeof(VkDependencyInfo));
#ifdef VK_KHR_synchronization2
    exports["VkDependencyInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkDependencyInfoKHR));
#endif
    exports["VkSemaphoreSubmitInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreSubmitInfo, sType));
    exports["VkSemaphoreSubmitInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreSubmitInfo, pNext));
    exports["VkSemaphoreSubmitInfo_semaphore_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreSubmitInfo, semaphore));
    exports["VkSemaphoreSubmitInfo_value_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreSubmitInfo, value));
    exports["VkSemaphoreSubmitInfo_stageMask_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreSubmitInfo, stageMask));
    exports["VkSemaphoreSubmitInfo_deviceIndex_offsetof"] = Napi::Number::New(env, offsetof(VkSemaphoreSubmitInfo, deviceIndex));
    exports["VkSemaphoreSubmitInfo_sizeof"] = Napi::Number::New(env, sizeof(VkSemaphoreSubmitInfo));
#ifdef VK_KHR_synchronization2
    exports["VkSemaphoreSubmitInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkSemaphoreSubmitInfoKHR));
#endif
    exports["VkCommandBufferSubmitInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferSubmitInfo, sType));
    exports["VkCommandBufferSubmitInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferSubmitInfo, pNext));
    exports["VkCommandBufferSubmitInfo_commandBuffer_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferSubmitInfo, commandBuffer));
    exports["VkCommandBufferSubmitInfo_deviceMask_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferSubmitInfo, deviceMask));
    exports["VkCommandBufferSubmitInfo_sizeof"] = Napi::Number::New(env, sizeof(VkCommandBufferSubmitInfo));
#ifdef VK_KHR_synchronization2
    exports["VkCommandBufferSubmitInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkCommandBufferSubmitInfoKHR));
#endif
    exports["VkSubmitInfo2_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo2, sType));
    exports["VkSubmitInfo2_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo2, pNext));
    exports["VkSubmitInfo2_flags_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo2, flags));
    exports["VkSubmitInfo2_waitSemaphoreInfoCount_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo2, waitSemaphoreInfoCount));
    exports["VkSubmitInfo2_pWaitSemaphoreInfos_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo2, pWaitSemaphoreInfos));
    exports["VkSubmitInfo2_commandBufferInfoCount_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo2, commandBufferInfoCount));
    exports["VkSubmitInfo2_pCommandBufferInfos_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo2, pCommandBufferInfos));
    exports["VkSubmitInfo2_signalSemaphoreInfoCount_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo2, signalSemaphoreInfoCount));
    exports["VkSubmitInfo2_pSignalSemaphoreInfos_offsetof"] = Napi::Number::New(env, offsetof(VkSubmitInfo2, pSignalSemaphoreInfos));
    exports["VkSubmitInfo2_sizeof"] = Napi::Number::New(env, sizeof(VkSubmitInfo2));
#ifdef VK_KHR_synchronization2
    exports["VkSubmitInfo2KHR_sizeof"] = Napi::Number::New(env, sizeof(VkSubmitInfo2KHR));
#endif
#ifdef VK_KHR_synchronization2
    exports["VkQueueFamilyCheckpointProperties2NV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyCheckpointProperties2NV, sType));
#endif
#ifdef VK_KHR_synchronization2
    exports["VkQueueFamilyCheckpointProperties2NV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyCheckpointProperties2NV, pNext));
#endif
#ifdef VK_KHR_synchronization2
    exports["VkQueueFamilyCheckpointProperties2NV_checkpointExecutionStageMask_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyCheckpointProperties2NV, checkpointExecutionStageMask));
#endif
#ifdef VK_KHR_synchronization2
    exports["VkQueueFamilyCheckpointProperties2NV_sizeof"] = Napi::Number::New(env, sizeof(VkQueueFamilyCheckpointProperties2NV));
#endif
#ifdef VK_KHR_synchronization2
    exports["VkCheckpointData2NV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCheckpointData2NV, sType));
#endif
#ifdef VK_KHR_synchronization2
    exports["VkCheckpointData2NV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCheckpointData2NV, pNext));
#endif
#ifdef VK_KHR_synchronization2
    exports["VkCheckpointData2NV_stage_offsetof"] = Napi::Number::New(env, offsetof(VkCheckpointData2NV, stage));
#endif
#ifdef VK_KHR_synchronization2
    exports["VkCheckpointData2NV_pCheckpointMarker_offsetof"] = Napi::Number::New(env, offsetof(VkCheckpointData2NV, pCheckpointMarker));
#endif
#ifdef VK_KHR_synchronization2
    exports["VkCheckpointData2NV_sizeof"] = Napi::Number::New(env, sizeof(VkCheckpointData2NV));
#endif
    exports["VkPhysicalDeviceSynchronization2Features_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSynchronization2Features, sType));
    exports["VkPhysicalDeviceSynchronization2Features_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSynchronization2Features, pNext));
    exports["VkPhysicalDeviceSynchronization2Features_synchronization2_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSynchronization2Features, synchronization2));
    exports["VkPhysicalDeviceSynchronization2Features_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSynchronization2Features));
#ifdef VK_KHR_synchronization2
    exports["VkPhysicalDeviceSynchronization2FeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSynchronization2FeaturesKHR));
#endif
#ifdef VK_EXT_primitives_generated_query
    exports["VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, sType));
#endif
#ifdef VK_EXT_primitives_generated_query
    exports["VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_primitives_generated_query
    exports["VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT_primitivesGeneratedQuery_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, primitivesGeneratedQuery));
#endif
#ifdef VK_EXT_primitives_generated_query
    exports["VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT_primitivesGeneratedQueryWithRasterizerDiscard_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, primitivesGeneratedQueryWithRasterizerDiscard));
#endif
#ifdef VK_EXT_primitives_generated_query
    exports["VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT_primitivesGeneratedQueryWithNonZeroStreams_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, primitivesGeneratedQueryWithNonZeroStreams));
#endif
#ifdef VK_EXT_primitives_generated_query
    exports["VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT));
#endif
#ifdef VK_EXT_legacy_dithering
    exports["VkPhysicalDeviceLegacyDitheringFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLegacyDitheringFeaturesEXT, sType));
#endif
#ifdef VK_EXT_legacy_dithering
    exports["VkPhysicalDeviceLegacyDitheringFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLegacyDitheringFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_legacy_dithering
    exports["VkPhysicalDeviceLegacyDitheringFeaturesEXT_legacyDithering_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLegacyDitheringFeaturesEXT, legacyDithering));
#endif
#ifdef VK_EXT_legacy_dithering
    exports["VkPhysicalDeviceLegacyDitheringFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceLegacyDitheringFeaturesEXT));
#endif
#ifdef VK_EXT_multisampled_render_to_single_sampled
    exports["VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT, sType));
#endif
#ifdef VK_EXT_multisampled_render_to_single_sampled
    exports["VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_multisampled_render_to_single_sampled
    exports["VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT_multisampledRenderToSingleSampled_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT, multisampledRenderToSingleSampled));
#endif
#ifdef VK_EXT_multisampled_render_to_single_sampled
    exports["VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT));
#endif
#ifdef VK_EXT_multisampled_render_to_single_sampled
    exports["VkSubpassResolvePerformanceQueryEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassResolvePerformanceQueryEXT, sType));
#endif
#ifdef VK_EXT_multisampled_render_to_single_sampled
    exports["VkSubpassResolvePerformanceQueryEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassResolvePerformanceQueryEXT, pNext));
#endif
#ifdef VK_EXT_multisampled_render_to_single_sampled
    exports["VkSubpassResolvePerformanceQueryEXT_optimal_offsetof"] = Napi::Number::New(env, offsetof(VkSubpassResolvePerformanceQueryEXT, optimal));
#endif
#ifdef VK_EXT_multisampled_render_to_single_sampled
    exports["VkSubpassResolvePerformanceQueryEXT_sizeof"] = Napi::Number::New(env, sizeof(VkSubpassResolvePerformanceQueryEXT));
#endif
#ifdef VK_EXT_multisampled_render_to_single_sampled
    exports["VkMultisampledRenderToSingleSampledInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMultisampledRenderToSingleSampledInfoEXT, sType));
#endif
#ifdef VK_EXT_multisampled_render_to_single_sampled
    exports["VkMultisampledRenderToSingleSampledInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMultisampledRenderToSingleSampledInfoEXT, pNext));
#endif
#ifdef VK_EXT_multisampled_render_to_single_sampled
    exports["VkMultisampledRenderToSingleSampledInfoEXT_multisampledRenderToSingleSampledEnable_offsetof"] = Napi::Number::New(env, offsetof(VkMultisampledRenderToSingleSampledInfoEXT, multisampledRenderToSingleSampledEnable));
#endif
#ifdef VK_EXT_multisampled_render_to_single_sampled
    exports["VkMultisampledRenderToSingleSampledInfoEXT_rasterizationSamples_offsetof"] = Napi::Number::New(env, offsetof(VkMultisampledRenderToSingleSampledInfoEXT, rasterizationSamples));
#endif
#ifdef VK_EXT_multisampled_render_to_single_sampled
    exports["VkMultisampledRenderToSingleSampledInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkMultisampledRenderToSingleSampledInfoEXT));
#endif
#ifdef VK_EXT_pipeline_protected_access
    exports["VkPhysicalDevicePipelineProtectedAccessFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineProtectedAccessFeaturesEXT, sType));
#endif
#ifdef VK_EXT_pipeline_protected_access
    exports["VkPhysicalDevicePipelineProtectedAccessFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineProtectedAccessFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_pipeline_protected_access
    exports["VkPhysicalDevicePipelineProtectedAccessFeaturesEXT_pipelineProtectedAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineProtectedAccessFeaturesEXT, pipelineProtectedAccess));
#endif
#ifdef VK_EXT_pipeline_protected_access
    exports["VkPhysicalDevicePipelineProtectedAccessFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePipelineProtectedAccessFeaturesEXT));
#endif
#ifdef VK_KHR_video_queue
    exports["VkQueueFamilyVideoPropertiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyVideoPropertiesKHR, sType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkQueueFamilyVideoPropertiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyVideoPropertiesKHR, pNext));
#endif
#ifdef VK_KHR_video_queue
    exports["VkQueueFamilyVideoPropertiesKHR_videoCodecOperations_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyVideoPropertiesKHR, videoCodecOperations));
#endif
#ifdef VK_KHR_video_queue
    exports["VkQueueFamilyVideoPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkQueueFamilyVideoPropertiesKHR));
#endif
#ifdef VK_KHR_video_queue
    exports["VkQueueFamilyQueryResultStatusPropertiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyQueryResultStatusPropertiesKHR, sType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkQueueFamilyQueryResultStatusPropertiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyQueryResultStatusPropertiesKHR, pNext));
#endif
#ifdef VK_KHR_video_queue
    exports["VkQueueFamilyQueryResultStatusPropertiesKHR_queryResultStatusSupport_offsetof"] = Napi::Number::New(env, offsetof(VkQueueFamilyQueryResultStatusPropertiesKHR, queryResultStatusSupport));
#endif
#ifdef VK_KHR_video_queue
    exports["VkQueueFamilyQueryResultStatusPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkQueueFamilyQueryResultStatusPropertiesKHR));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoProfileListInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoProfileListInfoKHR, sType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoProfileListInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoProfileListInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoProfileListInfoKHR_profileCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoProfileListInfoKHR, profileCount));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoProfileListInfoKHR_pProfiles_offsetof"] = Napi::Number::New(env, offsetof(VkVideoProfileListInfoKHR, pProfiles));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoProfileListInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoProfileListInfoKHR));
#endif
#ifdef VK_KHR_video_queue
    exports["VkPhysicalDeviceVideoFormatInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVideoFormatInfoKHR, sType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkPhysicalDeviceVideoFormatInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVideoFormatInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_queue
    exports["VkPhysicalDeviceVideoFormatInfoKHR_imageUsage_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceVideoFormatInfoKHR, imageUsage));
#endif
#ifdef VK_KHR_video_queue
    exports["VkPhysicalDeviceVideoFormatInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceVideoFormatInfoKHR));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoFormatPropertiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoFormatPropertiesKHR, sType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoFormatPropertiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoFormatPropertiesKHR, pNext));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoFormatPropertiesKHR_format_offsetof"] = Napi::Number::New(env, offsetof(VkVideoFormatPropertiesKHR, format));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoFormatPropertiesKHR_componentMapping_offsetof"] = Napi::Number::New(env, offsetof(VkVideoFormatPropertiesKHR, componentMapping));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoFormatPropertiesKHR_imageCreateFlags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoFormatPropertiesKHR, imageCreateFlags));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoFormatPropertiesKHR_imageType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoFormatPropertiesKHR, imageType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoFormatPropertiesKHR_imageTiling_offsetof"] = Napi::Number::New(env, offsetof(VkVideoFormatPropertiesKHR, imageTiling));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoFormatPropertiesKHR_imageUsageFlags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoFormatPropertiesKHR, imageUsageFlags));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoFormatPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoFormatPropertiesKHR));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoProfileInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoProfileInfoKHR, sType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoProfileInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoProfileInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoProfileInfoKHR_videoCodecOperation_offsetof"] = Napi::Number::New(env, offsetof(VkVideoProfileInfoKHR, videoCodecOperation));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoProfileInfoKHR_chromaSubsampling_offsetof"] = Napi::Number::New(env, offsetof(VkVideoProfileInfoKHR, chromaSubsampling));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoProfileInfoKHR_lumaBitDepth_offsetof"] = Napi::Number::New(env, offsetof(VkVideoProfileInfoKHR, lumaBitDepth));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoProfileInfoKHR_chromaBitDepth_offsetof"] = Napi::Number::New(env, offsetof(VkVideoProfileInfoKHR, chromaBitDepth));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoProfileInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoProfileInfoKHR));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoCapabilitiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoCapabilitiesKHR, sType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoCapabilitiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoCapabilitiesKHR, pNext));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoCapabilitiesKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoCapabilitiesKHR, flags));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoCapabilitiesKHR_minBitstreamBufferOffsetAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkVideoCapabilitiesKHR, minBitstreamBufferOffsetAlignment));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoCapabilitiesKHR_minBitstreamBufferSizeAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkVideoCapabilitiesKHR, minBitstreamBufferSizeAlignment));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoCapabilitiesKHR_pictureAccessGranularity_offsetof"] = Napi::Number::New(env, offsetof(VkVideoCapabilitiesKHR, pictureAccessGranularity));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoCapabilitiesKHR_minCodedExtent_offsetof"] = Napi::Number::New(env, offsetof(VkVideoCapabilitiesKHR, minCodedExtent));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoCapabilitiesKHR_maxCodedExtent_offsetof"] = Napi::Number::New(env, offsetof(VkVideoCapabilitiesKHR, maxCodedExtent));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoCapabilitiesKHR_maxDpbSlots_offsetof"] = Napi::Number::New(env, offsetof(VkVideoCapabilitiesKHR, maxDpbSlots));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoCapabilitiesKHR_maxActiveReferencePictures_offsetof"] = Napi::Number::New(env, offsetof(VkVideoCapabilitiesKHR, maxActiveReferencePictures));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoCapabilitiesKHR_stdHeaderVersion_offsetof"] = Napi::Number::New(env, offsetof(VkVideoCapabilitiesKHR, stdHeaderVersion));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoCapabilitiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoCapabilitiesKHR));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionMemoryRequirementsKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionMemoryRequirementsKHR, sType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionMemoryRequirementsKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionMemoryRequirementsKHR, pNext));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionMemoryRequirementsKHR_memoryBindIndex_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionMemoryRequirementsKHR, memoryBindIndex));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionMemoryRequirementsKHR_memoryRequirements_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionMemoryRequirementsKHR, memoryRequirements));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionMemoryRequirementsKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoSessionMemoryRequirementsKHR));
#endif
#ifdef VK_KHR_video_queue
    exports["VkBindVideoSessionMemoryInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBindVideoSessionMemoryInfoKHR, sType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkBindVideoSessionMemoryInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBindVideoSessionMemoryInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_queue
    exports["VkBindVideoSessionMemoryInfoKHR_memoryBindIndex_offsetof"] = Napi::Number::New(env, offsetof(VkBindVideoSessionMemoryInfoKHR, memoryBindIndex));
#endif
#ifdef VK_KHR_video_queue
    exports["VkBindVideoSessionMemoryInfoKHR_memory_offsetof"] = Napi::Number::New(env, offsetof(VkBindVideoSessionMemoryInfoKHR, memory));
#endif
#ifdef VK_KHR_video_queue
    exports["VkBindVideoSessionMemoryInfoKHR_memoryOffset_offsetof"] = Napi::Number::New(env, offsetof(VkBindVideoSessionMemoryInfoKHR, memoryOffset));
#endif
#ifdef VK_KHR_video_queue
    exports["VkBindVideoSessionMemoryInfoKHR_memorySize_offsetof"] = Napi::Number::New(env, offsetof(VkBindVideoSessionMemoryInfoKHR, memorySize));
#endif
#ifdef VK_KHR_video_queue
    exports["VkBindVideoSessionMemoryInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkBindVideoSessionMemoryInfoKHR));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoPictureResourceInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoPictureResourceInfoKHR, sType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoPictureResourceInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoPictureResourceInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoPictureResourceInfoKHR_codedOffset_offsetof"] = Napi::Number::New(env, offsetof(VkVideoPictureResourceInfoKHR, codedOffset));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoPictureResourceInfoKHR_codedExtent_offsetof"] = Napi::Number::New(env, offsetof(VkVideoPictureResourceInfoKHR, codedExtent));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoPictureResourceInfoKHR_baseArrayLayer_offsetof"] = Napi::Number::New(env, offsetof(VkVideoPictureResourceInfoKHR, baseArrayLayer));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoPictureResourceInfoKHR_imageViewBinding_offsetof"] = Napi::Number::New(env, offsetof(VkVideoPictureResourceInfoKHR, imageViewBinding));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoPictureResourceInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoPictureResourceInfoKHR));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoReferenceSlotInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoReferenceSlotInfoKHR, sType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoReferenceSlotInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoReferenceSlotInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoReferenceSlotInfoKHR_slotIndex_offsetof"] = Napi::Number::New(env, offsetof(VkVideoReferenceSlotInfoKHR, slotIndex));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoReferenceSlotInfoKHR_pPictureResource_offsetof"] = Napi::Number::New(env, offsetof(VkVideoReferenceSlotInfoKHR, pPictureResource));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoReferenceSlotInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoReferenceSlotInfoKHR));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeCapabilitiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeCapabilitiesKHR, sType));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeCapabilitiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeCapabilitiesKHR, pNext));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeCapabilitiesKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeCapabilitiesKHR, flags));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeCapabilitiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoDecodeCapabilitiesKHR));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeUsageInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeUsageInfoKHR, sType));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeUsageInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeUsageInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeUsageInfoKHR_videoUsageHints_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeUsageInfoKHR, videoUsageHints));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeUsageInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoDecodeUsageInfoKHR));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeInfoKHR, sType));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeInfoKHR, flags));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeInfoKHR_srcBuffer_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeInfoKHR, srcBuffer));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeInfoKHR_srcBufferOffset_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeInfoKHR, srcBufferOffset));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeInfoKHR_srcBufferRange_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeInfoKHR, srcBufferRange));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeInfoKHR_dstPictureResource_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeInfoKHR, dstPictureResource));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeInfoKHR_pSetupReferenceSlot_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeInfoKHR, pSetupReferenceSlot));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeInfoKHR_referenceSlotCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeInfoKHR, referenceSlotCount));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeInfoKHR_pReferenceSlots_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeInfoKHR, pReferenceSlots));
#endif
#ifdef VK_KHR_video_decode_queue
    exports["VkVideoDecodeInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoDecodeInfoKHR));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264ProfileInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264ProfileInfoEXT, sType));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264ProfileInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264ProfileInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264ProfileInfoEXT_stdProfileIdc_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264ProfileInfoEXT, stdProfileIdc));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264ProfileInfoEXT_pictureLayout_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264ProfileInfoEXT, pictureLayout));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264ProfileInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoDecodeH264ProfileInfoEXT));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264CapabilitiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264CapabilitiesEXT, sType));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264CapabilitiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264CapabilitiesEXT, pNext));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264CapabilitiesEXT_maxLevelIdc_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264CapabilitiesEXT, maxLevelIdc));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264CapabilitiesEXT_fieldOffsetGranularity_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264CapabilitiesEXT, fieldOffsetGranularity));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264CapabilitiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoDecodeH264CapabilitiesEXT));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264SessionParametersAddInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264SessionParametersAddInfoEXT, sType));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264SessionParametersAddInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264SessionParametersAddInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264SessionParametersAddInfoEXT_stdSPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264SessionParametersAddInfoEXT, stdSPSCount));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264SessionParametersAddInfoEXT_pStdSPSs_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264SessionParametersAddInfoEXT, pStdSPSs));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264SessionParametersAddInfoEXT_stdPPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264SessionParametersAddInfoEXT, stdPPSCount));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264SessionParametersAddInfoEXT_pStdPPSs_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264SessionParametersAddInfoEXT, pStdPPSs));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264SessionParametersAddInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoDecodeH264SessionParametersAddInfoEXT));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264SessionParametersCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264SessionParametersCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264SessionParametersCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264SessionParametersCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264SessionParametersCreateInfoEXT_maxStdSPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264SessionParametersCreateInfoEXT, maxStdSPSCount));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264SessionParametersCreateInfoEXT_maxStdPPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264SessionParametersCreateInfoEXT, maxStdPPSCount));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264SessionParametersCreateInfoEXT_pParametersAddInfo_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264SessionParametersCreateInfoEXT, pParametersAddInfo));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264SessionParametersCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoDecodeH264SessionParametersCreateInfoEXT));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264PictureInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264PictureInfoEXT, sType));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264PictureInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264PictureInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264PictureInfoEXT_pStdPictureInfo_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264PictureInfoEXT, pStdPictureInfo));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264PictureInfoEXT_sliceCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264PictureInfoEXT, sliceCount));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264PictureInfoEXT_pSliceOffsets_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264PictureInfoEXT, pSliceOffsets));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264PictureInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoDecodeH264PictureInfoEXT));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264DpbSlotInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264DpbSlotInfoEXT, sType));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264DpbSlotInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264DpbSlotInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264DpbSlotInfoEXT_pStdReferenceInfo_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH264DpbSlotInfoEXT, pStdReferenceInfo));
#endif
#ifdef VK_EXT_video_decode_h264
    exports["VkVideoDecodeH264DpbSlotInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoDecodeH264DpbSlotInfoEXT));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265ProfileInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265ProfileInfoEXT, sType));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265ProfileInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265ProfileInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265ProfileInfoEXT_stdProfileIdc_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265ProfileInfoEXT, stdProfileIdc));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265ProfileInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoDecodeH265ProfileInfoEXT));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265CapabilitiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265CapabilitiesEXT, sType));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265CapabilitiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265CapabilitiesEXT, pNext));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265CapabilitiesEXT_maxLevelIdc_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265CapabilitiesEXT, maxLevelIdc));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265CapabilitiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoDecodeH265CapabilitiesEXT));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265SessionParametersAddInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265SessionParametersAddInfoEXT, sType));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265SessionParametersAddInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265SessionParametersAddInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265SessionParametersAddInfoEXT_stdVPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265SessionParametersAddInfoEXT, stdVPSCount));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265SessionParametersAddInfoEXT_pStdVPSs_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265SessionParametersAddInfoEXT, pStdVPSs));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265SessionParametersAddInfoEXT_stdSPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265SessionParametersAddInfoEXT, stdSPSCount));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265SessionParametersAddInfoEXT_pStdSPSs_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265SessionParametersAddInfoEXT, pStdSPSs));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265SessionParametersAddInfoEXT_stdPPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265SessionParametersAddInfoEXT, stdPPSCount));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265SessionParametersAddInfoEXT_pStdPPSs_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265SessionParametersAddInfoEXT, pStdPPSs));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265SessionParametersAddInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoDecodeH265SessionParametersAddInfoEXT));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265SessionParametersCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265SessionParametersCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265SessionParametersCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265SessionParametersCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265SessionParametersCreateInfoEXT_maxStdVPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265SessionParametersCreateInfoEXT, maxStdVPSCount));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265SessionParametersCreateInfoEXT_maxStdSPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265SessionParametersCreateInfoEXT, maxStdSPSCount));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265SessionParametersCreateInfoEXT_maxStdPPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265SessionParametersCreateInfoEXT, maxStdPPSCount));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265SessionParametersCreateInfoEXT_pParametersAddInfo_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265SessionParametersCreateInfoEXT, pParametersAddInfo));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265SessionParametersCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoDecodeH265SessionParametersCreateInfoEXT));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265PictureInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265PictureInfoEXT, sType));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265PictureInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265PictureInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265PictureInfoEXT_pStdPictureInfo_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265PictureInfoEXT, pStdPictureInfo));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265PictureInfoEXT_sliceCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265PictureInfoEXT, sliceCount));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265PictureInfoEXT_pSliceOffsets_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265PictureInfoEXT, pSliceOffsets));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265PictureInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoDecodeH265PictureInfoEXT));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265DpbSlotInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265DpbSlotInfoEXT, sType));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265DpbSlotInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265DpbSlotInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265DpbSlotInfoEXT_pStdReferenceInfo_offsetof"] = Napi::Number::New(env, offsetof(VkVideoDecodeH265DpbSlotInfoEXT, pStdReferenceInfo));
#endif
#ifdef VK_EXT_video_decode_h265
    exports["VkVideoDecodeH265DpbSlotInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoDecodeH265DpbSlotInfoEXT));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionCreateInfoKHR_queueFamilyIndex_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionCreateInfoKHR, queueFamilyIndex));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionCreateInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionCreateInfoKHR, flags));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionCreateInfoKHR_pVideoProfile_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionCreateInfoKHR, pVideoProfile));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionCreateInfoKHR_pictureFormat_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionCreateInfoKHR, pictureFormat));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionCreateInfoKHR_maxCodedExtent_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionCreateInfoKHR, maxCodedExtent));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionCreateInfoKHR_referencePictureFormat_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionCreateInfoKHR, referencePictureFormat));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionCreateInfoKHR_maxDpbSlots_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionCreateInfoKHR, maxDpbSlots));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionCreateInfoKHR_maxActiveReferencePictures_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionCreateInfoKHR, maxActiveReferencePictures));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionCreateInfoKHR_pStdHeaderVersion_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionCreateInfoKHR, pStdHeaderVersion));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoSessionCreateInfoKHR));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionParametersCreateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionParametersCreateInfoKHR, sType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionParametersCreateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionParametersCreateInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionParametersCreateInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionParametersCreateInfoKHR, flags));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionParametersCreateInfoKHR_videoSessionParametersTemplate_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionParametersCreateInfoKHR, videoSessionParametersTemplate));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionParametersCreateInfoKHR_videoSession_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionParametersCreateInfoKHR, videoSession));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionParametersCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoSessionParametersCreateInfoKHR));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionParametersUpdateInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionParametersUpdateInfoKHR, sType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionParametersUpdateInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionParametersUpdateInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionParametersUpdateInfoKHR_updateSequenceCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoSessionParametersUpdateInfoKHR, updateSequenceCount));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoSessionParametersUpdateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoSessionParametersUpdateInfoKHR));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoBeginCodingInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoBeginCodingInfoKHR, sType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoBeginCodingInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoBeginCodingInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoBeginCodingInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoBeginCodingInfoKHR, flags));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoBeginCodingInfoKHR_videoSession_offsetof"] = Napi::Number::New(env, offsetof(VkVideoBeginCodingInfoKHR, videoSession));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoBeginCodingInfoKHR_videoSessionParameters_offsetof"] = Napi::Number::New(env, offsetof(VkVideoBeginCodingInfoKHR, videoSessionParameters));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoBeginCodingInfoKHR_referenceSlotCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoBeginCodingInfoKHR, referenceSlotCount));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoBeginCodingInfoKHR_pReferenceSlots_offsetof"] = Napi::Number::New(env, offsetof(VkVideoBeginCodingInfoKHR, pReferenceSlots));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoBeginCodingInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoBeginCodingInfoKHR));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoEndCodingInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEndCodingInfoKHR, sType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoEndCodingInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEndCodingInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoEndCodingInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEndCodingInfoKHR, flags));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoEndCodingInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEndCodingInfoKHR));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoCodingControlInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoCodingControlInfoKHR, sType));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoCodingControlInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoCodingControlInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoCodingControlInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoCodingControlInfoKHR, flags));
#endif
#ifdef VK_KHR_video_queue
    exports["VkVideoCodingControlInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoCodingControlInfoKHR));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeUsageInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeUsageInfoKHR, sType));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeUsageInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeUsageInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeUsageInfoKHR_videoUsageHints_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeUsageInfoKHR, videoUsageHints));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeUsageInfoKHR_videoContentHints_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeUsageInfoKHR, videoContentHints));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeUsageInfoKHR_tuningMode_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeUsageInfoKHR, tuningMode));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeUsageInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeUsageInfoKHR));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeInfoKHR, sType));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeInfoKHR, flags));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeInfoKHR_qualityLevel_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeInfoKHR, qualityLevel));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeInfoKHR_dstBitstreamBuffer_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeInfoKHR, dstBitstreamBuffer));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeInfoKHR_dstBitstreamBufferOffset_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeInfoKHR, dstBitstreamBufferOffset));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeInfoKHR_dstBitstreamBufferMaxRange_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeInfoKHR, dstBitstreamBufferMaxRange));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeInfoKHR_srcPictureResource_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeInfoKHR, srcPictureResource));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeInfoKHR_pSetupReferenceSlot_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeInfoKHR, pSetupReferenceSlot));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeInfoKHR_referenceSlotCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeInfoKHR, referenceSlotCount));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeInfoKHR_pReferenceSlots_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeInfoKHR, pReferenceSlots));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeInfoKHR_precedingExternallyEncodedBytes_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeInfoKHR, precedingExternallyEncodedBytes));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeInfoKHR));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeRateControlInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeRateControlInfoKHR, sType));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeRateControlInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeRateControlInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeRateControlInfoKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeRateControlInfoKHR, flags));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeRateControlInfoKHR_rateControlMode_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeRateControlInfoKHR, rateControlMode));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeRateControlInfoKHR_layerCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeRateControlInfoKHR, layerCount));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeRateControlInfoKHR_pLayerConfigs_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeRateControlInfoKHR, pLayerConfigs));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeRateControlInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeRateControlInfoKHR));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeRateControlLayerInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeRateControlLayerInfoKHR, sType));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeRateControlLayerInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeRateControlLayerInfoKHR, pNext));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeRateControlLayerInfoKHR_averageBitrate_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeRateControlLayerInfoKHR, averageBitrate));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeRateControlLayerInfoKHR_maxBitrate_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeRateControlLayerInfoKHR, maxBitrate));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeRateControlLayerInfoKHR_frameRateNumerator_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeRateControlLayerInfoKHR, frameRateNumerator));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeRateControlLayerInfoKHR_frameRateDenominator_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeRateControlLayerInfoKHR, frameRateDenominator));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeRateControlLayerInfoKHR_virtualBufferSizeInMs_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeRateControlLayerInfoKHR, virtualBufferSizeInMs));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeRateControlLayerInfoKHR_initialVirtualBufferSizeInMs_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeRateControlLayerInfoKHR, initialVirtualBufferSizeInMs));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeRateControlLayerInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeRateControlLayerInfoKHR));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeCapabilitiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeCapabilitiesKHR, sType));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeCapabilitiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeCapabilitiesKHR, pNext));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeCapabilitiesKHR_flags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeCapabilitiesKHR, flags));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeCapabilitiesKHR_rateControlModes_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeCapabilitiesKHR, rateControlModes));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeCapabilitiesKHR_rateControlLayerCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeCapabilitiesKHR, rateControlLayerCount));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeCapabilitiesKHR_qualityLevelCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeCapabilitiesKHR, qualityLevelCount));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeCapabilitiesKHR_inputImageDataFillAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeCapabilitiesKHR, inputImageDataFillAlignment));
#endif
#ifdef VK_KHR_video_encode_queue
    exports["VkVideoEncodeCapabilitiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeCapabilitiesKHR));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264CapabilitiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264CapabilitiesEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264CapabilitiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264CapabilitiesEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264CapabilitiesEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264CapabilitiesEXT, flags));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264CapabilitiesEXT_inputModeFlags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264CapabilitiesEXT, inputModeFlags));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264CapabilitiesEXT_outputModeFlags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264CapabilitiesEXT, outputModeFlags));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264CapabilitiesEXT_maxPPictureL0ReferenceCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264CapabilitiesEXT, maxPPictureL0ReferenceCount));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264CapabilitiesEXT_maxBPictureL0ReferenceCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264CapabilitiesEXT, maxBPictureL0ReferenceCount));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264CapabilitiesEXT_maxL1ReferenceCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264CapabilitiesEXT, maxL1ReferenceCount));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264CapabilitiesEXT_motionVectorsOverPicBoundariesFlag_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264CapabilitiesEXT, motionVectorsOverPicBoundariesFlag));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264CapabilitiesEXT_maxBytesPerPicDenom_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264CapabilitiesEXT, maxBytesPerPicDenom));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264CapabilitiesEXT_maxBitsPerMbDenom_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264CapabilitiesEXT, maxBitsPerMbDenom));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264CapabilitiesEXT_log2MaxMvLengthHorizontal_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264CapabilitiesEXT, log2MaxMvLengthHorizontal));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264CapabilitiesEXT_log2MaxMvLengthVertical_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264CapabilitiesEXT, log2MaxMvLengthVertical));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264CapabilitiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH264CapabilitiesEXT));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264SessionParametersAddInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264SessionParametersAddInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264SessionParametersAddInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264SessionParametersAddInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264SessionParametersAddInfoEXT_stdSPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264SessionParametersAddInfoEXT, stdSPSCount));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264SessionParametersAddInfoEXT_pStdSPSs_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264SessionParametersAddInfoEXT, pStdSPSs));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264SessionParametersAddInfoEXT_stdPPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264SessionParametersAddInfoEXT, stdPPSCount));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264SessionParametersAddInfoEXT_pStdPPSs_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264SessionParametersAddInfoEXT, pStdPPSs));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264SessionParametersAddInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH264SessionParametersAddInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264SessionParametersCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264SessionParametersCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264SessionParametersCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264SessionParametersCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264SessionParametersCreateInfoEXT_maxStdSPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264SessionParametersCreateInfoEXT, maxStdSPSCount));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264SessionParametersCreateInfoEXT_maxStdPPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264SessionParametersCreateInfoEXT, maxStdPPSCount));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264SessionParametersCreateInfoEXT_pParametersAddInfo_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264SessionParametersCreateInfoEXT, pParametersAddInfo));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264SessionParametersCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH264SessionParametersCreateInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264DpbSlotInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264DpbSlotInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264DpbSlotInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264DpbSlotInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264DpbSlotInfoEXT_slotIndex_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264DpbSlotInfoEXT, slotIndex));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264DpbSlotInfoEXT_pStdReferenceInfo_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264DpbSlotInfoEXT, pStdReferenceInfo));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264DpbSlotInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH264DpbSlotInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264VclFrameInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264VclFrameInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264VclFrameInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264VclFrameInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264VclFrameInfoEXT_pReferenceFinalLists_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264VclFrameInfoEXT, pReferenceFinalLists));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264VclFrameInfoEXT_naluSliceEntryCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264VclFrameInfoEXT, naluSliceEntryCount));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264VclFrameInfoEXT_pNaluSliceEntries_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264VclFrameInfoEXT, pNaluSliceEntries));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264VclFrameInfoEXT_pCurrentPictureInfo_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264VclFrameInfoEXT, pCurrentPictureInfo));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264VclFrameInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH264VclFrameInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264ReferenceListsInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264ReferenceListsInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264ReferenceListsInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264ReferenceListsInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264ReferenceListsInfoEXT_referenceList0EntryCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264ReferenceListsInfoEXT, referenceList0EntryCount));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264ReferenceListsInfoEXT_pReferenceList0Entries_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264ReferenceListsInfoEXT, pReferenceList0Entries));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264ReferenceListsInfoEXT_referenceList1EntryCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264ReferenceListsInfoEXT, referenceList1EntryCount));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264ReferenceListsInfoEXT_pReferenceList1Entries_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264ReferenceListsInfoEXT, pReferenceList1Entries));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264ReferenceListsInfoEXT_pMemMgmtCtrlOperations_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264ReferenceListsInfoEXT, pMemMgmtCtrlOperations));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264ReferenceListsInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH264ReferenceListsInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264EmitPictureParametersInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264EmitPictureParametersInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264EmitPictureParametersInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264EmitPictureParametersInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264EmitPictureParametersInfoEXT_spsId_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264EmitPictureParametersInfoEXT, spsId));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264EmitPictureParametersInfoEXT_emitSpsEnable_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264EmitPictureParametersInfoEXT, emitSpsEnable));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264EmitPictureParametersInfoEXT_ppsIdEntryCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264EmitPictureParametersInfoEXT, ppsIdEntryCount));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264EmitPictureParametersInfoEXT_ppsIdEntries_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264EmitPictureParametersInfoEXT, ppsIdEntries));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264EmitPictureParametersInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH264EmitPictureParametersInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264ProfileInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264ProfileInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264ProfileInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264ProfileInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264ProfileInfoEXT_stdProfileIdc_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264ProfileInfoEXT, stdProfileIdc));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264ProfileInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH264ProfileInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264NaluSliceInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264NaluSliceInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264NaluSliceInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264NaluSliceInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264NaluSliceInfoEXT_mbCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264NaluSliceInfoEXT, mbCount));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264NaluSliceInfoEXT_pReferenceFinalLists_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264NaluSliceInfoEXT, pReferenceFinalLists));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264NaluSliceInfoEXT_pSliceHeaderStd_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264NaluSliceInfoEXT, pSliceHeaderStd));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264NaluSliceInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH264NaluSliceInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlInfoEXT_gopFrameCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlInfoEXT, gopFrameCount));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlInfoEXT_idrPeriod_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlInfoEXT, idrPeriod));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlInfoEXT_consecutiveBFrameCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlInfoEXT, consecutiveBFrameCount));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlInfoEXT_rateControlStructure_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlInfoEXT, rateControlStructure));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlInfoEXT_temporalLayerCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlInfoEXT, temporalLayerCount));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH264RateControlInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264QpEXT_qpI_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264QpEXT, qpI));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264QpEXT_qpP_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264QpEXT, qpP));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264QpEXT_qpB_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264QpEXT, qpB));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264QpEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH264QpEXT));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264FrameSizeEXT_frameISize_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264FrameSizeEXT, frameISize));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264FrameSizeEXT_framePSize_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264FrameSizeEXT, framePSize));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264FrameSizeEXT_frameBSize_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264FrameSizeEXT, frameBSize));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264FrameSizeEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH264FrameSizeEXT));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlLayerInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlLayerInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlLayerInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlLayerInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlLayerInfoEXT_temporalLayerId_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlLayerInfoEXT, temporalLayerId));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlLayerInfoEXT_useInitialRcQp_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlLayerInfoEXT, useInitialRcQp));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlLayerInfoEXT_initialRcQp_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlLayerInfoEXT, initialRcQp));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlLayerInfoEXT_useMinQp_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlLayerInfoEXT, useMinQp));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlLayerInfoEXT_minQp_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlLayerInfoEXT, minQp));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlLayerInfoEXT_useMaxQp_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlLayerInfoEXT, useMaxQp));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlLayerInfoEXT_maxQp_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlLayerInfoEXT, maxQp));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlLayerInfoEXT_useMaxFrameSize_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlLayerInfoEXT, useMaxFrameSize));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlLayerInfoEXT_maxFrameSize_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH264RateControlLayerInfoEXT, maxFrameSize));
#endif
#ifdef VK_EXT_video_encode_h264
    exports["VkVideoEncodeH264RateControlLayerInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH264RateControlLayerInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, flags));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_inputModeFlags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, inputModeFlags));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_outputModeFlags_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, outputModeFlags));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_ctbSizes_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, ctbSizes));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_transformBlockSizes_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, transformBlockSizes));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_maxPPictureL0ReferenceCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, maxPPictureL0ReferenceCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_maxBPictureL0ReferenceCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, maxBPictureL0ReferenceCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_maxL1ReferenceCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, maxL1ReferenceCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_maxSubLayersCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, maxSubLayersCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_minLog2MinLumaCodingBlockSizeMinus3_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, minLog2MinLumaCodingBlockSizeMinus3));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_maxLog2MinLumaCodingBlockSizeMinus3_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, maxLog2MinLumaCodingBlockSizeMinus3));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_minLog2MinLumaTransformBlockSizeMinus2_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, minLog2MinLumaTransformBlockSizeMinus2));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_maxLog2MinLumaTransformBlockSizeMinus2_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, maxLog2MinLumaTransformBlockSizeMinus2));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_minMaxTransformHierarchyDepthInter_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, minMaxTransformHierarchyDepthInter));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_maxMaxTransformHierarchyDepthInter_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, maxMaxTransformHierarchyDepthInter));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_minMaxTransformHierarchyDepthIntra_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, minMaxTransformHierarchyDepthIntra));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_maxMaxTransformHierarchyDepthIntra_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, maxMaxTransformHierarchyDepthIntra));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_maxDiffCuQpDeltaDepth_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, maxDiffCuQpDeltaDepth));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_minMaxNumMergeCand_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, minMaxNumMergeCand));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_maxMaxNumMergeCand_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265CapabilitiesEXT, maxMaxNumMergeCand));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265CapabilitiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH265CapabilitiesEXT));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265SessionParametersAddInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265SessionParametersAddInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265SessionParametersAddInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265SessionParametersAddInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265SessionParametersAddInfoEXT_stdVPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265SessionParametersAddInfoEXT, stdVPSCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265SessionParametersAddInfoEXT_pStdVPSs_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265SessionParametersAddInfoEXT, pStdVPSs));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265SessionParametersAddInfoEXT_stdSPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265SessionParametersAddInfoEXT, stdSPSCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265SessionParametersAddInfoEXT_pStdSPSs_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265SessionParametersAddInfoEXT, pStdSPSs));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265SessionParametersAddInfoEXT_stdPPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265SessionParametersAddInfoEXT, stdPPSCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265SessionParametersAddInfoEXT_pStdPPSs_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265SessionParametersAddInfoEXT, pStdPPSs));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265SessionParametersAddInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH265SessionParametersAddInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265SessionParametersCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265SessionParametersCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265SessionParametersCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265SessionParametersCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265SessionParametersCreateInfoEXT_maxStdVPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265SessionParametersCreateInfoEXT, maxStdVPSCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265SessionParametersCreateInfoEXT_maxStdSPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265SessionParametersCreateInfoEXT, maxStdSPSCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265SessionParametersCreateInfoEXT_maxStdPPSCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265SessionParametersCreateInfoEXT, maxStdPPSCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265SessionParametersCreateInfoEXT_pParametersAddInfo_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265SessionParametersCreateInfoEXT, pParametersAddInfo));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265SessionParametersCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH265SessionParametersCreateInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265VclFrameInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265VclFrameInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265VclFrameInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265VclFrameInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265VclFrameInfoEXT_pReferenceFinalLists_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265VclFrameInfoEXT, pReferenceFinalLists));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265VclFrameInfoEXT_naluSliceSegmentEntryCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265VclFrameInfoEXT, naluSliceSegmentEntryCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265VclFrameInfoEXT_pNaluSliceSegmentEntries_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265VclFrameInfoEXT, pNaluSliceSegmentEntries));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265VclFrameInfoEXT_pCurrentPictureInfo_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265VclFrameInfoEXT, pCurrentPictureInfo));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265VclFrameInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH265VclFrameInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265EmitPictureParametersInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265EmitPictureParametersInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265EmitPictureParametersInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265EmitPictureParametersInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265EmitPictureParametersInfoEXT_vpsId_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265EmitPictureParametersInfoEXT, vpsId));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265EmitPictureParametersInfoEXT_spsId_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265EmitPictureParametersInfoEXT, spsId));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265EmitPictureParametersInfoEXT_emitVpsEnable_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265EmitPictureParametersInfoEXT, emitVpsEnable));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265EmitPictureParametersInfoEXT_emitSpsEnable_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265EmitPictureParametersInfoEXT, emitSpsEnable));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265EmitPictureParametersInfoEXT_ppsIdEntryCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265EmitPictureParametersInfoEXT, ppsIdEntryCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265EmitPictureParametersInfoEXT_ppsIdEntries_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265EmitPictureParametersInfoEXT, ppsIdEntries));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265EmitPictureParametersInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH265EmitPictureParametersInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265NaluSliceSegmentInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265NaluSliceSegmentInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265NaluSliceSegmentInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265NaluSliceSegmentInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265NaluSliceSegmentInfoEXT_ctbCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265NaluSliceSegmentInfoEXT, ctbCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265NaluSliceSegmentInfoEXT_pReferenceFinalLists_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265NaluSliceSegmentInfoEXT, pReferenceFinalLists));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265NaluSliceSegmentInfoEXT_pSliceSegmentHeaderStd_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265NaluSliceSegmentInfoEXT, pSliceSegmentHeaderStd));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265NaluSliceSegmentInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH265NaluSliceSegmentInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlInfoEXT_gopFrameCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlInfoEXT, gopFrameCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlInfoEXT_idrPeriod_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlInfoEXT, idrPeriod));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlInfoEXT_consecutiveBFrameCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlInfoEXT, consecutiveBFrameCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlInfoEXT_rateControlStructure_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlInfoEXT, rateControlStructure));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlInfoEXT_subLayerCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlInfoEXT, subLayerCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH265RateControlInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265QpEXT_qpI_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265QpEXT, qpI));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265QpEXT_qpP_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265QpEXT, qpP));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265QpEXT_qpB_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265QpEXT, qpB));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265QpEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH265QpEXT));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265FrameSizeEXT_frameISize_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265FrameSizeEXT, frameISize));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265FrameSizeEXT_framePSize_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265FrameSizeEXT, framePSize));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265FrameSizeEXT_frameBSize_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265FrameSizeEXT, frameBSize));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265FrameSizeEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH265FrameSizeEXT));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlLayerInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlLayerInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlLayerInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlLayerInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlLayerInfoEXT_temporalId_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlLayerInfoEXT, temporalId));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlLayerInfoEXT_useInitialRcQp_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlLayerInfoEXT, useInitialRcQp));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlLayerInfoEXT_initialRcQp_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlLayerInfoEXT, initialRcQp));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlLayerInfoEXT_useMinQp_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlLayerInfoEXT, useMinQp));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlLayerInfoEXT_minQp_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlLayerInfoEXT, minQp));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlLayerInfoEXT_useMaxQp_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlLayerInfoEXT, useMaxQp));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlLayerInfoEXT_maxQp_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlLayerInfoEXT, maxQp));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlLayerInfoEXT_useMaxFrameSize_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlLayerInfoEXT, useMaxFrameSize));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlLayerInfoEXT_maxFrameSize_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265RateControlLayerInfoEXT, maxFrameSize));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265RateControlLayerInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH265RateControlLayerInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265ProfileInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265ProfileInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265ProfileInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265ProfileInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265ProfileInfoEXT_stdProfileIdc_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265ProfileInfoEXT, stdProfileIdc));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265ProfileInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH265ProfileInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265DpbSlotInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265DpbSlotInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265DpbSlotInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265DpbSlotInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265DpbSlotInfoEXT_slotIndex_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265DpbSlotInfoEXT, slotIndex));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265DpbSlotInfoEXT_pStdReferenceInfo_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265DpbSlotInfoEXT, pStdReferenceInfo));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265DpbSlotInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH265DpbSlotInfoEXT));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265ReferenceListsInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265ReferenceListsInfoEXT, sType));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265ReferenceListsInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265ReferenceListsInfoEXT, pNext));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265ReferenceListsInfoEXT_referenceList0EntryCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265ReferenceListsInfoEXT, referenceList0EntryCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265ReferenceListsInfoEXT_pReferenceList0Entries_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265ReferenceListsInfoEXT, pReferenceList0Entries));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265ReferenceListsInfoEXT_referenceList1EntryCount_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265ReferenceListsInfoEXT, referenceList1EntryCount));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265ReferenceListsInfoEXT_pReferenceList1Entries_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265ReferenceListsInfoEXT, pReferenceList1Entries));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265ReferenceListsInfoEXT_pReferenceModifications_offsetof"] = Napi::Number::New(env, offsetof(VkVideoEncodeH265ReferenceListsInfoEXT, pReferenceModifications));
#endif
#ifdef VK_EXT_video_encode_h265
    exports["VkVideoEncodeH265ReferenceListsInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkVideoEncodeH265ReferenceListsInfoEXT));
#endif
#ifdef VK_NV_inherited_viewport_scissor
    exports["VkPhysicalDeviceInheritedViewportScissorFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceInheritedViewportScissorFeaturesNV, sType));
#endif
#ifdef VK_NV_inherited_viewport_scissor
    exports["VkPhysicalDeviceInheritedViewportScissorFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceInheritedViewportScissorFeaturesNV, pNext));
#endif
#ifdef VK_NV_inherited_viewport_scissor
    exports["VkPhysicalDeviceInheritedViewportScissorFeaturesNV_inheritedViewportScissor2D_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceInheritedViewportScissorFeaturesNV, inheritedViewportScissor2D));
#endif
#ifdef VK_NV_inherited_viewport_scissor
    exports["VkPhysicalDeviceInheritedViewportScissorFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceInheritedViewportScissorFeaturesNV));
#endif
#ifdef VK_NV_inherited_viewport_scissor
    exports["VkCommandBufferInheritanceViewportScissorInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceViewportScissorInfoNV, sType));
#endif
#ifdef VK_NV_inherited_viewport_scissor
    exports["VkCommandBufferInheritanceViewportScissorInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceViewportScissorInfoNV, pNext));
#endif
#ifdef VK_NV_inherited_viewport_scissor
    exports["VkCommandBufferInheritanceViewportScissorInfoNV_viewportScissor2D_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceViewportScissorInfoNV, viewportScissor2D));
#endif
#ifdef VK_NV_inherited_viewport_scissor
    exports["VkCommandBufferInheritanceViewportScissorInfoNV_viewportDepthCount_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceViewportScissorInfoNV, viewportDepthCount));
#endif
#ifdef VK_NV_inherited_viewport_scissor
    exports["VkCommandBufferInheritanceViewportScissorInfoNV_pViewportDepths_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceViewportScissorInfoNV, pViewportDepths));
#endif
#ifdef VK_NV_inherited_viewport_scissor
    exports["VkCommandBufferInheritanceViewportScissorInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkCommandBufferInheritanceViewportScissorInfoNV));
#endif
#ifdef VK_EXT_ycbcr_2plane_444_formats
    exports["VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT, sType));
#endif
#ifdef VK_EXT_ycbcr_2plane_444_formats
    exports["VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_ycbcr_2plane_444_formats
    exports["VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT_ycbcr2plane444Formats_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT, ycbcr2plane444Formats));
#endif
#ifdef VK_EXT_ycbcr_2plane_444_formats
    exports["VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT));
#endif
#ifdef VK_EXT_provoking_vertex
    exports["VkPhysicalDeviceProvokingVertexFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProvokingVertexFeaturesEXT, sType));
#endif
#ifdef VK_EXT_provoking_vertex
    exports["VkPhysicalDeviceProvokingVertexFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProvokingVertexFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_provoking_vertex
    exports["VkPhysicalDeviceProvokingVertexFeaturesEXT_provokingVertexLast_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProvokingVertexFeaturesEXT, provokingVertexLast));
#endif
#ifdef VK_EXT_provoking_vertex
    exports["VkPhysicalDeviceProvokingVertexFeaturesEXT_transformFeedbackPreservesProvokingVertex_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProvokingVertexFeaturesEXT, transformFeedbackPreservesProvokingVertex));
#endif
#ifdef VK_EXT_provoking_vertex
    exports["VkPhysicalDeviceProvokingVertexFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceProvokingVertexFeaturesEXT));
#endif
#ifdef VK_EXT_provoking_vertex
    exports["VkPhysicalDeviceProvokingVertexPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProvokingVertexPropertiesEXT, sType));
#endif
#ifdef VK_EXT_provoking_vertex
    exports["VkPhysicalDeviceProvokingVertexPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProvokingVertexPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_provoking_vertex
    exports["VkPhysicalDeviceProvokingVertexPropertiesEXT_provokingVertexModePerPipeline_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProvokingVertexPropertiesEXT, provokingVertexModePerPipeline));
#endif
#ifdef VK_EXT_provoking_vertex
    exports["VkPhysicalDeviceProvokingVertexPropertiesEXT_transformFeedbackPreservesTriangleFanProvokingVertex_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceProvokingVertexPropertiesEXT, transformFeedbackPreservesTriangleFanProvokingVertex));
#endif
#ifdef VK_EXT_provoking_vertex
    exports["VkPhysicalDeviceProvokingVertexPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceProvokingVertexPropertiesEXT));
#endif
#ifdef VK_EXT_provoking_vertex
    exports["VkPipelineRasterizationProvokingVertexStateCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_provoking_vertex
    exports["VkPipelineRasterizationProvokingVertexStateCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_provoking_vertex
    exports["VkPipelineRasterizationProvokingVertexStateCreateInfoEXT_provokingVertexMode_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT, provokingVertexMode));
#endif
#ifdef VK_EXT_provoking_vertex
    exports["VkPipelineRasterizationProvokingVertexStateCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuModuleCreateInfoNVX_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCuModuleCreateInfoNVX, sType));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuModuleCreateInfoNVX_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCuModuleCreateInfoNVX, pNext));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuModuleCreateInfoNVX_dataSize_offsetof"] = Napi::Number::New(env, offsetof(VkCuModuleCreateInfoNVX, dataSize));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuModuleCreateInfoNVX_pData_offsetof"] = Napi::Number::New(env, offsetof(VkCuModuleCreateInfoNVX, pData));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuModuleCreateInfoNVX_sizeof"] = Napi::Number::New(env, sizeof(VkCuModuleCreateInfoNVX));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuFunctionCreateInfoNVX_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCuFunctionCreateInfoNVX, sType));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuFunctionCreateInfoNVX_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCuFunctionCreateInfoNVX, pNext));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuFunctionCreateInfoNVX_module_offsetof"] = Napi::Number::New(env, offsetof(VkCuFunctionCreateInfoNVX, module));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuFunctionCreateInfoNVX_pName_offsetof"] = Napi::Number::New(env, offsetof(VkCuFunctionCreateInfoNVX, pName));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuFunctionCreateInfoNVX_sizeof"] = Napi::Number::New(env, sizeof(VkCuFunctionCreateInfoNVX));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuLaunchInfoNVX_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCuLaunchInfoNVX, sType));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuLaunchInfoNVX_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCuLaunchInfoNVX, pNext));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuLaunchInfoNVX_function_offsetof"] = Napi::Number::New(env, offsetof(VkCuLaunchInfoNVX, function));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuLaunchInfoNVX_gridDimX_offsetof"] = Napi::Number::New(env, offsetof(VkCuLaunchInfoNVX, gridDimX));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuLaunchInfoNVX_gridDimY_offsetof"] = Napi::Number::New(env, offsetof(VkCuLaunchInfoNVX, gridDimY));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuLaunchInfoNVX_gridDimZ_offsetof"] = Napi::Number::New(env, offsetof(VkCuLaunchInfoNVX, gridDimZ));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuLaunchInfoNVX_blockDimX_offsetof"] = Napi::Number::New(env, offsetof(VkCuLaunchInfoNVX, blockDimX));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuLaunchInfoNVX_blockDimY_offsetof"] = Napi::Number::New(env, offsetof(VkCuLaunchInfoNVX, blockDimY));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuLaunchInfoNVX_blockDimZ_offsetof"] = Napi::Number::New(env, offsetof(VkCuLaunchInfoNVX, blockDimZ));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuLaunchInfoNVX_sharedMemBytes_offsetof"] = Napi::Number::New(env, offsetof(VkCuLaunchInfoNVX, sharedMemBytes));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuLaunchInfoNVX_paramCount_offsetof"] = Napi::Number::New(env, offsetof(VkCuLaunchInfoNVX, paramCount));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuLaunchInfoNVX_pParams_offsetof"] = Napi::Number::New(env, offsetof(VkCuLaunchInfoNVX, pParams));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuLaunchInfoNVX_extraCount_offsetof"] = Napi::Number::New(env, offsetof(VkCuLaunchInfoNVX, extraCount));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuLaunchInfoNVX_pExtras_offsetof"] = Napi::Number::New(env, offsetof(VkCuLaunchInfoNVX, pExtras));
#endif
#ifdef VK_NVX_binary_import
    exports["VkCuLaunchInfoNVX_sizeof"] = Napi::Number::New(env, sizeof(VkCuLaunchInfoNVX));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferFeaturesEXT, sType));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferFeaturesEXT_descriptorBuffer_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferFeaturesEXT, descriptorBuffer));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferFeaturesEXT_descriptorBufferCaptureReplay_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferFeaturesEXT, descriptorBufferCaptureReplay));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferFeaturesEXT_descriptorBufferImageLayoutIgnored_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferFeaturesEXT, descriptorBufferImageLayoutIgnored));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferFeaturesEXT_descriptorBufferPushDescriptors_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferFeaturesEXT, descriptorBufferPushDescriptors));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDescriptorBufferFeaturesEXT));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, sType));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_combinedImageSamplerDescriptorSingleArray_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, combinedImageSamplerDescriptorSingleArray));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_bufferlessPushDescriptors_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, bufferlessPushDescriptors));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_allowSamplerImageViewPostSubmitCreation_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, allowSamplerImageViewPostSubmitCreation));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_descriptorBufferOffsetAlignment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, descriptorBufferOffsetAlignment));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_maxDescriptorBufferBindings_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, maxDescriptorBufferBindings));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_maxResourceDescriptorBufferBindings_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, maxResourceDescriptorBufferBindings));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_maxSamplerDescriptorBufferBindings_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, maxSamplerDescriptorBufferBindings));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_maxEmbeddedImmutableSamplerBindings_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, maxEmbeddedImmutableSamplerBindings));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_maxEmbeddedImmutableSamplers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, maxEmbeddedImmutableSamplers));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_bufferCaptureReplayDescriptorDataSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, bufferCaptureReplayDescriptorDataSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_imageCaptureReplayDescriptorDataSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, imageCaptureReplayDescriptorDataSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_imageViewCaptureReplayDescriptorDataSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, imageViewCaptureReplayDescriptorDataSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_samplerCaptureReplayDescriptorDataSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, samplerCaptureReplayDescriptorDataSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_accelerationStructureCaptureReplayDescriptorDataSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, accelerationStructureCaptureReplayDescriptorDataSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_samplerDescriptorSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, samplerDescriptorSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_combinedImageSamplerDescriptorSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, combinedImageSamplerDescriptorSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_sampledImageDescriptorSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, sampledImageDescriptorSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_storageImageDescriptorSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, storageImageDescriptorSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_uniformTexelBufferDescriptorSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, uniformTexelBufferDescriptorSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_robustUniformTexelBufferDescriptorSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, robustUniformTexelBufferDescriptorSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_storageTexelBufferDescriptorSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, storageTexelBufferDescriptorSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_robustStorageTexelBufferDescriptorSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, robustStorageTexelBufferDescriptorSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_uniformBufferDescriptorSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, uniformBufferDescriptorSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_robustUniformBufferDescriptorSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, robustUniformBufferDescriptorSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_storageBufferDescriptorSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, storageBufferDescriptorSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_robustStorageBufferDescriptorSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, robustStorageBufferDescriptorSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_inputAttachmentDescriptorSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, inputAttachmentDescriptorSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_accelerationStructureDescriptorSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, accelerationStructureDescriptorSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_maxSamplerDescriptorBufferRange_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, maxSamplerDescriptorBufferRange));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_maxResourceDescriptorBufferRange_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, maxResourceDescriptorBufferRange));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_samplerDescriptorBufferAddressSpaceSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, samplerDescriptorBufferAddressSpaceSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_resourceDescriptorBufferAddressSpaceSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, resourceDescriptorBufferAddressSpaceSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_descriptorBufferAddressSpaceSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferPropertiesEXT, descriptorBufferAddressSpaceSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDescriptorBufferPropertiesEXT));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT, sType));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT_combinedImageSamplerDensityMapDescriptorSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT, combinedImageSamplerDensityMapDescriptorSize));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorAddressInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorAddressInfoEXT, sType));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorAddressInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorAddressInfoEXT, pNext));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorAddressInfoEXT_address_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorAddressInfoEXT, address));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorAddressInfoEXT_range_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorAddressInfoEXT, range));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorAddressInfoEXT_format_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorAddressInfoEXT, format));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorAddressInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorAddressInfoEXT));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorBufferBindingInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorBufferBindingInfoEXT, sType));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorBufferBindingInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorBufferBindingInfoEXT, pNext));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorBufferBindingInfoEXT_address_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorBufferBindingInfoEXT, address));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorBufferBindingInfoEXT_usage_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorBufferBindingInfoEXT, usage));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorBufferBindingInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorBufferBindingInfoEXT));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorBufferBindingPushDescriptorBufferHandleEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorBufferBindingPushDescriptorBufferHandleEXT, sType));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorBufferBindingPushDescriptorBufferHandleEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorBufferBindingPushDescriptorBufferHandleEXT, pNext));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorBufferBindingPushDescriptorBufferHandleEXT_buffer_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorBufferBindingPushDescriptorBufferHandleEXT, buffer));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorBufferBindingPushDescriptorBufferHandleEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorBufferBindingPushDescriptorBufferHandleEXT));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorGetInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorGetInfoEXT, sType));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorGetInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorGetInfoEXT, pNext));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorGetInfoEXT_type_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorGetInfoEXT, type));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorGetInfoEXT_data_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorGetInfoEXT, data));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkDescriptorGetInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorGetInfoEXT));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkBufferCaptureDescriptorDataInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCaptureDescriptorDataInfoEXT, sType));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkBufferCaptureDescriptorDataInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCaptureDescriptorDataInfoEXT, pNext));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkBufferCaptureDescriptorDataInfoEXT_buffer_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCaptureDescriptorDataInfoEXT, buffer));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkBufferCaptureDescriptorDataInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkBufferCaptureDescriptorDataInfoEXT));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkImageCaptureDescriptorDataInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageCaptureDescriptorDataInfoEXT, sType));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkImageCaptureDescriptorDataInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageCaptureDescriptorDataInfoEXT, pNext));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkImageCaptureDescriptorDataInfoEXT_image_offsetof"] = Napi::Number::New(env, offsetof(VkImageCaptureDescriptorDataInfoEXT, image));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkImageCaptureDescriptorDataInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkImageCaptureDescriptorDataInfoEXT));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkImageViewCaptureDescriptorDataInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewCaptureDescriptorDataInfoEXT, sType));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkImageViewCaptureDescriptorDataInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewCaptureDescriptorDataInfoEXT, pNext));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkImageViewCaptureDescriptorDataInfoEXT_imageView_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewCaptureDescriptorDataInfoEXT, imageView));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkImageViewCaptureDescriptorDataInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkImageViewCaptureDescriptorDataInfoEXT));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkSamplerCaptureDescriptorDataInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCaptureDescriptorDataInfoEXT, sType));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkSamplerCaptureDescriptorDataInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCaptureDescriptorDataInfoEXT, pNext));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkSamplerCaptureDescriptorDataInfoEXT_sampler_offsetof"] = Napi::Number::New(env, offsetof(VkSamplerCaptureDescriptorDataInfoEXT, sampler));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkSamplerCaptureDescriptorDataInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkSamplerCaptureDescriptorDataInfoEXT));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkAccelerationStructureCaptureDescriptorDataInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureCaptureDescriptorDataInfoEXT, sType));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkAccelerationStructureCaptureDescriptorDataInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureCaptureDescriptorDataInfoEXT, pNext));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkAccelerationStructureCaptureDescriptorDataInfoEXT_accelerationStructure_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureCaptureDescriptorDataInfoEXT, accelerationStructure));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkAccelerationStructureCaptureDescriptorDataInfoEXT_accelerationStructureNV_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureCaptureDescriptorDataInfoEXT, accelerationStructureNV));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkAccelerationStructureCaptureDescriptorDataInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureCaptureDescriptorDataInfoEXT));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkOpaqueCaptureDescriptorDataCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkOpaqueCaptureDescriptorDataCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkOpaqueCaptureDescriptorDataCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkOpaqueCaptureDescriptorDataCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkOpaqueCaptureDescriptorDataCreateInfoEXT_opaqueCaptureDescriptorData_offsetof"] = Napi::Number::New(env, offsetof(VkOpaqueCaptureDescriptorDataCreateInfoEXT, opaqueCaptureDescriptorData));
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["VkOpaqueCaptureDescriptorDataCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkOpaqueCaptureDescriptorDataCreateInfoEXT));
#endif
    exports["VkPhysicalDeviceShaderIntegerDotProductFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductFeatures, sType));
    exports["VkPhysicalDeviceShaderIntegerDotProductFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductFeatures, pNext));
    exports["VkPhysicalDeviceShaderIntegerDotProductFeatures_shaderIntegerDotProduct_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductFeatures, shaderIntegerDotProduct));
    exports["VkPhysicalDeviceShaderIntegerDotProductFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderIntegerDotProductFeatures));
#ifdef VK_KHR_shader_integer_dot_product
    exports["VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR));
#endif
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, sType));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, pNext));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProduct8BitUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProduct8BitUnsignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProduct8BitSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProduct8BitSignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProduct8BitMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProduct8BitMixedSignednessAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProduct4x8BitPackedUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProduct4x8BitPackedUnsignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProduct4x8BitPackedSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProduct4x8BitPackedSignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProduct4x8BitPackedMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProduct4x8BitPackedMixedSignednessAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProduct16BitUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProduct16BitUnsignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProduct16BitSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProduct16BitSignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProduct16BitMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProduct16BitMixedSignednessAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProduct32BitUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProduct32BitUnsignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProduct32BitSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProduct32BitSignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProduct32BitMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProduct32BitMixedSignednessAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProduct64BitUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProduct64BitUnsignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProduct64BitSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProduct64BitSignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProduct64BitMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProduct64BitMixedSignednessAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProductAccumulatingSaturating8BitUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProductAccumulatingSaturating8BitUnsignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProductAccumulatingSaturating8BitSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProductAccumulatingSaturating8BitSignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProductAccumulatingSaturating16BitUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProductAccumulatingSaturating16BitUnsignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProductAccumulatingSaturating16BitSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProductAccumulatingSaturating16BitSignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProductAccumulatingSaturating32BitUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProductAccumulatingSaturating32BitUnsignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProductAccumulatingSaturating32BitSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProductAccumulatingSaturating32BitSignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProductAccumulatingSaturating64BitUnsignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProductAccumulatingSaturating64BitUnsignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProductAccumulatingSaturating64BitSignedAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProductAccumulatingSaturating64BitSignedAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderIntegerDotProductProperties, integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated));
    exports["VkPhysicalDeviceShaderIntegerDotProductProperties_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderIntegerDotProductProperties));
#ifdef VK_KHR_shader_integer_dot_product
    exports["VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR));
#endif
#ifdef VK_EXT_physical_device_drm
    exports["VkPhysicalDeviceDrmPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDrmPropertiesEXT, sType));
#endif
#ifdef VK_EXT_physical_device_drm
    exports["VkPhysicalDeviceDrmPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDrmPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_physical_device_drm
    exports["VkPhysicalDeviceDrmPropertiesEXT_hasPrimary_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDrmPropertiesEXT, hasPrimary));
#endif
#ifdef VK_EXT_physical_device_drm
    exports["VkPhysicalDeviceDrmPropertiesEXT_hasRender_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDrmPropertiesEXT, hasRender));
#endif
#ifdef VK_EXT_physical_device_drm
    exports["VkPhysicalDeviceDrmPropertiesEXT_primaryMajor_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDrmPropertiesEXT, primaryMajor));
#endif
#ifdef VK_EXT_physical_device_drm
    exports["VkPhysicalDeviceDrmPropertiesEXT_primaryMinor_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDrmPropertiesEXT, primaryMinor));
#endif
#ifdef VK_EXT_physical_device_drm
    exports["VkPhysicalDeviceDrmPropertiesEXT_renderMajor_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDrmPropertiesEXT, renderMajor));
#endif
#ifdef VK_EXT_physical_device_drm
    exports["VkPhysicalDeviceDrmPropertiesEXT_renderMinor_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDrmPropertiesEXT, renderMinor));
#endif
#ifdef VK_EXT_physical_device_drm
    exports["VkPhysicalDeviceDrmPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDrmPropertiesEXT));
#endif
#ifdef VK_KHR_fragment_shader_barycentric
    exports["VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR, sType));
#endif
#ifdef VK_KHR_fragment_shader_barycentric
    exports["VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR, pNext));
#endif
#ifdef VK_KHR_fragment_shader_barycentric
    exports["VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR_fragmentShaderBarycentric_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR, fragmentShaderBarycentric));
#endif
#ifdef VK_KHR_fragment_shader_barycentric
    exports["VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR));
#endif
#ifdef VK_KHR_fragment_shader_barycentric
    exports["VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR, sType));
#endif
#ifdef VK_KHR_fragment_shader_barycentric
    exports["VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR, pNext));
#endif
#ifdef VK_KHR_fragment_shader_barycentric
    exports["VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR_triStripVertexOrderIndependentOfProvokingVertex_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR, triStripVertexOrderIndependentOfProvokingVertex));
#endif
#ifdef VK_KHR_fragment_shader_barycentric
    exports["VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkPhysicalDeviceRayTracingMotionBlurFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV, sType));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkPhysicalDeviceRayTracingMotionBlurFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV, pNext));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkPhysicalDeviceRayTracingMotionBlurFeaturesNV_rayTracingMotionBlur_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV, rayTracingMotionBlur));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkPhysicalDeviceRayTracingMotionBlurFeaturesNV_rayTracingMotionBlurPipelineTraceRaysIndirect_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV, rayTracingMotionBlurPipelineTraceRaysIndirect));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkPhysicalDeviceRayTracingMotionBlurFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureGeometryMotionTrianglesDataNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryMotionTrianglesDataNV, sType));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureGeometryMotionTrianglesDataNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryMotionTrianglesDataNV, pNext));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureGeometryMotionTrianglesDataNV_vertexData_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureGeometryMotionTrianglesDataNV, vertexData));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureGeometryMotionTrianglesDataNV_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureGeometryMotionTrianglesDataNV));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureMotionInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureMotionInfoNV, sType));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureMotionInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureMotionInfoNV, pNext));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureMotionInfoNV_maxInstances_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureMotionInfoNV, maxInstances));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureMotionInfoNV_flags_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureMotionInfoNV, flags));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureMotionInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureMotionInfoNV));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkSRTDataNV_sx_offsetof"] = Napi::Number::New(env, offsetof(VkSRTDataNV, sx));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkSRTDataNV_a_offsetof"] = Napi::Number::New(env, offsetof(VkSRTDataNV, a));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkSRTDataNV_b_offsetof"] = Napi::Number::New(env, offsetof(VkSRTDataNV, b));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkSRTDataNV_pvx_offsetof"] = Napi::Number::New(env, offsetof(VkSRTDataNV, pvx));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkSRTDataNV_sy_offsetof"] = Napi::Number::New(env, offsetof(VkSRTDataNV, sy));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkSRTDataNV_c_offsetof"] = Napi::Number::New(env, offsetof(VkSRTDataNV, c));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkSRTDataNV_pvy_offsetof"] = Napi::Number::New(env, offsetof(VkSRTDataNV, pvy));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkSRTDataNV_sz_offsetof"] = Napi::Number::New(env, offsetof(VkSRTDataNV, sz));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkSRTDataNV_pvz_offsetof"] = Napi::Number::New(env, offsetof(VkSRTDataNV, pvz));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkSRTDataNV_qx_offsetof"] = Napi::Number::New(env, offsetof(VkSRTDataNV, qx));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkSRTDataNV_qy_offsetof"] = Napi::Number::New(env, offsetof(VkSRTDataNV, qy));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkSRTDataNV_qz_offsetof"] = Napi::Number::New(env, offsetof(VkSRTDataNV, qz));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkSRTDataNV_qw_offsetof"] = Napi::Number::New(env, offsetof(VkSRTDataNV, qw));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkSRTDataNV_tx_offsetof"] = Napi::Number::New(env, offsetof(VkSRTDataNV, tx));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkSRTDataNV_ty_offsetof"] = Napi::Number::New(env, offsetof(VkSRTDataNV, ty));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkSRTDataNV_tz_offsetof"] = Napi::Number::New(env, offsetof(VkSRTDataNV, tz));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkSRTDataNV_sizeof"] = Napi::Number::New(env, sizeof(VkSRTDataNV));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureSRTMotionInstanceNV_transformT0_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureSRTMotionInstanceNV, transformT0));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureSRTMotionInstanceNV_transformT1_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureSRTMotionInstanceNV, transformT1));
#endif




#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureSRTMotionInstanceNV_accelerationStructureReference_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureSRTMotionInstanceNV, accelerationStructureReference));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureSRTMotionInstanceNV_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureSRTMotionInstanceNV));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureMatrixMotionInstanceNV_transformT0_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureMatrixMotionInstanceNV, transformT0));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureMatrixMotionInstanceNV_transformT1_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureMatrixMotionInstanceNV, transformT1));
#endif




#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureMatrixMotionInstanceNV_accelerationStructureReference_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureMatrixMotionInstanceNV, accelerationStructureReference));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureMatrixMotionInstanceNV_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureMatrixMotionInstanceNV));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureMotionInstanceNV_type_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureMotionInstanceNV, type));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureMotionInstanceNV_flags_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureMotionInstanceNV, flags));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureMotionInstanceNV_data_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureMotionInstanceNV, data));
#endif
#ifdef VK_NV_ray_tracing_motion_blur
    exports["VkAccelerationStructureMotionInstanceNV_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureMotionInstanceNV));
#endif
#ifdef VK_NV_external_memory_rdma
    exports["VkMemoryGetRemoteAddressInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetRemoteAddressInfoNV, sType));
#endif
#ifdef VK_NV_external_memory_rdma
    exports["VkMemoryGetRemoteAddressInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetRemoteAddressInfoNV, pNext));
#endif
#ifdef VK_NV_external_memory_rdma
    exports["VkMemoryGetRemoteAddressInfoNV_memory_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetRemoteAddressInfoNV, memory));
#endif
#ifdef VK_NV_external_memory_rdma
    exports["VkMemoryGetRemoteAddressInfoNV_handleType_offsetof"] = Napi::Number::New(env, offsetof(VkMemoryGetRemoteAddressInfoNV, handleType));
#endif
#ifdef VK_NV_external_memory_rdma
    exports["VkMemoryGetRemoteAddressInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkMemoryGetRemoteAddressInfoNV));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImportMemoryBufferCollectionFUCHSIA_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryBufferCollectionFUCHSIA, sType));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImportMemoryBufferCollectionFUCHSIA_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryBufferCollectionFUCHSIA, pNext));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImportMemoryBufferCollectionFUCHSIA_collection_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryBufferCollectionFUCHSIA, collection));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImportMemoryBufferCollectionFUCHSIA_index_offsetof"] = Napi::Number::New(env, offsetof(VkImportMemoryBufferCollectionFUCHSIA, index));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImportMemoryBufferCollectionFUCHSIA_sizeof"] = Napi::Number::New(env, sizeof(VkImportMemoryBufferCollectionFUCHSIA));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionImageCreateInfoFUCHSIA_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionImageCreateInfoFUCHSIA, sType));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionImageCreateInfoFUCHSIA_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionImageCreateInfoFUCHSIA, pNext));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionImageCreateInfoFUCHSIA_collection_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionImageCreateInfoFUCHSIA, collection));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionImageCreateInfoFUCHSIA_index_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionImageCreateInfoFUCHSIA, index));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionImageCreateInfoFUCHSIA_sizeof"] = Napi::Number::New(env, sizeof(VkBufferCollectionImageCreateInfoFUCHSIA));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionBufferCreateInfoFUCHSIA_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionBufferCreateInfoFUCHSIA, sType));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionBufferCreateInfoFUCHSIA_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionBufferCreateInfoFUCHSIA, pNext));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionBufferCreateInfoFUCHSIA_collection_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionBufferCreateInfoFUCHSIA, collection));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionBufferCreateInfoFUCHSIA_index_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionBufferCreateInfoFUCHSIA, index));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionBufferCreateInfoFUCHSIA_sizeof"] = Napi::Number::New(env, sizeof(VkBufferCollectionBufferCreateInfoFUCHSIA));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionCreateInfoFUCHSIA_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionCreateInfoFUCHSIA, sType));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionCreateInfoFUCHSIA_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionCreateInfoFUCHSIA, pNext));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionCreateInfoFUCHSIA_collectionToken_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionCreateInfoFUCHSIA, collectionToken));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionCreateInfoFUCHSIA_sizeof"] = Napi::Number::New(env, sizeof(VkBufferCollectionCreateInfoFUCHSIA));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionPropertiesFUCHSIA_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionPropertiesFUCHSIA, sType));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionPropertiesFUCHSIA_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionPropertiesFUCHSIA, pNext));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionPropertiesFUCHSIA_memoryTypeBits_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionPropertiesFUCHSIA, memoryTypeBits));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionPropertiesFUCHSIA_bufferCount_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionPropertiesFUCHSIA, bufferCount));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionPropertiesFUCHSIA_createInfoIndex_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionPropertiesFUCHSIA, createInfoIndex));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionPropertiesFUCHSIA_sysmemPixelFormat_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionPropertiesFUCHSIA, sysmemPixelFormat));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionPropertiesFUCHSIA_formatFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionPropertiesFUCHSIA, formatFeatures));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionPropertiesFUCHSIA_sysmemColorSpaceIndex_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionPropertiesFUCHSIA, sysmemColorSpaceIndex));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionPropertiesFUCHSIA_samplerYcbcrConversionComponents_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionPropertiesFUCHSIA, samplerYcbcrConversionComponents));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionPropertiesFUCHSIA_suggestedYcbcrModel_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionPropertiesFUCHSIA, suggestedYcbcrModel));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionPropertiesFUCHSIA_suggestedYcbcrRange_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionPropertiesFUCHSIA, suggestedYcbcrRange));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionPropertiesFUCHSIA_suggestedXChromaOffset_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionPropertiesFUCHSIA, suggestedXChromaOffset));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionPropertiesFUCHSIA_suggestedYChromaOffset_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionPropertiesFUCHSIA, suggestedYChromaOffset));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionPropertiesFUCHSIA_sizeof"] = Napi::Number::New(env, sizeof(VkBufferCollectionPropertiesFUCHSIA));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferConstraintsInfoFUCHSIA_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBufferConstraintsInfoFUCHSIA, sType));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferConstraintsInfoFUCHSIA_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBufferConstraintsInfoFUCHSIA, pNext));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferConstraintsInfoFUCHSIA_createInfo_offsetof"] = Napi::Number::New(env, offsetof(VkBufferConstraintsInfoFUCHSIA, createInfo));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferConstraintsInfoFUCHSIA_requiredFormatFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkBufferConstraintsInfoFUCHSIA, requiredFormatFeatures));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferConstraintsInfoFUCHSIA_bufferCollectionConstraints_offsetof"] = Napi::Number::New(env, offsetof(VkBufferConstraintsInfoFUCHSIA, bufferCollectionConstraints));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferConstraintsInfoFUCHSIA_sizeof"] = Napi::Number::New(env, sizeof(VkBufferConstraintsInfoFUCHSIA));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkSysmemColorSpaceFUCHSIA_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSysmemColorSpaceFUCHSIA, sType));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkSysmemColorSpaceFUCHSIA_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSysmemColorSpaceFUCHSIA, pNext));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkSysmemColorSpaceFUCHSIA_colorSpace_offsetof"] = Napi::Number::New(env, offsetof(VkSysmemColorSpaceFUCHSIA, colorSpace));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkSysmemColorSpaceFUCHSIA_sizeof"] = Napi::Number::New(env, sizeof(VkSysmemColorSpaceFUCHSIA));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImageFormatConstraintsInfoFUCHSIA_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatConstraintsInfoFUCHSIA, sType));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImageFormatConstraintsInfoFUCHSIA_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatConstraintsInfoFUCHSIA, pNext));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImageFormatConstraintsInfoFUCHSIA_imageCreateInfo_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatConstraintsInfoFUCHSIA, imageCreateInfo));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImageFormatConstraintsInfoFUCHSIA_requiredFormatFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatConstraintsInfoFUCHSIA, requiredFormatFeatures));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImageFormatConstraintsInfoFUCHSIA_flags_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatConstraintsInfoFUCHSIA, flags));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImageFormatConstraintsInfoFUCHSIA_sysmemPixelFormat_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatConstraintsInfoFUCHSIA, sysmemPixelFormat));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImageFormatConstraintsInfoFUCHSIA_colorSpaceCount_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatConstraintsInfoFUCHSIA, colorSpaceCount));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImageFormatConstraintsInfoFUCHSIA_pColorSpaces_offsetof"] = Napi::Number::New(env, offsetof(VkImageFormatConstraintsInfoFUCHSIA, pColorSpaces));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImageFormatConstraintsInfoFUCHSIA_sizeof"] = Napi::Number::New(env, sizeof(VkImageFormatConstraintsInfoFUCHSIA));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImageConstraintsInfoFUCHSIA_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageConstraintsInfoFUCHSIA, sType));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImageConstraintsInfoFUCHSIA_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageConstraintsInfoFUCHSIA, pNext));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImageConstraintsInfoFUCHSIA_formatConstraintsCount_offsetof"] = Napi::Number::New(env, offsetof(VkImageConstraintsInfoFUCHSIA, formatConstraintsCount));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImageConstraintsInfoFUCHSIA_pFormatConstraints_offsetof"] = Napi::Number::New(env, offsetof(VkImageConstraintsInfoFUCHSIA, pFormatConstraints));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImageConstraintsInfoFUCHSIA_bufferCollectionConstraints_offsetof"] = Napi::Number::New(env, offsetof(VkImageConstraintsInfoFUCHSIA, bufferCollectionConstraints));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImageConstraintsInfoFUCHSIA_flags_offsetof"] = Napi::Number::New(env, offsetof(VkImageConstraintsInfoFUCHSIA, flags));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkImageConstraintsInfoFUCHSIA_sizeof"] = Napi::Number::New(env, sizeof(VkImageConstraintsInfoFUCHSIA));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionConstraintsInfoFUCHSIA_sType_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionConstraintsInfoFUCHSIA, sType));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionConstraintsInfoFUCHSIA_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionConstraintsInfoFUCHSIA, pNext));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionConstraintsInfoFUCHSIA_minBufferCount_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionConstraintsInfoFUCHSIA, minBufferCount));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionConstraintsInfoFUCHSIA_maxBufferCount_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionConstraintsInfoFUCHSIA, maxBufferCount));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionConstraintsInfoFUCHSIA_minBufferCountForCamping_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionConstraintsInfoFUCHSIA, minBufferCountForCamping));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionConstraintsInfoFUCHSIA_minBufferCountForDedicatedSlack_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionConstraintsInfoFUCHSIA, minBufferCountForDedicatedSlack));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionConstraintsInfoFUCHSIA_minBufferCountForSharedSlack_offsetof"] = Napi::Number::New(env, offsetof(VkBufferCollectionConstraintsInfoFUCHSIA, minBufferCountForSharedSlack));
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["VkBufferCollectionConstraintsInfoFUCHSIA_sizeof"] = Napi::Number::New(env, sizeof(VkBufferCollectionConstraintsInfoFUCHSIA));
#endif
#ifdef VK_EXT_rgba10x6_formats
    exports["VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT, sType));
#endif
#ifdef VK_EXT_rgba10x6_formats
    exports["VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_rgba10x6_formats
    exports["VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT_formatRgba10x6WithoutYCbCrSampler_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT, formatRgba10x6WithoutYCbCrSampler));
#endif
#ifdef VK_EXT_rgba10x6_formats
    exports["VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT));
#endif
    exports["VkFormatProperties3_sType_offsetof"] = Napi::Number::New(env, offsetof(VkFormatProperties3, sType));
    exports["VkFormatProperties3_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkFormatProperties3, pNext));
    exports["VkFormatProperties3_linearTilingFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkFormatProperties3, linearTilingFeatures));
    exports["VkFormatProperties3_optimalTilingFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkFormatProperties3, optimalTilingFeatures));
    exports["VkFormatProperties3_bufferFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkFormatProperties3, bufferFeatures));
    exports["VkFormatProperties3_sizeof"] = Napi::Number::New(env, sizeof(VkFormatProperties3));
#ifdef VK_KHR_format_feature_flags2
    exports["VkFormatProperties3KHR_sizeof"] = Napi::Number::New(env, sizeof(VkFormatProperties3KHR));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierPropertiesList2EXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDrmFormatModifierPropertiesList2EXT, sType));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierPropertiesList2EXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDrmFormatModifierPropertiesList2EXT, pNext));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierPropertiesList2EXT_drmFormatModifierCount_offsetof"] = Napi::Number::New(env, offsetof(VkDrmFormatModifierPropertiesList2EXT, drmFormatModifierCount));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierPropertiesList2EXT_pDrmFormatModifierProperties_offsetof"] = Napi::Number::New(env, offsetof(VkDrmFormatModifierPropertiesList2EXT, pDrmFormatModifierProperties));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierPropertiesList2EXT_sizeof"] = Napi::Number::New(env, sizeof(VkDrmFormatModifierPropertiesList2EXT));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierProperties2EXT_drmFormatModifier_offsetof"] = Napi::Number::New(env, offsetof(VkDrmFormatModifierProperties2EXT, drmFormatModifier));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierProperties2EXT_drmFormatModifierPlaneCount_offsetof"] = Napi::Number::New(env, offsetof(VkDrmFormatModifierProperties2EXT, drmFormatModifierPlaneCount));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierProperties2EXT_drmFormatModifierTilingFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkDrmFormatModifierProperties2EXT, drmFormatModifierTilingFeatures));
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["VkDrmFormatModifierProperties2EXT_sizeof"] = Napi::Number::New(env, sizeof(VkDrmFormatModifierProperties2EXT));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatProperties2ANDROID_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatProperties2ANDROID, sType));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatProperties2ANDROID_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatProperties2ANDROID, pNext));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatProperties2ANDROID_format_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatProperties2ANDROID, format));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatProperties2ANDROID_externalFormat_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatProperties2ANDROID, externalFormat));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatProperties2ANDROID_formatFeatures_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatProperties2ANDROID, formatFeatures));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatProperties2ANDROID_samplerYcbcrConversionComponents_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatProperties2ANDROID, samplerYcbcrConversionComponents));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatProperties2ANDROID_suggestedYcbcrModel_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatProperties2ANDROID, suggestedYcbcrModel));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatProperties2ANDROID_suggestedYcbcrRange_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatProperties2ANDROID, suggestedYcbcrRange));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatProperties2ANDROID_suggestedXChromaOffset_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatProperties2ANDROID, suggestedXChromaOffset));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatProperties2ANDROID_suggestedYChromaOffset_offsetof"] = Napi::Number::New(env, offsetof(VkAndroidHardwareBufferFormatProperties2ANDROID, suggestedYChromaOffset));
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["VkAndroidHardwareBufferFormatProperties2ANDROID_sizeof"] = Napi::Number::New(env, sizeof(VkAndroidHardwareBufferFormatProperties2ANDROID));
#endif
    exports["VkPipelineRenderingCreateInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRenderingCreateInfo, sType));
    exports["VkPipelineRenderingCreateInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRenderingCreateInfo, pNext));
    exports["VkPipelineRenderingCreateInfo_viewMask_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRenderingCreateInfo, viewMask));
    exports["VkPipelineRenderingCreateInfo_colorAttachmentCount_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRenderingCreateInfo, colorAttachmentCount));
    exports["VkPipelineRenderingCreateInfo_pColorAttachmentFormats_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRenderingCreateInfo, pColorAttachmentFormats));
    exports["VkPipelineRenderingCreateInfo_depthAttachmentFormat_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRenderingCreateInfo, depthAttachmentFormat));
    exports["VkPipelineRenderingCreateInfo_stencilAttachmentFormat_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRenderingCreateInfo, stencilAttachmentFormat));
    exports["VkPipelineRenderingCreateInfo_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineRenderingCreateInfo));
#ifdef VK_KHR_dynamic_rendering
    exports["VkPipelineRenderingCreateInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineRenderingCreateInfoKHR));
#endif
    exports["VkRenderingInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingInfo, sType));
    exports["VkRenderingInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingInfo, pNext));
    exports["VkRenderingInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingInfo, flags));
    exports["VkRenderingInfo_renderArea_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingInfo, renderArea));
    exports["VkRenderingInfo_layerCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingInfo, layerCount));
    exports["VkRenderingInfo_viewMask_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingInfo, viewMask));
    exports["VkRenderingInfo_colorAttachmentCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingInfo, colorAttachmentCount));
    exports["VkRenderingInfo_pColorAttachments_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingInfo, pColorAttachments));
    exports["VkRenderingInfo_pDepthAttachment_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingInfo, pDepthAttachment));
    exports["VkRenderingInfo_pStencilAttachment_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingInfo, pStencilAttachment));
    exports["VkRenderingInfo_sizeof"] = Napi::Number::New(env, sizeof(VkRenderingInfo));
#ifdef VK_QCOM_tile_properties
    exports["VkRenderingInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkRenderingInfoKHR));
#endif
    exports["VkRenderingAttachmentInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingAttachmentInfo, sType));
    exports["VkRenderingAttachmentInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingAttachmentInfo, pNext));
    exports["VkRenderingAttachmentInfo_imageView_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingAttachmentInfo, imageView));
    exports["VkRenderingAttachmentInfo_imageLayout_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingAttachmentInfo, imageLayout));
    exports["VkRenderingAttachmentInfo_resolveMode_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingAttachmentInfo, resolveMode));
    exports["VkRenderingAttachmentInfo_resolveImageView_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingAttachmentInfo, resolveImageView));
    exports["VkRenderingAttachmentInfo_resolveImageLayout_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingAttachmentInfo, resolveImageLayout));
    exports["VkRenderingAttachmentInfo_loadOp_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingAttachmentInfo, loadOp));
    exports["VkRenderingAttachmentInfo_storeOp_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingAttachmentInfo, storeOp));
    exports["VkRenderingAttachmentInfo_clearValue_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingAttachmentInfo, clearValue));
    exports["VkRenderingAttachmentInfo_sizeof"] = Napi::Number::New(env, sizeof(VkRenderingAttachmentInfo));
#ifdef VK_KHR_dynamic_rendering
    exports["VkRenderingAttachmentInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkRenderingAttachmentInfoKHR));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkRenderingFragmentShadingRateAttachmentInfoKHR_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingFragmentShadingRateAttachmentInfoKHR, sType));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkRenderingFragmentShadingRateAttachmentInfoKHR_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingFragmentShadingRateAttachmentInfoKHR, pNext));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkRenderingFragmentShadingRateAttachmentInfoKHR_imageView_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingFragmentShadingRateAttachmentInfoKHR, imageView));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkRenderingFragmentShadingRateAttachmentInfoKHR_imageLayout_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingFragmentShadingRateAttachmentInfoKHR, imageLayout));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkRenderingFragmentShadingRateAttachmentInfoKHR_shadingRateAttachmentTexelSize_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingFragmentShadingRateAttachmentInfoKHR, shadingRateAttachmentTexelSize));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkRenderingFragmentShadingRateAttachmentInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkRenderingFragmentShadingRateAttachmentInfoKHR));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkRenderingFragmentDensityMapAttachmentInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingFragmentDensityMapAttachmentInfoEXT, sType));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkRenderingFragmentDensityMapAttachmentInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingFragmentDensityMapAttachmentInfoEXT, pNext));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkRenderingFragmentDensityMapAttachmentInfoEXT_imageView_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingFragmentDensityMapAttachmentInfoEXT, imageView));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkRenderingFragmentDensityMapAttachmentInfoEXT_imageLayout_offsetof"] = Napi::Number::New(env, offsetof(VkRenderingFragmentDensityMapAttachmentInfoEXT, imageLayout));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkRenderingFragmentDensityMapAttachmentInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkRenderingFragmentDensityMapAttachmentInfoEXT));
#endif
    exports["VkPhysicalDeviceDynamicRenderingFeatures_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDynamicRenderingFeatures, sType));
    exports["VkPhysicalDeviceDynamicRenderingFeatures_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDynamicRenderingFeatures, pNext));
    exports["VkPhysicalDeviceDynamicRenderingFeatures_dynamicRendering_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDynamicRenderingFeatures, dynamicRendering));
    exports["VkPhysicalDeviceDynamicRenderingFeatures_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDynamicRenderingFeatures));
#ifdef VK_KHR_dynamic_rendering
    exports["VkPhysicalDeviceDynamicRenderingFeaturesKHR_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDynamicRenderingFeaturesKHR));
#endif
    exports["VkCommandBufferInheritanceRenderingInfo_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceRenderingInfo, sType));
    exports["VkCommandBufferInheritanceRenderingInfo_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceRenderingInfo, pNext));
    exports["VkCommandBufferInheritanceRenderingInfo_flags_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceRenderingInfo, flags));
    exports["VkCommandBufferInheritanceRenderingInfo_viewMask_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceRenderingInfo, viewMask));
    exports["VkCommandBufferInheritanceRenderingInfo_colorAttachmentCount_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceRenderingInfo, colorAttachmentCount));
    exports["VkCommandBufferInheritanceRenderingInfo_pColorAttachmentFormats_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceRenderingInfo, pColorAttachmentFormats));
    exports["VkCommandBufferInheritanceRenderingInfo_depthAttachmentFormat_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceRenderingInfo, depthAttachmentFormat));
    exports["VkCommandBufferInheritanceRenderingInfo_stencilAttachmentFormat_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceRenderingInfo, stencilAttachmentFormat));
    exports["VkCommandBufferInheritanceRenderingInfo_rasterizationSamples_offsetof"] = Napi::Number::New(env, offsetof(VkCommandBufferInheritanceRenderingInfo, rasterizationSamples));
    exports["VkCommandBufferInheritanceRenderingInfo_sizeof"] = Napi::Number::New(env, sizeof(VkCommandBufferInheritanceRenderingInfo));
#ifdef VK_KHR_dynamic_rendering
    exports["VkCommandBufferInheritanceRenderingInfoKHR_sizeof"] = Napi::Number::New(env, sizeof(VkCommandBufferInheritanceRenderingInfoKHR));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkAttachmentSampleCountInfoAMD_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentSampleCountInfoAMD, sType));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkAttachmentSampleCountInfoAMD_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentSampleCountInfoAMD, pNext));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkAttachmentSampleCountInfoAMD_colorAttachmentCount_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentSampleCountInfoAMD, colorAttachmentCount));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkAttachmentSampleCountInfoAMD_pColorAttachmentSamples_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentSampleCountInfoAMD, pColorAttachmentSamples));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkAttachmentSampleCountInfoAMD_depthStencilAttachmentSamples_offsetof"] = Napi::Number::New(env, offsetof(VkAttachmentSampleCountInfoAMD, depthStencilAttachmentSamples));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkAttachmentSampleCountInfoAMD_sizeof"] = Napi::Number::New(env, sizeof(VkAttachmentSampleCountInfoAMD));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkAttachmentSampleCountInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkAttachmentSampleCountInfoNV));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkMultiviewPerViewAttributesInfoNVX_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMultiviewPerViewAttributesInfoNVX, sType));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkMultiviewPerViewAttributesInfoNVX_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMultiviewPerViewAttributesInfoNVX, pNext));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkMultiviewPerViewAttributesInfoNVX_perViewAttributes_offsetof"] = Napi::Number::New(env, offsetof(VkMultiviewPerViewAttributesInfoNVX, perViewAttributes));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkMultiviewPerViewAttributesInfoNVX_perViewAttributesPositionXOnly_offsetof"] = Napi::Number::New(env, offsetof(VkMultiviewPerViewAttributesInfoNVX, perViewAttributesPositionXOnly));
#endif
#ifdef VK_KHR_dynamic_rendering
    exports["VkMultiviewPerViewAttributesInfoNVX_sizeof"] = Napi::Number::New(env, sizeof(VkMultiviewPerViewAttributesInfoNVX));
#endif
#ifdef VK_EXT_image_view_min_lod
    exports["VkPhysicalDeviceImageViewMinLodFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageViewMinLodFeaturesEXT, sType));
#endif
#ifdef VK_EXT_image_view_min_lod
    exports["VkPhysicalDeviceImageViewMinLodFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageViewMinLodFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_image_view_min_lod
    exports["VkPhysicalDeviceImageViewMinLodFeaturesEXT_minLod_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageViewMinLodFeaturesEXT, minLod));
#endif
#ifdef VK_EXT_image_view_min_lod
    exports["VkPhysicalDeviceImageViewMinLodFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceImageViewMinLodFeaturesEXT));
#endif
#ifdef VK_EXT_image_view_min_lod
    exports["VkImageViewMinLodCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewMinLodCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_image_view_min_lod
    exports["VkImageViewMinLodCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewMinLodCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_image_view_min_lod
    exports["VkImageViewMinLodCreateInfoEXT_minLod_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewMinLodCreateInfoEXT, minLod));
#endif
#ifdef VK_EXT_image_view_min_lod
    exports["VkImageViewMinLodCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkImageViewMinLodCreateInfoEXT));
#endif
#ifdef VK_EXT_rasterization_order_attachment_access
    exports["VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, sType));
#endif
#ifdef VK_EXT_rasterization_order_attachment_access
    exports["VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_rasterization_order_attachment_access
    exports["VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT_rasterizationOrderColorAttachmentAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, rasterizationOrderColorAttachmentAccess));
#endif
#ifdef VK_EXT_rasterization_order_attachment_access
    exports["VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT_rasterizationOrderDepthAttachmentAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, rasterizationOrderDepthAttachmentAccess));
#endif
#ifdef VK_EXT_rasterization_order_attachment_access
    exports["VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT_rasterizationOrderStencilAttachmentAccess_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, rasterizationOrderStencilAttachmentAccess));
#endif
#ifdef VK_EXT_rasterization_order_attachment_access
    exports["VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT));
#endif
#ifdef VK_ARM_rasterization_order_attachment_access
    exports["VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM));
#endif
#ifdef VK_NV_linear_color_attachment
    exports["VkPhysicalDeviceLinearColorAttachmentFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLinearColorAttachmentFeaturesNV, sType));
#endif
#ifdef VK_NV_linear_color_attachment
    exports["VkPhysicalDeviceLinearColorAttachmentFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLinearColorAttachmentFeaturesNV, pNext));
#endif
#ifdef VK_NV_linear_color_attachment
    exports["VkPhysicalDeviceLinearColorAttachmentFeaturesNV_linearColorAttachment_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceLinearColorAttachmentFeaturesNV, linearColorAttachment));
#endif
#ifdef VK_NV_linear_color_attachment
    exports["VkPhysicalDeviceLinearColorAttachmentFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceLinearColorAttachmentFeaturesNV));
#endif
#ifdef VK_EXT_graphics_pipeline_library
    exports["VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT, sType));
#endif
#ifdef VK_EXT_graphics_pipeline_library
    exports["VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_graphics_pipeline_library
    exports["VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT_graphicsPipelineLibrary_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT, graphicsPipelineLibrary));
#endif
#ifdef VK_EXT_graphics_pipeline_library
    exports["VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT));
#endif
#ifdef VK_EXT_graphics_pipeline_library
    exports["VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT, sType));
#endif
#ifdef VK_EXT_graphics_pipeline_library
    exports["VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_graphics_pipeline_library
    exports["VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT_graphicsPipelineLibraryFastLinking_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT, graphicsPipelineLibraryFastLinking));
#endif
#ifdef VK_EXT_graphics_pipeline_library
    exports["VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT_graphicsPipelineLibraryIndependentInterpolationDecoration_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT, graphicsPipelineLibraryIndependentInterpolationDecoration));
#endif
#ifdef VK_EXT_graphics_pipeline_library
    exports["VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT));
#endif
#ifdef VK_EXT_graphics_pipeline_library
    exports["VkGraphicsPipelineLibraryCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineLibraryCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_graphics_pipeline_library
    exports["VkGraphicsPipelineLibraryCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineLibraryCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_graphics_pipeline_library
    exports["VkGraphicsPipelineLibraryCreateInfoEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkGraphicsPipelineLibraryCreateInfoEXT, flags));
#endif
#ifdef VK_EXT_graphics_pipeline_library
    exports["VkGraphicsPipelineLibraryCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkGraphicsPipelineLibraryCreateInfoEXT));
#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
    exports["VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE, sType));
#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
    exports["VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE, pNext));
#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
    exports["VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE_descriptorSetHostMapping_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE, descriptorSetHostMapping));
#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
    exports["VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE));
#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
    exports["VkDescriptorSetBindingReferenceVALVE_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetBindingReferenceVALVE, sType));
#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
    exports["VkDescriptorSetBindingReferenceVALVE_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetBindingReferenceVALVE, pNext));
#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
    exports["VkDescriptorSetBindingReferenceVALVE_descriptorSetLayout_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetBindingReferenceVALVE, descriptorSetLayout));
#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
    exports["VkDescriptorSetBindingReferenceVALVE_binding_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetBindingReferenceVALVE, binding));
#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
    exports["VkDescriptorSetBindingReferenceVALVE_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorSetBindingReferenceVALVE));
#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
    exports["VkDescriptorSetLayoutHostMappingInfoVALVE_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutHostMappingInfoVALVE, sType));
#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
    exports["VkDescriptorSetLayoutHostMappingInfoVALVE_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutHostMappingInfoVALVE, pNext));
#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
    exports["VkDescriptorSetLayoutHostMappingInfoVALVE_descriptorOffset_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutHostMappingInfoVALVE, descriptorOffset));
#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
    exports["VkDescriptorSetLayoutHostMappingInfoVALVE_descriptorSize_offsetof"] = Napi::Number::New(env, offsetof(VkDescriptorSetLayoutHostMappingInfoVALVE, descriptorSize));
#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
    exports["VkDescriptorSetLayoutHostMappingInfoVALVE_sizeof"] = Napi::Number::New(env, sizeof(VkDescriptorSetLayoutHostMappingInfoVALVE));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT, sType));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT_shaderModuleIdentifier_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT, shaderModuleIdentifier));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT, sType));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT_shaderModuleIdentifierAlgorithmUUID_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT, shaderModuleIdentifierAlgorithmUUID));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkPipelineShaderStageModuleIdentifierCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineShaderStageModuleIdentifierCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkPipelineShaderStageModuleIdentifierCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineShaderStageModuleIdentifierCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkPipelineShaderStageModuleIdentifierCreateInfoEXT_identifierSize_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineShaderStageModuleIdentifierCreateInfoEXT, identifierSize));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkPipelineShaderStageModuleIdentifierCreateInfoEXT_pIdentifier_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineShaderStageModuleIdentifierCreateInfoEXT, pIdentifier));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkPipelineShaderStageModuleIdentifierCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineShaderStageModuleIdentifierCreateInfoEXT));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkShaderModuleIdentifierEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkShaderModuleIdentifierEXT, sType));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkShaderModuleIdentifierEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkShaderModuleIdentifierEXT, pNext));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkShaderModuleIdentifierEXT_identifierSize_offsetof"] = Napi::Number::New(env, offsetof(VkShaderModuleIdentifierEXT, identifierSize));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkShaderModuleIdentifierEXT_identifier_offsetof"] = Napi::Number::New(env, offsetof(VkShaderModuleIdentifierEXT, identifier));
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["VkShaderModuleIdentifierEXT_sizeof"] = Napi::Number::New(env, sizeof(VkShaderModuleIdentifierEXT));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkImageCompressionControlEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageCompressionControlEXT, sType));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkImageCompressionControlEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageCompressionControlEXT, pNext));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkImageCompressionControlEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkImageCompressionControlEXT, flags));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkImageCompressionControlEXT_compressionControlPlaneCount_offsetof"] = Napi::Number::New(env, offsetof(VkImageCompressionControlEXT, compressionControlPlaneCount));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkImageCompressionControlEXT_pFixedRateFlags_offsetof"] = Napi::Number::New(env, offsetof(VkImageCompressionControlEXT, pFixedRateFlags));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkImageCompressionControlEXT_sizeof"] = Napi::Number::New(env, sizeof(VkImageCompressionControlEXT));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkPhysicalDeviceImageCompressionControlFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageCompressionControlFeaturesEXT, sType));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkPhysicalDeviceImageCompressionControlFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageCompressionControlFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkPhysicalDeviceImageCompressionControlFeaturesEXT_imageCompressionControl_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageCompressionControlFeaturesEXT, imageCompressionControl));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkPhysicalDeviceImageCompressionControlFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceImageCompressionControlFeaturesEXT));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkImageCompressionPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageCompressionPropertiesEXT, sType));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkImageCompressionPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageCompressionPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkImageCompressionPropertiesEXT_imageCompressionFlags_offsetof"] = Napi::Number::New(env, offsetof(VkImageCompressionPropertiesEXT, imageCompressionFlags));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkImageCompressionPropertiesEXT_imageCompressionFixedRateFlags_offsetof"] = Napi::Number::New(env, offsetof(VkImageCompressionPropertiesEXT, imageCompressionFixedRateFlags));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkImageCompressionPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkImageCompressionPropertiesEXT));
#endif
#ifdef VK_EXT_image_compression_control_swapchain
    exports["VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT, sType));
#endif
#ifdef VK_EXT_image_compression_control_swapchain
    exports["VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_image_compression_control_swapchain
    exports["VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT_imageCompressionControlSwapchain_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT, imageCompressionControlSwapchain));
#endif
#ifdef VK_EXT_image_compression_control_swapchain
    exports["VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkImageSubresource2EXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageSubresource2EXT, sType));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkImageSubresource2EXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageSubresource2EXT, pNext));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkImageSubresource2EXT_imageSubresource_offsetof"] = Napi::Number::New(env, offsetof(VkImageSubresource2EXT, imageSubresource));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkImageSubresource2EXT_sizeof"] = Napi::Number::New(env, sizeof(VkImageSubresource2EXT));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkSubresourceLayout2EXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkSubresourceLayout2EXT, sType));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkSubresourceLayout2EXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkSubresourceLayout2EXT, pNext));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkSubresourceLayout2EXT_subresourceLayout_offsetof"] = Napi::Number::New(env, offsetof(VkSubresourceLayout2EXT, subresourceLayout));
#endif
#ifdef VK_EXT_image_compression_control
    exports["VkSubresourceLayout2EXT_sizeof"] = Napi::Number::New(env, sizeof(VkSubresourceLayout2EXT));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassCreationControlEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreationControlEXT, sType));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassCreationControlEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreationControlEXT, pNext));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassCreationControlEXT_disallowMerging_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreationControlEXT, disallowMerging));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassCreationControlEXT_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassCreationControlEXT));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassCreationFeedbackInfoEXT_postMergeSubpassCount_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreationFeedbackInfoEXT, postMergeSubpassCount));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassCreationFeedbackInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassCreationFeedbackInfoEXT));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassCreationFeedbackCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreationFeedbackCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassCreationFeedbackCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreationFeedbackCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassCreationFeedbackCreateInfoEXT_pRenderPassFeedback_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassCreationFeedbackCreateInfoEXT, pRenderPassFeedback));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassCreationFeedbackCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassCreationFeedbackCreateInfoEXT));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassSubpassFeedbackInfoEXT_subpassMergeStatus_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassSubpassFeedbackInfoEXT, subpassMergeStatus));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassSubpassFeedbackInfoEXT_description_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassSubpassFeedbackInfoEXT, description));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassSubpassFeedbackInfoEXT_postMergeIndex_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassSubpassFeedbackInfoEXT, postMergeIndex));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassSubpassFeedbackInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassSubpassFeedbackInfoEXT));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassSubpassFeedbackCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassSubpassFeedbackCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassSubpassFeedbackCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassSubpassFeedbackCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassSubpassFeedbackCreateInfoEXT_pSubpassFeedback_offsetof"] = Napi::Number::New(env, offsetof(VkRenderPassSubpassFeedbackCreateInfoEXT, pSubpassFeedback));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkRenderPassSubpassFeedbackCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkRenderPassSubpassFeedbackCreateInfoEXT));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT, sType));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT_subpassMergeFeedback_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT, subpassMergeFeedback));
#endif
#ifdef VK_EXT_subpass_merge_feedback
    exports["VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildInfoEXT, sType));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildInfoEXT, pNext));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildInfoEXT_type_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildInfoEXT, type));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildInfoEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildInfoEXT, flags));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildInfoEXT_mode_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildInfoEXT, mode));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildInfoEXT_dstMicromap_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildInfoEXT, dstMicromap));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildInfoEXT_usageCountsCount_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildInfoEXT, usageCountsCount));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildInfoEXT_pUsageCounts_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildInfoEXT, pUsageCounts));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildInfoEXT_ppUsageCounts_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildInfoEXT, ppUsageCounts));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildInfoEXT_data_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildInfoEXT, data));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildInfoEXT_scratchData_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildInfoEXT, scratchData));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildInfoEXT_triangleArray_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildInfoEXT, triangleArray));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildInfoEXT_triangleArrayStride_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildInfoEXT, triangleArrayStride));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkMicromapBuildInfoEXT));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapCreateInfoEXT_createFlags_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapCreateInfoEXT, createFlags));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapCreateInfoEXT_buffer_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapCreateInfoEXT, buffer));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapCreateInfoEXT_offset_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapCreateInfoEXT, offset));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapCreateInfoEXT_size_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapCreateInfoEXT, size));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapCreateInfoEXT_type_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapCreateInfoEXT, type));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapCreateInfoEXT_deviceAddress_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapCreateInfoEXT, deviceAddress));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkMicromapCreateInfoEXT));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapVersionInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapVersionInfoEXT, sType));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapVersionInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapVersionInfoEXT, pNext));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapVersionInfoEXT_pVersionData_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapVersionInfoEXT, pVersionData));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapVersionInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkMicromapVersionInfoEXT));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMicromapInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMicromapInfoEXT, sType));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMicromapInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMicromapInfoEXT, pNext));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMicromapInfoEXT_src_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMicromapInfoEXT, src));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMicromapInfoEXT_dst_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMicromapInfoEXT, dst));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMicromapInfoEXT_mode_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMicromapInfoEXT, mode));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMicromapInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkCopyMicromapInfoEXT));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMicromapToMemoryInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMicromapToMemoryInfoEXT, sType));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMicromapToMemoryInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMicromapToMemoryInfoEXT, pNext));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMicromapToMemoryInfoEXT_src_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMicromapToMemoryInfoEXT, src));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMicromapToMemoryInfoEXT_dst_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMicromapToMemoryInfoEXT, dst));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMicromapToMemoryInfoEXT_mode_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMicromapToMemoryInfoEXT, mode));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMicromapToMemoryInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkCopyMicromapToMemoryInfoEXT));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMemoryToMicromapInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryToMicromapInfoEXT, sType));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMemoryToMicromapInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryToMicromapInfoEXT, pNext));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMemoryToMicromapInfoEXT_src_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryToMicromapInfoEXT, src));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMemoryToMicromapInfoEXT_dst_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryToMicromapInfoEXT, dst));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMemoryToMicromapInfoEXT_mode_offsetof"] = Napi::Number::New(env, offsetof(VkCopyMemoryToMicromapInfoEXT, mode));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkCopyMemoryToMicromapInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkCopyMemoryToMicromapInfoEXT));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildSizesInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildSizesInfoEXT, sType));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildSizesInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildSizesInfoEXT, pNext));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildSizesInfoEXT_micromapSize_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildSizesInfoEXT, micromapSize));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildSizesInfoEXT_buildScratchSize_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildSizesInfoEXT, buildScratchSize));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildSizesInfoEXT_discardable_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapBuildSizesInfoEXT, discardable));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapBuildSizesInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkMicromapBuildSizesInfoEXT));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapUsageEXT_count_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapUsageEXT, count));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapUsageEXT_subdivisionLevel_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapUsageEXT, subdivisionLevel));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapUsageEXT_format_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapUsageEXT, format));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapUsageEXT_sizeof"] = Napi::Number::New(env, sizeof(VkMicromapUsageEXT));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapTriangleEXT_dataOffset_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapTriangleEXT, dataOffset));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapTriangleEXT_subdivisionLevel_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapTriangleEXT, subdivisionLevel));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapTriangleEXT_format_offsetof"] = Napi::Number::New(env, offsetof(VkMicromapTriangleEXT, format));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkMicromapTriangleEXT_sizeof"] = Napi::Number::New(env, sizeof(VkMicromapTriangleEXT));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkPhysicalDeviceOpacityMicromapFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpacityMicromapFeaturesEXT, sType));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkPhysicalDeviceOpacityMicromapFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpacityMicromapFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkPhysicalDeviceOpacityMicromapFeaturesEXT_micromap_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpacityMicromapFeaturesEXT, micromap));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkPhysicalDeviceOpacityMicromapFeaturesEXT_micromapCaptureReplay_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpacityMicromapFeaturesEXT, micromapCaptureReplay));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkPhysicalDeviceOpacityMicromapFeaturesEXT_micromapHostCommands_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpacityMicromapFeaturesEXT, micromapHostCommands));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkPhysicalDeviceOpacityMicromapFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceOpacityMicromapFeaturesEXT));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkPhysicalDeviceOpacityMicromapPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpacityMicromapPropertiesEXT, sType));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkPhysicalDeviceOpacityMicromapPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpacityMicromapPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkPhysicalDeviceOpacityMicromapPropertiesEXT_maxOpacity2StateSubdivisionLevel_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpacityMicromapPropertiesEXT, maxOpacity2StateSubdivisionLevel));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkPhysicalDeviceOpacityMicromapPropertiesEXT_maxOpacity4StateSubdivisionLevel_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpacityMicromapPropertiesEXT, maxOpacity4StateSubdivisionLevel));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkPhysicalDeviceOpacityMicromapPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceOpacityMicromapPropertiesEXT));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkAccelerationStructureTrianglesOpacityMicromapEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureTrianglesOpacityMicromapEXT, sType));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkAccelerationStructureTrianglesOpacityMicromapEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureTrianglesOpacityMicromapEXT, pNext));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkAccelerationStructureTrianglesOpacityMicromapEXT_indexType_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureTrianglesOpacityMicromapEXT, indexType));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkAccelerationStructureTrianglesOpacityMicromapEXT_indexBuffer_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureTrianglesOpacityMicromapEXT, indexBuffer));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkAccelerationStructureTrianglesOpacityMicromapEXT_indexStride_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureTrianglesOpacityMicromapEXT, indexStride));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkAccelerationStructureTrianglesOpacityMicromapEXT_baseTriangle_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureTrianglesOpacityMicromapEXT, baseTriangle));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkAccelerationStructureTrianglesOpacityMicromapEXT_usageCountsCount_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureTrianglesOpacityMicromapEXT, usageCountsCount));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkAccelerationStructureTrianglesOpacityMicromapEXT_pUsageCounts_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureTrianglesOpacityMicromapEXT, pUsageCounts));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkAccelerationStructureTrianglesOpacityMicromapEXT_ppUsageCounts_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureTrianglesOpacityMicromapEXT, ppUsageCounts));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkAccelerationStructureTrianglesOpacityMicromapEXT_micromap_offsetof"] = Napi::Number::New(env, offsetof(VkAccelerationStructureTrianglesOpacityMicromapEXT, micromap));
#endif
#ifdef VK_EXT_opacity_micromap
    exports["VkAccelerationStructureTrianglesOpacityMicromapEXT_sizeof"] = Napi::Number::New(env, sizeof(VkAccelerationStructureTrianglesOpacityMicromapEXT));
#endif
#ifdef VK_EXT_pipeline_properties
    exports["VkPipelinePropertiesIdentifierEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelinePropertiesIdentifierEXT, sType));
#endif
#ifdef VK_EXT_pipeline_properties
    exports["VkPipelinePropertiesIdentifierEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelinePropertiesIdentifierEXT, pNext));
#endif
#ifdef VK_EXT_pipeline_properties
    exports["VkPipelinePropertiesIdentifierEXT_pipelineIdentifier_offsetof"] = Napi::Number::New(env, offsetof(VkPipelinePropertiesIdentifierEXT, pipelineIdentifier));
#endif
#ifdef VK_EXT_pipeline_properties
    exports["VkPipelinePropertiesIdentifierEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelinePropertiesIdentifierEXT));
#endif
#ifdef VK_EXT_pipeline_properties
    exports["VkPhysicalDevicePipelinePropertiesFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelinePropertiesFeaturesEXT, sType));
#endif
#ifdef VK_EXT_pipeline_properties
    exports["VkPhysicalDevicePipelinePropertiesFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelinePropertiesFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_pipeline_properties
    exports["VkPhysicalDevicePipelinePropertiesFeaturesEXT_pipelinePropertiesIdentifier_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelinePropertiesFeaturesEXT, pipelinePropertiesIdentifier));
#endif
#ifdef VK_EXT_pipeline_properties
    exports["VkPhysicalDevicePipelinePropertiesFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePipelinePropertiesFeaturesEXT));
#endif
#ifdef VK_AMD_shader_early_and_late_fragment_tests
    exports["VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD, sType));
#endif
#ifdef VK_AMD_shader_early_and_late_fragment_tests
    exports["VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD, pNext));
#endif
#ifdef VK_AMD_shader_early_and_late_fragment_tests
    exports["VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD_shaderEarlyAndLateFragmentTests_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD, shaderEarlyAndLateFragmentTests));
#endif
#ifdef VK_AMD_shader_early_and_late_fragment_tests
    exports["VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalObjectCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalObjectCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalObjectCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalObjectCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalObjectCreateInfoEXT_exportObjectType_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalObjectCreateInfoEXT, exportObjectType));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalObjectCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkExportMetalObjectCreateInfoEXT));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalObjectsInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalObjectsInfoEXT, sType));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalObjectsInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalObjectsInfoEXT, pNext));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalObjectsInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkExportMetalObjectsInfoEXT));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalDeviceInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalDeviceInfoEXT, sType));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalDeviceInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalDeviceInfoEXT, pNext));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalDeviceInfoEXT_mtlDevice_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalDeviceInfoEXT, mtlDevice));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalDeviceInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkExportMetalDeviceInfoEXT));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalCommandQueueInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalCommandQueueInfoEXT, sType));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalCommandQueueInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalCommandQueueInfoEXT, pNext));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalCommandQueueInfoEXT_queue_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalCommandQueueInfoEXT, queue));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalCommandQueueInfoEXT_mtlCommandQueue_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalCommandQueueInfoEXT, mtlCommandQueue));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalCommandQueueInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkExportMetalCommandQueueInfoEXT));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalBufferInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalBufferInfoEXT, sType));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalBufferInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalBufferInfoEXT, pNext));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalBufferInfoEXT_memory_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalBufferInfoEXT, memory));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalBufferInfoEXT_mtlBuffer_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalBufferInfoEXT, mtlBuffer));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalBufferInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkExportMetalBufferInfoEXT));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkImportMetalBufferInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImportMetalBufferInfoEXT, sType));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkImportMetalBufferInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImportMetalBufferInfoEXT, pNext));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkImportMetalBufferInfoEXT_mtlBuffer_offsetof"] = Napi::Number::New(env, offsetof(VkImportMetalBufferInfoEXT, mtlBuffer));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkImportMetalBufferInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkImportMetalBufferInfoEXT));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalTextureInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalTextureInfoEXT, sType));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalTextureInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalTextureInfoEXT, pNext));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalTextureInfoEXT_image_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalTextureInfoEXT, image));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalTextureInfoEXT_imageView_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalTextureInfoEXT, imageView));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalTextureInfoEXT_bufferView_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalTextureInfoEXT, bufferView));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalTextureInfoEXT_plane_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalTextureInfoEXT, plane));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalTextureInfoEXT_mtlTexture_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalTextureInfoEXT, mtlTexture));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalTextureInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkExportMetalTextureInfoEXT));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkImportMetalTextureInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImportMetalTextureInfoEXT, sType));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkImportMetalTextureInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImportMetalTextureInfoEXT, pNext));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkImportMetalTextureInfoEXT_plane_offsetof"] = Napi::Number::New(env, offsetof(VkImportMetalTextureInfoEXT, plane));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkImportMetalTextureInfoEXT_mtlTexture_offsetof"] = Napi::Number::New(env, offsetof(VkImportMetalTextureInfoEXT, mtlTexture));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkImportMetalTextureInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkImportMetalTextureInfoEXT));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalIOSurfaceInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalIOSurfaceInfoEXT, sType));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalIOSurfaceInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalIOSurfaceInfoEXT, pNext));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalIOSurfaceInfoEXT_image_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalIOSurfaceInfoEXT, image));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalIOSurfaceInfoEXT_ioSurface_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalIOSurfaceInfoEXT, ioSurface));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalIOSurfaceInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkExportMetalIOSurfaceInfoEXT));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkImportMetalIOSurfaceInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImportMetalIOSurfaceInfoEXT, sType));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkImportMetalIOSurfaceInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImportMetalIOSurfaceInfoEXT, pNext));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkImportMetalIOSurfaceInfoEXT_ioSurface_offsetof"] = Napi::Number::New(env, offsetof(VkImportMetalIOSurfaceInfoEXT, ioSurface));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkImportMetalIOSurfaceInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkImportMetalIOSurfaceInfoEXT));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalSharedEventInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalSharedEventInfoEXT, sType));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalSharedEventInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalSharedEventInfoEXT, pNext));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalSharedEventInfoEXT_semaphore_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalSharedEventInfoEXT, semaphore));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalSharedEventInfoEXT_event_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalSharedEventInfoEXT, event));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalSharedEventInfoEXT_mtlSharedEvent_offsetof"] = Napi::Number::New(env, offsetof(VkExportMetalSharedEventInfoEXT, mtlSharedEvent));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkExportMetalSharedEventInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkExportMetalSharedEventInfoEXT));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkImportMetalSharedEventInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImportMetalSharedEventInfoEXT, sType));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkImportMetalSharedEventInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImportMetalSharedEventInfoEXT, pNext));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkImportMetalSharedEventInfoEXT_mtlSharedEvent_offsetof"] = Napi::Number::New(env, offsetof(VkImportMetalSharedEventInfoEXT, mtlSharedEvent));
#endif
#ifdef VK_EXT_metal_objects
    exports["VkImportMetalSharedEventInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkImportMetalSharedEventInfoEXT));
#endif
#ifdef VK_EXT_non_seamless_cube_map
    exports["VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT, sType));
#endif
#ifdef VK_EXT_non_seamless_cube_map
    exports["VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_non_seamless_cube_map
    exports["VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT_nonSeamlessCubeMap_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT, nonSeamlessCubeMap));
#endif
#ifdef VK_EXT_non_seamless_cube_map
    exports["VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPhysicalDevicePipelineRobustnessFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineRobustnessFeaturesEXT, sType));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPhysicalDevicePipelineRobustnessFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineRobustnessFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPhysicalDevicePipelineRobustnessFeaturesEXT_pipelineRobustness_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineRobustnessFeaturesEXT, pipelineRobustness));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPhysicalDevicePipelineRobustnessFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePipelineRobustnessFeaturesEXT));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPipelineRobustnessCreateInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRobustnessCreateInfoEXT, sType));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPipelineRobustnessCreateInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRobustnessCreateInfoEXT, pNext));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPipelineRobustnessCreateInfoEXT_storageBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRobustnessCreateInfoEXT, storageBuffers));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPipelineRobustnessCreateInfoEXT_uniformBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRobustnessCreateInfoEXT, uniformBuffers));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPipelineRobustnessCreateInfoEXT_vertexInputs_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRobustnessCreateInfoEXT, vertexInputs));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPipelineRobustnessCreateInfoEXT_images_offsetof"] = Napi::Number::New(env, offsetof(VkPipelineRobustnessCreateInfoEXT, images));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPipelineRobustnessCreateInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPipelineRobustnessCreateInfoEXT));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPhysicalDevicePipelineRobustnessPropertiesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineRobustnessPropertiesEXT, sType));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPhysicalDevicePipelineRobustnessPropertiesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineRobustnessPropertiesEXT, pNext));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPhysicalDevicePipelineRobustnessPropertiesEXT_defaultRobustnessStorageBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineRobustnessPropertiesEXT, defaultRobustnessStorageBuffers));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPhysicalDevicePipelineRobustnessPropertiesEXT_defaultRobustnessUniformBuffers_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineRobustnessPropertiesEXT, defaultRobustnessUniformBuffers));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPhysicalDevicePipelineRobustnessPropertiesEXT_defaultRobustnessVertexInputs_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineRobustnessPropertiesEXT, defaultRobustnessVertexInputs));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPhysicalDevicePipelineRobustnessPropertiesEXT_defaultRobustnessImages_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDevicePipelineRobustnessPropertiesEXT, defaultRobustnessImages));
#endif
#ifdef VK_EXT_pipeline_robustness
    exports["VkPhysicalDevicePipelineRobustnessPropertiesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDevicePipelineRobustnessPropertiesEXT));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkImageViewSampleWeightCreateInfoQCOM_sType_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewSampleWeightCreateInfoQCOM, sType));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkImageViewSampleWeightCreateInfoQCOM_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewSampleWeightCreateInfoQCOM, pNext));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkImageViewSampleWeightCreateInfoQCOM_filterCenter_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewSampleWeightCreateInfoQCOM, filterCenter));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkImageViewSampleWeightCreateInfoQCOM_filterSize_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewSampleWeightCreateInfoQCOM, filterSize));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkImageViewSampleWeightCreateInfoQCOM_numPhases_offsetof"] = Napi::Number::New(env, offsetof(VkImageViewSampleWeightCreateInfoQCOM, numPhases));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkImageViewSampleWeightCreateInfoQCOM_sizeof"] = Napi::Number::New(env, sizeof(VkImageViewSampleWeightCreateInfoQCOM));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkPhysicalDeviceImageProcessingFeaturesQCOM_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageProcessingFeaturesQCOM, sType));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkPhysicalDeviceImageProcessingFeaturesQCOM_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageProcessingFeaturesQCOM, pNext));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkPhysicalDeviceImageProcessingFeaturesQCOM_textureSampleWeighted_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageProcessingFeaturesQCOM, textureSampleWeighted));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkPhysicalDeviceImageProcessingFeaturesQCOM_textureBoxFilter_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageProcessingFeaturesQCOM, textureBoxFilter));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkPhysicalDeviceImageProcessingFeaturesQCOM_textureBlockMatch_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageProcessingFeaturesQCOM, textureBlockMatch));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkPhysicalDeviceImageProcessingFeaturesQCOM_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceImageProcessingFeaturesQCOM));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkPhysicalDeviceImageProcessingPropertiesQCOM_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageProcessingPropertiesQCOM, sType));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkPhysicalDeviceImageProcessingPropertiesQCOM_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageProcessingPropertiesQCOM, pNext));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkPhysicalDeviceImageProcessingPropertiesQCOM_maxWeightFilterPhases_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageProcessingPropertiesQCOM, maxWeightFilterPhases));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkPhysicalDeviceImageProcessingPropertiesQCOM_maxWeightFilterDimension_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageProcessingPropertiesQCOM, maxWeightFilterDimension));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkPhysicalDeviceImageProcessingPropertiesQCOM_maxBlockMatchRegion_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageProcessingPropertiesQCOM, maxBlockMatchRegion));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkPhysicalDeviceImageProcessingPropertiesQCOM_maxBoxFilterBlockSize_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceImageProcessingPropertiesQCOM, maxBoxFilterBlockSize));
#endif
#ifdef VK_QCOM_image_processing
    exports["VkPhysicalDeviceImageProcessingPropertiesQCOM_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceImageProcessingPropertiesQCOM));
#endif
#ifdef VK_QCOM_tile_properties
    exports["VkPhysicalDeviceTilePropertiesFeaturesQCOM_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTilePropertiesFeaturesQCOM, sType));
#endif
#ifdef VK_QCOM_tile_properties
    exports["VkPhysicalDeviceTilePropertiesFeaturesQCOM_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTilePropertiesFeaturesQCOM, pNext));
#endif
#ifdef VK_QCOM_tile_properties
    exports["VkPhysicalDeviceTilePropertiesFeaturesQCOM_tileProperties_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceTilePropertiesFeaturesQCOM, tileProperties));
#endif
#ifdef VK_QCOM_tile_properties
    exports["VkPhysicalDeviceTilePropertiesFeaturesQCOM_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceTilePropertiesFeaturesQCOM));
#endif
#ifdef VK_QCOM_tile_properties
    exports["VkTilePropertiesQCOM_sType_offsetof"] = Napi::Number::New(env, offsetof(VkTilePropertiesQCOM, sType));
#endif
#ifdef VK_QCOM_tile_properties
    exports["VkTilePropertiesQCOM_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkTilePropertiesQCOM, pNext));
#endif
#ifdef VK_QCOM_tile_properties
    exports["VkTilePropertiesQCOM_tileSize_offsetof"] = Napi::Number::New(env, offsetof(VkTilePropertiesQCOM, tileSize));
#endif
#ifdef VK_QCOM_tile_properties
    exports["VkTilePropertiesQCOM_apronSize_offsetof"] = Napi::Number::New(env, offsetof(VkTilePropertiesQCOM, apronSize));
#endif
#ifdef VK_QCOM_tile_properties
    exports["VkTilePropertiesQCOM_origin_offsetof"] = Napi::Number::New(env, offsetof(VkTilePropertiesQCOM, origin));
#endif
#ifdef VK_QCOM_tile_properties
    exports["VkTilePropertiesQCOM_sizeof"] = Napi::Number::New(env, sizeof(VkTilePropertiesQCOM));
#endif
#ifdef VK_SEC_amigo_profiling
    exports["VkPhysicalDeviceAmigoProfilingFeaturesSEC_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAmigoProfilingFeaturesSEC, sType));
#endif
#ifdef VK_SEC_amigo_profiling
    exports["VkPhysicalDeviceAmigoProfilingFeaturesSEC_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAmigoProfilingFeaturesSEC, pNext));
#endif
#ifdef VK_SEC_amigo_profiling
    exports["VkPhysicalDeviceAmigoProfilingFeaturesSEC_amigoProfiling_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAmigoProfilingFeaturesSEC, amigoProfiling));
#endif
#ifdef VK_SEC_amigo_profiling
    exports["VkPhysicalDeviceAmigoProfilingFeaturesSEC_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceAmigoProfilingFeaturesSEC));
#endif
#ifdef VK_SEC_amigo_profiling
    exports["VkAmigoProfilingSubmitInfoSEC_sType_offsetof"] = Napi::Number::New(env, offsetof(VkAmigoProfilingSubmitInfoSEC, sType));
#endif
#ifdef VK_SEC_amigo_profiling
    exports["VkAmigoProfilingSubmitInfoSEC_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkAmigoProfilingSubmitInfoSEC, pNext));
#endif
#ifdef VK_SEC_amigo_profiling
    exports["VkAmigoProfilingSubmitInfoSEC_firstDrawTimestamp_offsetof"] = Napi::Number::New(env, offsetof(VkAmigoProfilingSubmitInfoSEC, firstDrawTimestamp));
#endif
#ifdef VK_SEC_amigo_profiling
    exports["VkAmigoProfilingSubmitInfoSEC_swapBufferTimestamp_offsetof"] = Napi::Number::New(env, offsetof(VkAmigoProfilingSubmitInfoSEC, swapBufferTimestamp));
#endif
#ifdef VK_SEC_amigo_profiling
    exports["VkAmigoProfilingSubmitInfoSEC_sizeof"] = Napi::Number::New(env, sizeof(VkAmigoProfilingSubmitInfoSEC));
#endif
#ifdef VK_EXT_attachment_feedback_loop_layout
    exports["VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT, sType));
#endif
#ifdef VK_EXT_attachment_feedback_loop_layout
    exports["VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_attachment_feedback_loop_layout
    exports["VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT_attachmentFeedbackLoopLayout_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT, attachmentFeedbackLoopLayout));
#endif
#ifdef VK_EXT_attachment_feedback_loop_layout
    exports["VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT));
#endif
#ifdef VK_EXT_depth_clamp_zero_one
    exports["VkPhysicalDeviceDepthClampZeroOneFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDepthClampZeroOneFeaturesEXT, sType));
#endif
#ifdef VK_EXT_depth_clamp_zero_one
    exports["VkPhysicalDeviceDepthClampZeroOneFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDepthClampZeroOneFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_depth_clamp_zero_one
    exports["VkPhysicalDeviceDepthClampZeroOneFeaturesEXT_depthClampZeroOne_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceDepthClampZeroOneFeaturesEXT, depthClampZeroOne));
#endif
#ifdef VK_EXT_depth_clamp_zero_one
    exports["VkPhysicalDeviceDepthClampZeroOneFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceDepthClampZeroOneFeaturesEXT));
#endif
#ifdef VK_EXT_device_address_binding_report
    exports["VkPhysicalDeviceAddressBindingReportFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAddressBindingReportFeaturesEXT, sType));
#endif
#ifdef VK_EXT_device_address_binding_report
    exports["VkPhysicalDeviceAddressBindingReportFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAddressBindingReportFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_device_address_binding_report
    exports["VkPhysicalDeviceAddressBindingReportFeaturesEXT_reportAddressBinding_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceAddressBindingReportFeaturesEXT, reportAddressBinding));
#endif
#ifdef VK_EXT_device_address_binding_report
    exports["VkPhysicalDeviceAddressBindingReportFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceAddressBindingReportFeaturesEXT));
#endif
#ifdef VK_EXT_device_address_binding_report
    exports["VkDeviceAddressBindingCallbackDataEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceAddressBindingCallbackDataEXT, sType));
#endif
#ifdef VK_EXT_device_address_binding_report
    exports["VkDeviceAddressBindingCallbackDataEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceAddressBindingCallbackDataEXT, pNext));
#endif
#ifdef VK_EXT_device_address_binding_report
    exports["VkDeviceAddressBindingCallbackDataEXT_flags_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceAddressBindingCallbackDataEXT, flags));
#endif
#ifdef VK_EXT_device_address_binding_report
    exports["VkDeviceAddressBindingCallbackDataEXT_baseAddress_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceAddressBindingCallbackDataEXT, baseAddress));
#endif
#ifdef VK_EXT_device_address_binding_report
    exports["VkDeviceAddressBindingCallbackDataEXT_size_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceAddressBindingCallbackDataEXT, size));
#endif
#ifdef VK_EXT_device_address_binding_report
    exports["VkDeviceAddressBindingCallbackDataEXT_bindingType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceAddressBindingCallbackDataEXT, bindingType));
#endif
#ifdef VK_EXT_device_address_binding_report
    exports["VkDeviceAddressBindingCallbackDataEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceAddressBindingCallbackDataEXT));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpticalFlowFeaturesNV, sType));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpticalFlowFeaturesNV, pNext));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowFeaturesNV_opticalFlow_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpticalFlowFeaturesNV, opticalFlow));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceOpticalFlowFeaturesNV));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowPropertiesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpticalFlowPropertiesNV, sType));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowPropertiesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpticalFlowPropertiesNV, pNext));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowPropertiesNV_supportedOutputGridSizes_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpticalFlowPropertiesNV, supportedOutputGridSizes));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowPropertiesNV_supportedHintGridSizes_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpticalFlowPropertiesNV, supportedHintGridSizes));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowPropertiesNV_hintSupported_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpticalFlowPropertiesNV, hintSupported));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowPropertiesNV_costSupported_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpticalFlowPropertiesNV, costSupported));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowPropertiesNV_bidirectionalFlowSupported_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpticalFlowPropertiesNV, bidirectionalFlowSupported));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowPropertiesNV_globalFlowSupported_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpticalFlowPropertiesNV, globalFlowSupported));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowPropertiesNV_minWidth_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpticalFlowPropertiesNV, minWidth));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowPropertiesNV_minHeight_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpticalFlowPropertiesNV, minHeight));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowPropertiesNV_maxWidth_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpticalFlowPropertiesNV, maxWidth));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowPropertiesNV_maxHeight_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpticalFlowPropertiesNV, maxHeight));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowPropertiesNV_maxNumRegionsOfInterest_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceOpticalFlowPropertiesNV, maxNumRegionsOfInterest));
#endif
#ifdef VK_NV_optical_flow
    exports["VkPhysicalDeviceOpticalFlowPropertiesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceOpticalFlowPropertiesNV));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowImageFormatInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowImageFormatInfoNV, sType));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowImageFormatInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowImageFormatInfoNV, pNext));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowImageFormatInfoNV_usage_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowImageFormatInfoNV, usage));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowImageFormatInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkOpticalFlowImageFormatInfoNV));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowImageFormatPropertiesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowImageFormatPropertiesNV, sType));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowImageFormatPropertiesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowImageFormatPropertiesNV, pNext));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowImageFormatPropertiesNV_format_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowImageFormatPropertiesNV, format));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowImageFormatPropertiesNV_sizeof"] = Napi::Number::New(env, sizeof(VkOpticalFlowImageFormatPropertiesNV));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreateInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowSessionCreateInfoNV, sType));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreateInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowSessionCreateInfoNV, pNext));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreateInfoNV_width_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowSessionCreateInfoNV, width));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreateInfoNV_height_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowSessionCreateInfoNV, height));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreateInfoNV_imageFormat_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowSessionCreateInfoNV, imageFormat));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreateInfoNV_flowVectorFormat_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowSessionCreateInfoNV, flowVectorFormat));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreateInfoNV_costFormat_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowSessionCreateInfoNV, costFormat));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreateInfoNV_outputGridSize_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowSessionCreateInfoNV, outputGridSize));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreateInfoNV_hintGridSize_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowSessionCreateInfoNV, hintGridSize));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreateInfoNV_performanceLevel_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowSessionCreateInfoNV, performanceLevel));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreateInfoNV_flags_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowSessionCreateInfoNV, flags));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreateInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkOpticalFlowSessionCreateInfoNV));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreatePrivateDataInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowSessionCreatePrivateDataInfoNV, sType));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreatePrivateDataInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowSessionCreatePrivateDataInfoNV, pNext));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreatePrivateDataInfoNV_id_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowSessionCreatePrivateDataInfoNV, id));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreatePrivateDataInfoNV_size_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowSessionCreatePrivateDataInfoNV, size));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreatePrivateDataInfoNV_pPrivateData_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowSessionCreatePrivateDataInfoNV, pPrivateData));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowSessionCreatePrivateDataInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkOpticalFlowSessionCreatePrivateDataInfoNV));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowExecuteInfoNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowExecuteInfoNV, sType));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowExecuteInfoNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowExecuteInfoNV, pNext));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowExecuteInfoNV_flags_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowExecuteInfoNV, flags));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowExecuteInfoNV_regionCount_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowExecuteInfoNV, regionCount));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowExecuteInfoNV_pRegions_offsetof"] = Napi::Number::New(env, offsetof(VkOpticalFlowExecuteInfoNV, pRegions));
#endif
#ifdef VK_NV_optical_flow
    exports["VkOpticalFlowExecuteInfoNV_sizeof"] = Napi::Number::New(env, sizeof(VkOpticalFlowExecuteInfoNV));
#endif
#ifdef VK_EXT_device_fault
    exports["VkPhysicalDeviceFaultFeaturesEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFaultFeaturesEXT, sType));
#endif
#ifdef VK_EXT_device_fault
    exports["VkPhysicalDeviceFaultFeaturesEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFaultFeaturesEXT, pNext));
#endif
#ifdef VK_EXT_device_fault
    exports["VkPhysicalDeviceFaultFeaturesEXT_deviceFault_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFaultFeaturesEXT, deviceFault));
#endif
#ifdef VK_EXT_device_fault
    exports["VkPhysicalDeviceFaultFeaturesEXT_deviceFaultVendorBinary_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceFaultFeaturesEXT, deviceFaultVendorBinary));
#endif
#ifdef VK_EXT_device_fault
    exports["VkPhysicalDeviceFaultFeaturesEXT_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceFaultFeaturesEXT));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultAddressInfoEXT_addressType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultAddressInfoEXT, addressType));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultAddressInfoEXT_reportedAddress_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultAddressInfoEXT, reportedAddress));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultAddressInfoEXT_addressPrecision_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultAddressInfoEXT, addressPrecision));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultAddressInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceFaultAddressInfoEXT));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultVendorInfoEXT_description_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultVendorInfoEXT, description));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultVendorInfoEXT_vendorFaultCode_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultVendorInfoEXT, vendorFaultCode));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultVendorInfoEXT_vendorFaultData_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultVendorInfoEXT, vendorFaultData));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultVendorInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceFaultVendorInfoEXT));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultCountsEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultCountsEXT, sType));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultCountsEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultCountsEXT, pNext));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultCountsEXT_addressInfoCount_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultCountsEXT, addressInfoCount));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultCountsEXT_vendorInfoCount_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultCountsEXT, vendorInfoCount));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultCountsEXT_vendorBinarySize_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultCountsEXT, vendorBinarySize));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultCountsEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceFaultCountsEXT));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultInfoEXT_sType_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultInfoEXT, sType));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultInfoEXT_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultInfoEXT, pNext));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultInfoEXT_description_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultInfoEXT, description));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultInfoEXT_pAddressInfos_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultInfoEXT, pAddressInfos));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultInfoEXT_pVendorInfos_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultInfoEXT, pVendorInfos));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultInfoEXT_pVendorBinaryData_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultInfoEXT, pVendorBinaryData));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultInfoEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceFaultInfoEXT));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultVendorBinaryHeaderVersionOneEXT_headerSize_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultVendorBinaryHeaderVersionOneEXT, headerSize));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultVendorBinaryHeaderVersionOneEXT_headerVersion_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultVendorBinaryHeaderVersionOneEXT, headerVersion));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultVendorBinaryHeaderVersionOneEXT_vendorID_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultVendorBinaryHeaderVersionOneEXT, vendorID));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultVendorBinaryHeaderVersionOneEXT_deviceID_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultVendorBinaryHeaderVersionOneEXT, deviceID));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultVendorBinaryHeaderVersionOneEXT_driverVersion_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultVendorBinaryHeaderVersionOneEXT, driverVersion));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultVendorBinaryHeaderVersionOneEXT_pipelineCacheUUID_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultVendorBinaryHeaderVersionOneEXT, pipelineCacheUUID));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultVendorBinaryHeaderVersionOneEXT_applicationNameOffset_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultVendorBinaryHeaderVersionOneEXT, applicationNameOffset));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultVendorBinaryHeaderVersionOneEXT_applicationVersion_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultVendorBinaryHeaderVersionOneEXT, applicationVersion));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultVendorBinaryHeaderVersionOneEXT_engineNameOffset_offsetof"] = Napi::Number::New(env, offsetof(VkDeviceFaultVendorBinaryHeaderVersionOneEXT, engineNameOffset));
#endif
#ifdef VK_EXT_device_fault
    exports["VkDeviceFaultVendorBinaryHeaderVersionOneEXT_sizeof"] = Napi::Number::New(env, sizeof(VkDeviceFaultVendorBinaryHeaderVersionOneEXT));
#endif
#ifdef VK_NV_memory_decompression
    exports["VkDecompressMemoryRegionNV_srcAddress_offsetof"] = Napi::Number::New(env, offsetof(VkDecompressMemoryRegionNV, srcAddress));
#endif
#ifdef VK_NV_memory_decompression
    exports["VkDecompressMemoryRegionNV_dstAddress_offsetof"] = Napi::Number::New(env, offsetof(VkDecompressMemoryRegionNV, dstAddress));
#endif
#ifdef VK_NV_memory_decompression
    exports["VkDecompressMemoryRegionNV_compressedSize_offsetof"] = Napi::Number::New(env, offsetof(VkDecompressMemoryRegionNV, compressedSize));
#endif
#ifdef VK_NV_memory_decompression
    exports["VkDecompressMemoryRegionNV_decompressedSize_offsetof"] = Napi::Number::New(env, offsetof(VkDecompressMemoryRegionNV, decompressedSize));
#endif
#ifdef VK_NV_memory_decompression
    exports["VkDecompressMemoryRegionNV_decompressionMethod_offsetof"] = Napi::Number::New(env, offsetof(VkDecompressMemoryRegionNV, decompressionMethod));
#endif
#ifdef VK_NV_memory_decompression
    exports["VkDecompressMemoryRegionNV_sizeof"] = Napi::Number::New(env, sizeof(VkDecompressMemoryRegionNV));
#endif
#ifdef VK_ARM_shader_core_builtins
    exports["VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM, sType));
#endif
#ifdef VK_ARM_shader_core_builtins
    exports["VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM, pNext));
#endif
#ifdef VK_ARM_shader_core_builtins
    exports["VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM_shaderCoreMask_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM, shaderCoreMask));
#endif
#ifdef VK_ARM_shader_core_builtins
    exports["VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM_shaderCoreCount_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM, shaderCoreCount));
#endif
#ifdef VK_ARM_shader_core_builtins
    exports["VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM_shaderWarpsPerCore_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM, shaderWarpsPerCore));
#endif
#ifdef VK_ARM_shader_core_builtins
    exports["VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM));
#endif
#ifdef VK_ARM_shader_core_builtins
    exports["VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM, sType));
#endif
#ifdef VK_ARM_shader_core_builtins
    exports["VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM, pNext));
#endif
#ifdef VK_ARM_shader_core_builtins
    exports["VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM_shaderCoreBuiltins_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM, shaderCoreBuiltins));
#endif
#ifdef VK_ARM_shader_core_builtins
    exports["VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM));
#endif
#ifdef VK_NV_ray_tracing_invocation_reorder
    exports["VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV, sType));
#endif
#ifdef VK_NV_ray_tracing_invocation_reorder
    exports["VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV, pNext));
#endif
#ifdef VK_NV_ray_tracing_invocation_reorder
    exports["VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV_rayTracingInvocationReorder_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV, rayTracingInvocationReorder));
#endif
#ifdef VK_NV_ray_tracing_invocation_reorder
    exports["VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV));
#endif
#ifdef VK_NV_ray_tracing_invocation_reorder
    exports["VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV_sType_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV, sType));
#endif
#ifdef VK_NV_ray_tracing_invocation_reorder
    exports["VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV_pNext_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV, pNext));
#endif
#ifdef VK_NV_ray_tracing_invocation_reorder
    exports["VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV_rayTracingInvocationReorderReorderingHint_offsetof"] = Napi::Number::New(env, offsetof(VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV, rayTracingInvocationReorderReorderingHint));
#endif
#ifdef VK_NV_ray_tracing_invocation_reorder
    exports["VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV_sizeof"] = Napi::Number::New(env, sizeof(VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV));
#endif

    exports["vkCreateInstance"] = Napi::Function::New(env, rawCreateInstance);
    exports["vkDestroyInstance"] = Napi::Function::New(env, rawDestroyInstance);
    exports["vkEnumeratePhysicalDevices"] = Napi::Function::New(env, rawEnumeratePhysicalDevices);
    exports["vkGetDeviceProcAddr"] = Napi::Function::New(env, rawGetDeviceProcAddr);
    exports["vkGetInstanceProcAddr"] = Napi::Function::New(env, rawGetInstanceProcAddr);
    exports["vkGetPhysicalDeviceProperties"] = Napi::Function::New(env, rawGetPhysicalDeviceProperties);
    exports["vkGetPhysicalDeviceQueueFamilyProperties"] = Napi::Function::New(env, rawGetPhysicalDeviceQueueFamilyProperties);
    exports["vkGetPhysicalDeviceMemoryProperties"] = Napi::Function::New(env, rawGetPhysicalDeviceMemoryProperties);
    exports["vkGetPhysicalDeviceFeatures"] = Napi::Function::New(env, rawGetPhysicalDeviceFeatures);
    exports["vkGetPhysicalDeviceFormatProperties"] = Napi::Function::New(env, rawGetPhysicalDeviceFormatProperties);
    exports["vkGetPhysicalDeviceImageFormatProperties"] = Napi::Function::New(env, rawGetPhysicalDeviceImageFormatProperties);
    exports["vkCreateDevice"] = Napi::Function::New(env, rawCreateDevice);
    exports["vkDestroyDevice"] = Napi::Function::New(env, rawDestroyDevice);
    exports["vkEnumerateInstanceVersion"] = Napi::Function::New(env, rawEnumerateInstanceVersion);
    exports["vkEnumerateInstanceLayerProperties"] = Napi::Function::New(env, rawEnumerateInstanceLayerProperties);
    exports["vkEnumerateInstanceExtensionProperties"] = Napi::Function::New(env, rawEnumerateInstanceExtensionProperties);
    exports["vkEnumerateDeviceLayerProperties"] = Napi::Function::New(env, rawEnumerateDeviceLayerProperties);
    exports["vkEnumerateDeviceExtensionProperties"] = Napi::Function::New(env, rawEnumerateDeviceExtensionProperties);
    exports["vkGetDeviceQueue"] = Napi::Function::New(env, rawGetDeviceQueue);
    exports["vkQueueSubmit"] = Napi::Function::New(env, rawQueueSubmit);
    exports["vkQueueWaitIdle"] = Napi::Function::New(env, rawQueueWaitIdle);
    exports["vkDeviceWaitIdle"] = Napi::Function::New(env, rawDeviceWaitIdle);
    exports["vkAllocateMemory"] = Napi::Function::New(env, rawAllocateMemory);
    exports["vkFreeMemory"] = Napi::Function::New(env, rawFreeMemory);
    exports["vkMapMemory"] = Napi::Function::New(env, rawMapMemory);
    exports["vkUnmapMemory"] = Napi::Function::New(env, rawUnmapMemory);
    exports["vkFlushMappedMemoryRanges"] = Napi::Function::New(env, rawFlushMappedMemoryRanges);
    exports["vkInvalidateMappedMemoryRanges"] = Napi::Function::New(env, rawInvalidateMappedMemoryRanges);
    exports["vkGetDeviceMemoryCommitment"] = Napi::Function::New(env, rawGetDeviceMemoryCommitment);
    exports["vkGetBufferMemoryRequirements"] = Napi::Function::New(env, rawGetBufferMemoryRequirements);
    exports["vkBindBufferMemory"] = Napi::Function::New(env, rawBindBufferMemory);
    exports["vkGetImageMemoryRequirements"] = Napi::Function::New(env, rawGetImageMemoryRequirements);
    exports["vkBindImageMemory"] = Napi::Function::New(env, rawBindImageMemory);
    exports["vkGetImageSparseMemoryRequirements"] = Napi::Function::New(env, rawGetImageSparseMemoryRequirements);
    exports["vkGetPhysicalDeviceSparseImageFormatProperties"] = Napi::Function::New(env, rawGetPhysicalDeviceSparseImageFormatProperties);
    exports["vkQueueBindSparse"] = Napi::Function::New(env, rawQueueBindSparse);
    exports["vkCreateFence"] = Napi::Function::New(env, rawCreateFence);
    exports["vkDestroyFence"] = Napi::Function::New(env, rawDestroyFence);
    exports["vkResetFences"] = Napi::Function::New(env, rawResetFences);
    exports["vkGetFenceStatus"] = Napi::Function::New(env, rawGetFenceStatus);
    exports["vkWaitForFences"] = Napi::Function::New(env, rawWaitForFences);
    exports["vkCreateSemaphore"] = Napi::Function::New(env, rawCreateSemaphore);
    exports["vkDestroySemaphore"] = Napi::Function::New(env, rawDestroySemaphore);
    exports["vkCreateEvent"] = Napi::Function::New(env, rawCreateEvent);
    exports["vkDestroyEvent"] = Napi::Function::New(env, rawDestroyEvent);
    exports["vkGetEventStatus"] = Napi::Function::New(env, rawGetEventStatus);
    exports["vkSetEvent"] = Napi::Function::New(env, rawSetEvent);
    exports["vkResetEvent"] = Napi::Function::New(env, rawResetEvent);
    exports["vkCreateQueryPool"] = Napi::Function::New(env, rawCreateQueryPool);
    exports["vkDestroyQueryPool"] = Napi::Function::New(env, rawDestroyQueryPool);
    exports["vkGetQueryPoolResults"] = Napi::Function::New(env, rawGetQueryPoolResults);
    exports["vkResetQueryPool"] = Napi::Function::New(env, rawResetQueryPool);
    exports["vkCreateBuffer"] = Napi::Function::New(env, rawCreateBuffer);
    exports["vkDestroyBuffer"] = Napi::Function::New(env, rawDestroyBuffer);
    exports["vkCreateBufferView"] = Napi::Function::New(env, rawCreateBufferView);
    exports["vkDestroyBufferView"] = Napi::Function::New(env, rawDestroyBufferView);
    exports["vkCreateImage"] = Napi::Function::New(env, rawCreateImage);
    exports["vkDestroyImage"] = Napi::Function::New(env, rawDestroyImage);
    exports["vkGetImageSubresourceLayout"] = Napi::Function::New(env, rawGetImageSubresourceLayout);
    exports["vkCreateImageView"] = Napi::Function::New(env, rawCreateImageView);
    exports["vkDestroyImageView"] = Napi::Function::New(env, rawDestroyImageView);
    exports["vkCreateShaderModule"] = Napi::Function::New(env, rawCreateShaderModule);
    exports["vkDestroyShaderModule"] = Napi::Function::New(env, rawDestroyShaderModule);
    exports["vkCreatePipelineCache"] = Napi::Function::New(env, rawCreatePipelineCache);
    exports["vkDestroyPipelineCache"] = Napi::Function::New(env, rawDestroyPipelineCache);
    exports["vkGetPipelineCacheData"] = Napi::Function::New(env, rawGetPipelineCacheData);
    exports["vkMergePipelineCaches"] = Napi::Function::New(env, rawMergePipelineCaches);
    exports["vkCreateGraphicsPipelines"] = Napi::Function::New(env, rawCreateGraphicsPipelines);
    exports["vkCreateComputePipelines"] = Napi::Function::New(env, rawCreateComputePipelines);
#ifdef VK_HUAWEI_subpass_shading
    exports["vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI"] = Napi::Function::New(env, rawGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI);
#endif
    exports["vkDestroyPipeline"] = Napi::Function::New(env, rawDestroyPipeline);
    exports["vkCreatePipelineLayout"] = Napi::Function::New(env, rawCreatePipelineLayout);
    exports["vkDestroyPipelineLayout"] = Napi::Function::New(env, rawDestroyPipelineLayout);
    exports["vkCreateSampler"] = Napi::Function::New(env, rawCreateSampler);
    exports["vkDestroySampler"] = Napi::Function::New(env, rawDestroySampler);
    exports["vkCreateDescriptorSetLayout"] = Napi::Function::New(env, rawCreateDescriptorSetLayout);
    exports["vkDestroyDescriptorSetLayout"] = Napi::Function::New(env, rawDestroyDescriptorSetLayout);
    exports["vkCreateDescriptorPool"] = Napi::Function::New(env, rawCreateDescriptorPool);
    exports["vkDestroyDescriptorPool"] = Napi::Function::New(env, rawDestroyDescriptorPool);
    exports["vkResetDescriptorPool"] = Napi::Function::New(env, rawResetDescriptorPool);
    exports["vkAllocateDescriptorSets"] = Napi::Function::New(env, rawAllocateDescriptorSets);
    exports["vkFreeDescriptorSets"] = Napi::Function::New(env, rawFreeDescriptorSets);
    exports["vkUpdateDescriptorSets"] = Napi::Function::New(env, rawUpdateDescriptorSets);
    exports["vkCreateFramebuffer"] = Napi::Function::New(env, rawCreateFramebuffer);
    exports["vkDestroyFramebuffer"] = Napi::Function::New(env, rawDestroyFramebuffer);
    exports["vkCreateRenderPass"] = Napi::Function::New(env, rawCreateRenderPass);
    exports["vkDestroyRenderPass"] = Napi::Function::New(env, rawDestroyRenderPass);
    exports["vkGetRenderAreaGranularity"] = Napi::Function::New(env, rawGetRenderAreaGranularity);
    exports["vkCreateCommandPool"] = Napi::Function::New(env, rawCreateCommandPool);
    exports["vkDestroyCommandPool"] = Napi::Function::New(env, rawDestroyCommandPool);
    exports["vkResetCommandPool"] = Napi::Function::New(env, rawResetCommandPool);
    exports["vkAllocateCommandBuffers"] = Napi::Function::New(env, rawAllocateCommandBuffers);
    exports["vkFreeCommandBuffers"] = Napi::Function::New(env, rawFreeCommandBuffers);
    exports["vkBeginCommandBuffer"] = Napi::Function::New(env, rawBeginCommandBuffer);
    exports["vkEndCommandBuffer"] = Napi::Function::New(env, rawEndCommandBuffer);
    exports["vkResetCommandBuffer"] = Napi::Function::New(env, rawResetCommandBuffer);
    exports["vkCmdBindPipeline"] = Napi::Function::New(env, rawCmdBindPipeline);
    exports["vkCmdSetViewport"] = Napi::Function::New(env, rawCmdSetViewport);
    exports["vkCmdSetScissor"] = Napi::Function::New(env, rawCmdSetScissor);
    exports["vkCmdSetLineWidth"] = Napi::Function::New(env, rawCmdSetLineWidth);
    exports["vkCmdSetDepthBias"] = Napi::Function::New(env, rawCmdSetDepthBias);
    exports["vkCmdSetBlendConstants"] = Napi::Function::New(env, rawCmdSetBlendConstants);
    exports["vkCmdSetDepthBounds"] = Napi::Function::New(env, rawCmdSetDepthBounds);
    exports["vkCmdSetStencilCompareMask"] = Napi::Function::New(env, rawCmdSetStencilCompareMask);
    exports["vkCmdSetStencilWriteMask"] = Napi::Function::New(env, rawCmdSetStencilWriteMask);
    exports["vkCmdSetStencilReference"] = Napi::Function::New(env, rawCmdSetStencilReference);
    exports["vkCmdBindDescriptorSets"] = Napi::Function::New(env, rawCmdBindDescriptorSets);
    exports["vkCmdBindIndexBuffer"] = Napi::Function::New(env, rawCmdBindIndexBuffer);
    exports["vkCmdBindVertexBuffers"] = Napi::Function::New(env, rawCmdBindVertexBuffers);
    exports["vkCmdDraw"] = Napi::Function::New(env, rawCmdDraw);
    exports["vkCmdDrawIndexed"] = Napi::Function::New(env, rawCmdDrawIndexed);
#ifdef VK_EXT_multi_draw
    exports["vkCmdDrawMultiEXT"] = Napi::Function::New(env, rawCmdDrawMultiEXT);
#endif
#ifdef VK_EXT_multi_draw
    exports["vkCmdDrawMultiIndexedEXT"] = Napi::Function::New(env, rawCmdDrawMultiIndexedEXT);
#endif
    exports["vkCmdDrawIndirect"] = Napi::Function::New(env, rawCmdDrawIndirect);
    exports["vkCmdDrawIndexedIndirect"] = Napi::Function::New(env, rawCmdDrawIndexedIndirect);
    exports["vkCmdDispatch"] = Napi::Function::New(env, rawCmdDispatch);
    exports["vkCmdDispatchIndirect"] = Napi::Function::New(env, rawCmdDispatchIndirect);
#ifdef VK_HUAWEI_subpass_shading
    exports["vkCmdSubpassShadingHUAWEI"] = Napi::Function::New(env, rawCmdSubpassShadingHUAWEI);
#endif
    exports["vkCmdCopyBuffer"] = Napi::Function::New(env, rawCmdCopyBuffer);
    exports["vkCmdCopyImage"] = Napi::Function::New(env, rawCmdCopyImage);
    exports["vkCmdBlitImage"] = Napi::Function::New(env, rawCmdBlitImage);
    exports["vkCmdCopyBufferToImage"] = Napi::Function::New(env, rawCmdCopyBufferToImage);
    exports["vkCmdCopyImageToBuffer"] = Napi::Function::New(env, rawCmdCopyImageToBuffer);
#ifdef VK_NV_copy_memory_indirect
    exports["vkCmdCopyMemoryIndirectNV"] = Napi::Function::New(env, rawCmdCopyMemoryIndirectNV);
#endif
#ifdef VK_NV_copy_memory_indirect
    exports["vkCmdCopyMemoryToImageIndirectNV"] = Napi::Function::New(env, rawCmdCopyMemoryToImageIndirectNV);
#endif
    exports["vkCmdUpdateBuffer"] = Napi::Function::New(env, rawCmdUpdateBuffer);
    exports["vkCmdFillBuffer"] = Napi::Function::New(env, rawCmdFillBuffer);
    exports["vkCmdClearColorImage"] = Napi::Function::New(env, rawCmdClearColorImage);
    exports["vkCmdClearDepthStencilImage"] = Napi::Function::New(env, rawCmdClearDepthStencilImage);
    exports["vkCmdClearAttachments"] = Napi::Function::New(env, rawCmdClearAttachments);
    exports["vkCmdResolveImage"] = Napi::Function::New(env, rawCmdResolveImage);
    exports["vkCmdSetEvent"] = Napi::Function::New(env, rawCmdSetEvent);
    exports["vkCmdResetEvent"] = Napi::Function::New(env, rawCmdResetEvent);
    exports["vkCmdWaitEvents"] = Napi::Function::New(env, rawCmdWaitEvents);
    exports["vkCmdPipelineBarrier"] = Napi::Function::New(env, rawCmdPipelineBarrier);
    exports["vkCmdBeginQuery"] = Napi::Function::New(env, rawCmdBeginQuery);
    exports["vkCmdEndQuery"] = Napi::Function::New(env, rawCmdEndQuery);
#ifdef VK_EXT_conditional_rendering
    exports["vkCmdBeginConditionalRenderingEXT"] = Napi::Function::New(env, rawCmdBeginConditionalRenderingEXT);
#endif
#ifdef VK_EXT_conditional_rendering
    exports["vkCmdEndConditionalRenderingEXT"] = Napi::Function::New(env, rawCmdEndConditionalRenderingEXT);
#endif
    exports["vkCmdResetQueryPool"] = Napi::Function::New(env, rawCmdResetQueryPool);
    exports["vkCmdWriteTimestamp"] = Napi::Function::New(env, rawCmdWriteTimestamp);
    exports["vkCmdCopyQueryPoolResults"] = Napi::Function::New(env, rawCmdCopyQueryPoolResults);
    exports["vkCmdPushConstants"] = Napi::Function::New(env, rawCmdPushConstants);
    exports["vkCmdBeginRenderPass"] = Napi::Function::New(env, rawCmdBeginRenderPass);
    exports["vkCmdNextSubpass"] = Napi::Function::New(env, rawCmdNextSubpass);
    exports["vkCmdEndRenderPass"] = Napi::Function::New(env, rawCmdEndRenderPass);
    exports["vkCmdExecuteCommands"] = Napi::Function::New(env, rawCmdExecuteCommands);
#ifdef VK_KHR_android_surface
    exports["vkCreateAndroidSurfaceKHR"] = Napi::Function::New(env, rawCreateAndroidSurfaceKHR);
#endif
#ifdef VK_KHR_display
    exports["vkGetPhysicalDeviceDisplayPropertiesKHR"] = Napi::Function::New(env, rawGetPhysicalDeviceDisplayPropertiesKHR);
#endif
#ifdef VK_KHR_display
    exports["vkGetPhysicalDeviceDisplayPlanePropertiesKHR"] = Napi::Function::New(env, rawGetPhysicalDeviceDisplayPlanePropertiesKHR);
#endif
#ifdef VK_KHR_display
    exports["vkGetDisplayPlaneSupportedDisplaysKHR"] = Napi::Function::New(env, rawGetDisplayPlaneSupportedDisplaysKHR);
#endif
#ifdef VK_KHR_display
    exports["vkGetDisplayModePropertiesKHR"] = Napi::Function::New(env, rawGetDisplayModePropertiesKHR);
#endif
#ifdef VK_KHR_display
    exports["vkCreateDisplayModeKHR"] = Napi::Function::New(env, rawCreateDisplayModeKHR);
#endif
#ifdef VK_KHR_display
    exports["vkGetDisplayPlaneCapabilitiesKHR"] = Napi::Function::New(env, rawGetDisplayPlaneCapabilitiesKHR);
#endif
#ifdef VK_KHR_display
    exports["vkCreateDisplayPlaneSurfaceKHR"] = Napi::Function::New(env, rawCreateDisplayPlaneSurfaceKHR);
#endif
#ifdef VK_KHR_display_swapchain
    exports["vkCreateSharedSwapchainsKHR"] = Napi::Function::New(env, rawCreateSharedSwapchainsKHR);
#endif
#ifdef VK_KHR_surface
    exports["vkDestroySurfaceKHR"] = Napi::Function::New(env, rawDestroySurfaceKHR);
#endif
#ifdef VK_KHR_surface
    exports["vkGetPhysicalDeviceSurfaceSupportKHR"] = Napi::Function::New(env, rawGetPhysicalDeviceSurfaceSupportKHR);
#endif
#ifdef VK_KHR_surface
    exports["vkGetPhysicalDeviceSurfaceCapabilitiesKHR"] = Napi::Function::New(env, rawGetPhysicalDeviceSurfaceCapabilitiesKHR);
#endif
#ifdef VK_KHR_surface
    exports["vkGetPhysicalDeviceSurfaceFormatsKHR"] = Napi::Function::New(env, rawGetPhysicalDeviceSurfaceFormatsKHR);
#endif
#ifdef VK_KHR_surface
    exports["vkGetPhysicalDeviceSurfacePresentModesKHR"] = Napi::Function::New(env, rawGetPhysicalDeviceSurfacePresentModesKHR);
#endif
#ifdef VK_KHR_swapchain
    exports["vkCreateSwapchainKHR"] = Napi::Function::New(env, rawCreateSwapchainKHR);
#endif
#ifdef VK_KHR_swapchain
    exports["vkDestroySwapchainKHR"] = Napi::Function::New(env, rawDestroySwapchainKHR);
#endif
#ifdef VK_KHR_swapchain
    exports["vkGetSwapchainImagesKHR"] = Napi::Function::New(env, rawGetSwapchainImagesKHR);
#endif
#ifdef VK_KHR_swapchain
    exports["vkAcquireNextImageKHR"] = Napi::Function::New(env, rawAcquireNextImageKHR);
#endif
#ifdef VK_KHR_swapchain
    exports["vkQueuePresentKHR"] = Napi::Function::New(env, rawQueuePresentKHR);
#endif
#ifdef VK_NN_vi_surface
    exports["vkCreateViSurfaceNN"] = Napi::Function::New(env, rawCreateViSurfaceNN);
#endif
#ifdef VK_KHR_wayland_surface
    exports["vkCreateWaylandSurfaceKHR"] = Napi::Function::New(env, rawCreateWaylandSurfaceKHR);
#endif
#ifdef VK_KHR_wayland_surface
    exports["vkGetPhysicalDeviceWaylandPresentationSupportKHR"] = Napi::Function::New(env, rawGetPhysicalDeviceWaylandPresentationSupportKHR);
#endif
#ifdef VK_KHR_win32_surface
    exports["vkCreateWin32SurfaceKHR"] = Napi::Function::New(env, rawCreateWin32SurfaceKHR);
#endif
#ifdef VK_KHR_win32_surface
    exports["vkGetPhysicalDeviceWin32PresentationSupportKHR"] = Napi::Function::New(env, rawGetPhysicalDeviceWin32PresentationSupportKHR);
#endif
#ifdef VK_KHR_xlib_surface
    exports["vkCreateXlibSurfaceKHR"] = Napi::Function::New(env, rawCreateXlibSurfaceKHR);
#endif
#ifdef VK_KHR_xlib_surface
    exports["vkGetPhysicalDeviceXlibPresentationSupportKHR"] = Napi::Function::New(env, rawGetPhysicalDeviceXlibPresentationSupportKHR);
#endif
#ifdef VK_KHR_xcb_surface
    exports["vkCreateXcbSurfaceKHR"] = Napi::Function::New(env, rawCreateXcbSurfaceKHR);
#endif
#ifdef VK_KHR_xcb_surface
    exports["vkGetPhysicalDeviceXcbPresentationSupportKHR"] = Napi::Function::New(env, rawGetPhysicalDeviceXcbPresentationSupportKHR);
#endif
#ifdef VK_EXT_directfb_surface
    exports["vkCreateDirectFBSurfaceEXT"] = Napi::Function::New(env, rawCreateDirectFBSurfaceEXT);
#endif
#ifdef VK_EXT_directfb_surface
    exports["vkGetPhysicalDeviceDirectFBPresentationSupportEXT"] = Napi::Function::New(env, rawGetPhysicalDeviceDirectFBPresentationSupportEXT);
#endif
#ifdef VK_FUCHSIA_imagepipe_surface
    exports["vkCreateImagePipeSurfaceFUCHSIA"] = Napi::Function::New(env, rawCreateImagePipeSurfaceFUCHSIA);
#endif
#ifdef VK_GGP_stream_descriptor_surface
    exports["vkCreateStreamDescriptorSurfaceGGP"] = Napi::Function::New(env, rawCreateStreamDescriptorSurfaceGGP);
#endif
#ifdef VK_QNX_screen_surface
    exports["vkCreateScreenSurfaceQNX"] = Napi::Function::New(env, rawCreateScreenSurfaceQNX);
#endif
#ifdef VK_QNX_screen_surface
    exports["vkGetPhysicalDeviceScreenPresentationSupportQNX"] = Napi::Function::New(env, rawGetPhysicalDeviceScreenPresentationSupportQNX);
#endif
#ifdef VK_EXT_debug_report
    exports["vkCreateDebugReportCallbackEXT"] = Napi::Function::New(env, rawCreateDebugReportCallbackEXT);
#endif
#ifdef VK_EXT_debug_report
    exports["vkDestroyDebugReportCallbackEXT"] = Napi::Function::New(env, rawDestroyDebugReportCallbackEXT);
#endif
#ifdef VK_EXT_debug_report
    exports["vkDebugReportMessageEXT"] = Napi::Function::New(env, rawDebugReportMessageEXT);
#endif
#ifdef VK_EXT_debug_marker
    exports["vkDebugMarkerSetObjectNameEXT"] = Napi::Function::New(env, rawDebugMarkerSetObjectNameEXT);
#endif
#ifdef VK_EXT_debug_marker
    exports["vkDebugMarkerSetObjectTagEXT"] = Napi::Function::New(env, rawDebugMarkerSetObjectTagEXT);
#endif
#ifdef VK_EXT_debug_marker
    exports["vkCmdDebugMarkerBeginEXT"] = Napi::Function::New(env, rawCmdDebugMarkerBeginEXT);
#endif
#ifdef VK_EXT_debug_marker
    exports["vkCmdDebugMarkerEndEXT"] = Napi::Function::New(env, rawCmdDebugMarkerEndEXT);
#endif
#ifdef VK_EXT_debug_marker
    exports["vkCmdDebugMarkerInsertEXT"] = Napi::Function::New(env, rawCmdDebugMarkerInsertEXT);
#endif
#ifdef VK_NV_external_memory_capabilities
    exports["vkGetPhysicalDeviceExternalImageFormatPropertiesNV"] = Napi::Function::New(env, rawGetPhysicalDeviceExternalImageFormatPropertiesNV);
#endif
#ifdef VK_NV_external_memory_win32
    exports["vkGetMemoryWin32HandleNV"] = Napi::Function::New(env, rawGetMemoryWin32HandleNV);
#endif
#ifdef VK_NV_device_generated_commands
    exports["vkCmdExecuteGeneratedCommandsNV"] = Napi::Function::New(env, rawCmdExecuteGeneratedCommandsNV);
#endif
#ifdef VK_NV_device_generated_commands
    exports["vkCmdPreprocessGeneratedCommandsNV"] = Napi::Function::New(env, rawCmdPreprocessGeneratedCommandsNV);
#endif
#ifdef VK_NV_device_generated_commands
    exports["vkCmdBindPipelineShaderGroupNV"] = Napi::Function::New(env, rawCmdBindPipelineShaderGroupNV);
#endif
#ifdef VK_NV_device_generated_commands
    exports["vkGetGeneratedCommandsMemoryRequirementsNV"] = Napi::Function::New(env, rawGetGeneratedCommandsMemoryRequirementsNV);
#endif
#ifdef VK_NV_device_generated_commands
    exports["vkCreateIndirectCommandsLayoutNV"] = Napi::Function::New(env, rawCreateIndirectCommandsLayoutNV);
#endif
#ifdef VK_NV_device_generated_commands
    exports["vkDestroyIndirectCommandsLayoutNV"] = Napi::Function::New(env, rawDestroyIndirectCommandsLayoutNV);
#endif
    exports["vkGetPhysicalDeviceFeatures2"] = Napi::Function::New(env, rawGetPhysicalDeviceFeatures2);
    exports["vkGetPhysicalDeviceProperties2"] = Napi::Function::New(env, rawGetPhysicalDeviceProperties2);
    exports["vkGetPhysicalDeviceFormatProperties2"] = Napi::Function::New(env, rawGetPhysicalDeviceFormatProperties2);
    exports["vkGetPhysicalDeviceImageFormatProperties2"] = Napi::Function::New(env, rawGetPhysicalDeviceImageFormatProperties2);
    exports["vkGetPhysicalDeviceQueueFamilyProperties2"] = Napi::Function::New(env, rawGetPhysicalDeviceQueueFamilyProperties2);
    exports["vkGetPhysicalDeviceMemoryProperties2"] = Napi::Function::New(env, rawGetPhysicalDeviceMemoryProperties2);
    exports["vkGetPhysicalDeviceSparseImageFormatProperties2"] = Napi::Function::New(env, rawGetPhysicalDeviceSparseImageFormatProperties2);
#ifdef VK_KHR_push_descriptor
    exports["vkCmdPushDescriptorSetKHR"] = Napi::Function::New(env, rawCmdPushDescriptorSetKHR);
#endif
    exports["vkTrimCommandPool"] = Napi::Function::New(env, rawTrimCommandPool);
    exports["vkGetPhysicalDeviceExternalBufferProperties"] = Napi::Function::New(env, rawGetPhysicalDeviceExternalBufferProperties);
#ifdef VK_KHR_external_memory_win32
    exports["vkGetMemoryWin32HandleKHR"] = Napi::Function::New(env, rawGetMemoryWin32HandleKHR);
#endif
#ifdef VK_KHR_external_memory_win32
    exports["vkGetMemoryWin32HandlePropertiesKHR"] = Napi::Function::New(env, rawGetMemoryWin32HandlePropertiesKHR);
#endif
#ifdef VK_KHR_external_memory_fd
    exports["vkGetMemoryFdKHR"] = Napi::Function::New(env, rawGetMemoryFdKHR);
#endif
#ifdef VK_KHR_external_memory_fd
    exports["vkGetMemoryFdPropertiesKHR"] = Napi::Function::New(env, rawGetMemoryFdPropertiesKHR);
#endif
#ifdef VK_FUCHSIA_external_memory
    exports["vkGetMemoryZirconHandleFUCHSIA"] = Napi::Function::New(env, rawGetMemoryZirconHandleFUCHSIA);
#endif
#ifdef VK_FUCHSIA_external_memory
    exports["vkGetMemoryZirconHandlePropertiesFUCHSIA"] = Napi::Function::New(env, rawGetMemoryZirconHandlePropertiesFUCHSIA);
#endif
#ifdef VK_NV_external_memory_rdma
    exports["vkGetMemoryRemoteAddressNV"] = Napi::Function::New(env, rawGetMemoryRemoteAddressNV);
#endif
    exports["vkGetPhysicalDeviceExternalSemaphoreProperties"] = Napi::Function::New(env, rawGetPhysicalDeviceExternalSemaphoreProperties);
#ifdef VK_KHR_external_semaphore_win32
    exports["vkGetSemaphoreWin32HandleKHR"] = Napi::Function::New(env, rawGetSemaphoreWin32HandleKHR);
#endif
#ifdef VK_KHR_external_semaphore_win32
    exports["vkImportSemaphoreWin32HandleKHR"] = Napi::Function::New(env, rawImportSemaphoreWin32HandleKHR);
#endif
#ifdef VK_KHR_external_semaphore_fd
    exports["vkGetSemaphoreFdKHR"] = Napi::Function::New(env, rawGetSemaphoreFdKHR);
#endif
#ifdef VK_KHR_external_semaphore_fd
    exports["vkImportSemaphoreFdKHR"] = Napi::Function::New(env, rawImportSemaphoreFdKHR);
#endif
#ifdef VK_FUCHSIA_external_semaphore
    exports["vkGetSemaphoreZirconHandleFUCHSIA"] = Napi::Function::New(env, rawGetSemaphoreZirconHandleFUCHSIA);
#endif
#ifdef VK_FUCHSIA_external_semaphore
    exports["vkImportSemaphoreZirconHandleFUCHSIA"] = Napi::Function::New(env, rawImportSemaphoreZirconHandleFUCHSIA);
#endif
    exports["vkGetPhysicalDeviceExternalFenceProperties"] = Napi::Function::New(env, rawGetPhysicalDeviceExternalFenceProperties);
#ifdef VK_KHR_external_fence_win32
    exports["vkGetFenceWin32HandleKHR"] = Napi::Function::New(env, rawGetFenceWin32HandleKHR);
#endif
#ifdef VK_KHR_external_fence_win32
    exports["vkImportFenceWin32HandleKHR"] = Napi::Function::New(env, rawImportFenceWin32HandleKHR);
#endif
#ifdef VK_KHR_external_fence_fd
    exports["vkGetFenceFdKHR"] = Napi::Function::New(env, rawGetFenceFdKHR);
#endif
#ifdef VK_KHR_external_fence_fd
    exports["vkImportFenceFdKHR"] = Napi::Function::New(env, rawImportFenceFdKHR);
#endif
#ifdef VK_EXT_direct_mode_display
    exports["vkReleaseDisplayEXT"] = Napi::Function::New(env, rawReleaseDisplayEXT);
#endif
#ifdef VK_EXT_acquire_xlib_display
    exports["vkAcquireXlibDisplayEXT"] = Napi::Function::New(env, rawAcquireXlibDisplayEXT);
#endif
#ifdef VK_EXT_acquire_xlib_display
    exports["vkGetRandROutputDisplayEXT"] = Napi::Function::New(env, rawGetRandROutputDisplayEXT);
#endif
#ifdef VK_NV_acquire_winrt_display
    exports["vkAcquireWinrtDisplayNV"] = Napi::Function::New(env, rawAcquireWinrtDisplayNV);
#endif
#ifdef VK_NV_acquire_winrt_display
    exports["vkGetWinrtDisplayNV"] = Napi::Function::New(env, rawGetWinrtDisplayNV);
#endif
#ifdef VK_EXT_display_control
    exports["vkDisplayPowerControlEXT"] = Napi::Function::New(env, rawDisplayPowerControlEXT);
#endif
#ifdef VK_EXT_display_control
    exports["vkRegisterDeviceEventEXT"] = Napi::Function::New(env, rawRegisterDeviceEventEXT);
#endif
#ifdef VK_EXT_display_control
    exports["vkRegisterDisplayEventEXT"] = Napi::Function::New(env, rawRegisterDisplayEventEXT);
#endif
#ifdef VK_EXT_display_control
    exports["vkGetSwapchainCounterEXT"] = Napi::Function::New(env, rawGetSwapchainCounterEXT);
#endif
#ifdef VK_EXT_display_surface_counter
    exports["vkGetPhysicalDeviceSurfaceCapabilities2EXT"] = Napi::Function::New(env, rawGetPhysicalDeviceSurfaceCapabilities2EXT);
#endif
    exports["vkEnumeratePhysicalDeviceGroups"] = Napi::Function::New(env, rawEnumeratePhysicalDeviceGroups);
    exports["vkGetDeviceGroupPeerMemoryFeatures"] = Napi::Function::New(env, rawGetDeviceGroupPeerMemoryFeatures);
    exports["vkBindBufferMemory2"] = Napi::Function::New(env, rawBindBufferMemory2);
    exports["vkBindImageMemory2"] = Napi::Function::New(env, rawBindImageMemory2);
    exports["vkCmdSetDeviceMask"] = Napi::Function::New(env, rawCmdSetDeviceMask);
#ifdef VK_KHR_device_group
    exports["vkGetDeviceGroupPresentCapabilitiesKHR"] = Napi::Function::New(env, rawGetDeviceGroupPresentCapabilitiesKHR);
#endif
#ifdef VK_KHR_device_group
    exports["vkGetDeviceGroupSurfacePresentModesKHR"] = Napi::Function::New(env, rawGetDeviceGroupSurfacePresentModesKHR);
#endif
#ifdef VK_KHR_device_group
    exports["vkAcquireNextImage2KHR"] = Napi::Function::New(env, rawAcquireNextImage2KHR);
#endif
    exports["vkCmdDispatchBase"] = Napi::Function::New(env, rawCmdDispatchBase);
#ifdef VK_KHR_device_group
    exports["vkGetPhysicalDevicePresentRectanglesKHR"] = Napi::Function::New(env, rawGetPhysicalDevicePresentRectanglesKHR);
#endif
    exports["vkCreateDescriptorUpdateTemplate"] = Napi::Function::New(env, rawCreateDescriptorUpdateTemplate);
    exports["vkDestroyDescriptorUpdateTemplate"] = Napi::Function::New(env, rawDestroyDescriptorUpdateTemplate);
    exports["vkUpdateDescriptorSetWithTemplate"] = Napi::Function::New(env, rawUpdateDescriptorSetWithTemplate);
#ifdef VK_KHR_descriptor_update_template
    exports["vkCmdPushDescriptorSetWithTemplateKHR"] = Napi::Function::New(env, rawCmdPushDescriptorSetWithTemplateKHR);
#endif
#ifdef VK_EXT_hdr_metadata
    exports["vkSetHdrMetadataEXT"] = Napi::Function::New(env, rawSetHdrMetadataEXT);
#endif
#ifdef VK_KHR_shared_presentable_image
    exports["vkGetSwapchainStatusKHR"] = Napi::Function::New(env, rawGetSwapchainStatusKHR);
#endif
#ifdef VK_GOOGLE_display_timing
    exports["vkGetRefreshCycleDurationGOOGLE"] = Napi::Function::New(env, rawGetRefreshCycleDurationGOOGLE);
#endif
#ifdef VK_GOOGLE_display_timing
    exports["vkGetPastPresentationTimingGOOGLE"] = Napi::Function::New(env, rawGetPastPresentationTimingGOOGLE);
#endif
#ifdef VK_MVK_ios_surface
    exports["vkCreateIOSSurfaceMVK"] = Napi::Function::New(env, rawCreateIOSSurfaceMVK);
#endif
#ifdef VK_MVK_macos_surface
    exports["vkCreateMacOSSurfaceMVK"] = Napi::Function::New(env, rawCreateMacOSSurfaceMVK);
#endif
#ifdef VK_EXT_metal_surface
    exports["vkCreateMetalSurfaceEXT"] = Napi::Function::New(env, rawCreateMetalSurfaceEXT);
#endif
#ifdef VK_NV_clip_space_w_scaling
    exports["vkCmdSetViewportWScalingNV"] = Napi::Function::New(env, rawCmdSetViewportWScalingNV);
#endif
#ifdef VK_EXT_discard_rectangles
    exports["vkCmdSetDiscardRectangleEXT"] = Napi::Function::New(env, rawCmdSetDiscardRectangleEXT);
#endif
#ifdef VK_EXT_sample_locations
    exports["vkCmdSetSampleLocationsEXT"] = Napi::Function::New(env, rawCmdSetSampleLocationsEXT);
#endif
#ifdef VK_EXT_sample_locations
    exports["vkGetPhysicalDeviceMultisamplePropertiesEXT"] = Napi::Function::New(env, rawGetPhysicalDeviceMultisamplePropertiesEXT);
#endif
#ifdef VK_KHR_get_surface_capabilities2
    exports["vkGetPhysicalDeviceSurfaceCapabilities2KHR"] = Napi::Function::New(env, rawGetPhysicalDeviceSurfaceCapabilities2KHR);
#endif
#ifdef VK_KHR_get_surface_capabilities2
    exports["vkGetPhysicalDeviceSurfaceFormats2KHR"] = Napi::Function::New(env, rawGetPhysicalDeviceSurfaceFormats2KHR);
#endif
#ifdef VK_KHR_get_display_properties2
    exports["vkGetPhysicalDeviceDisplayProperties2KHR"] = Napi::Function::New(env, rawGetPhysicalDeviceDisplayProperties2KHR);
#endif
#ifdef VK_KHR_get_display_properties2
    exports["vkGetPhysicalDeviceDisplayPlaneProperties2KHR"] = Napi::Function::New(env, rawGetPhysicalDeviceDisplayPlaneProperties2KHR);
#endif
#ifdef VK_KHR_get_display_properties2
    exports["vkGetDisplayModeProperties2KHR"] = Napi::Function::New(env, rawGetDisplayModeProperties2KHR);
#endif
#ifdef VK_KHR_get_display_properties2
    exports["vkGetDisplayPlaneCapabilities2KHR"] = Napi::Function::New(env, rawGetDisplayPlaneCapabilities2KHR);
#endif
    exports["vkGetBufferMemoryRequirements2"] = Napi::Function::New(env, rawGetBufferMemoryRequirements2);
    exports["vkGetImageMemoryRequirements2"] = Napi::Function::New(env, rawGetImageMemoryRequirements2);
    exports["vkGetImageSparseMemoryRequirements2"] = Napi::Function::New(env, rawGetImageSparseMemoryRequirements2);
    exports["vkGetDeviceBufferMemoryRequirements"] = Napi::Function::New(env, rawGetDeviceBufferMemoryRequirements);
    exports["vkGetDeviceImageMemoryRequirements"] = Napi::Function::New(env, rawGetDeviceImageMemoryRequirements);
    exports["vkGetDeviceImageSparseMemoryRequirements"] = Napi::Function::New(env, rawGetDeviceImageSparseMemoryRequirements);
    exports["vkCreateSamplerYcbcrConversion"] = Napi::Function::New(env, rawCreateSamplerYcbcrConversion);
    exports["vkDestroySamplerYcbcrConversion"] = Napi::Function::New(env, rawDestroySamplerYcbcrConversion);
    exports["vkGetDeviceQueue2"] = Napi::Function::New(env, rawGetDeviceQueue2);
#ifdef VK_EXT_validation_cache
    exports["vkCreateValidationCacheEXT"] = Napi::Function::New(env, rawCreateValidationCacheEXT);
#endif
#ifdef VK_EXT_validation_cache
    exports["vkDestroyValidationCacheEXT"] = Napi::Function::New(env, rawDestroyValidationCacheEXT);
#endif
#ifdef VK_EXT_validation_cache
    exports["vkGetValidationCacheDataEXT"] = Napi::Function::New(env, rawGetValidationCacheDataEXT);
#endif
#ifdef VK_EXT_validation_cache
    exports["vkMergeValidationCachesEXT"] = Napi::Function::New(env, rawMergeValidationCachesEXT);
#endif
    exports["vkGetDescriptorSetLayoutSupport"] = Napi::Function::New(env, rawGetDescriptorSetLayoutSupport);
#ifdef VK_ANDROID_native_buffer
    exports["vkGetSwapchainGrallocUsageANDROID"] = Napi::Function::New(env, rawGetSwapchainGrallocUsageANDROID);
#endif
#ifdef VK_ANDROID_native_buffer
    exports["vkGetSwapchainGrallocUsage2ANDROID"] = Napi::Function::New(env, rawGetSwapchainGrallocUsage2ANDROID);
#endif
#ifdef VK_ANDROID_native_buffer
    exports["vkAcquireImageANDROID"] = Napi::Function::New(env, rawAcquireImageANDROID);
#endif
#ifdef VK_ANDROID_native_buffer
    exports["vkQueueSignalReleaseImageANDROID"] = Napi::Function::New(env, rawQueueSignalReleaseImageANDROID);
#endif
#ifdef VK_AMD_shader_info
    exports["vkGetShaderInfoAMD"] = Napi::Function::New(env, rawGetShaderInfoAMD);
#endif
#ifdef VK_AMD_display_native_hdr
    exports["vkSetLocalDimmingAMD"] = Napi::Function::New(env, rawSetLocalDimmingAMD);
#endif
#ifdef VK_EXT_calibrated_timestamps
    exports["vkGetPhysicalDeviceCalibrateableTimeDomainsEXT"] = Napi::Function::New(env, rawGetPhysicalDeviceCalibrateableTimeDomainsEXT);
#endif
#ifdef VK_EXT_calibrated_timestamps
    exports["vkGetCalibratedTimestampsEXT"] = Napi::Function::New(env, rawGetCalibratedTimestampsEXT);
#endif
#ifdef VK_EXT_debug_utils
    exports["vkSetDebugUtilsObjectNameEXT"] = Napi::Function::New(env, rawSetDebugUtilsObjectNameEXT);
#endif
#ifdef VK_EXT_debug_utils
    exports["vkSetDebugUtilsObjectTagEXT"] = Napi::Function::New(env, rawSetDebugUtilsObjectTagEXT);
#endif
#ifdef VK_EXT_debug_utils
    exports["vkQueueBeginDebugUtilsLabelEXT"] = Napi::Function::New(env, rawQueueBeginDebugUtilsLabelEXT);
#endif
#ifdef VK_EXT_debug_utils
    exports["vkQueueEndDebugUtilsLabelEXT"] = Napi::Function::New(env, rawQueueEndDebugUtilsLabelEXT);
#endif
#ifdef VK_EXT_debug_utils
    exports["vkQueueInsertDebugUtilsLabelEXT"] = Napi::Function::New(env, rawQueueInsertDebugUtilsLabelEXT);
#endif
#ifdef VK_EXT_debug_utils
    exports["vkCmdBeginDebugUtilsLabelEXT"] = Napi::Function::New(env, rawCmdBeginDebugUtilsLabelEXT);
#endif
#ifdef VK_EXT_debug_utils
    exports["vkCmdEndDebugUtilsLabelEXT"] = Napi::Function::New(env, rawCmdEndDebugUtilsLabelEXT);
#endif
#ifdef VK_EXT_debug_utils
    exports["vkCmdInsertDebugUtilsLabelEXT"] = Napi::Function::New(env, rawCmdInsertDebugUtilsLabelEXT);
#endif
#ifdef VK_EXT_debug_utils
    exports["vkCreateDebugUtilsMessengerEXT"] = Napi::Function::New(env, rawCreateDebugUtilsMessengerEXT);
#endif
#ifdef VK_EXT_debug_utils
    exports["vkDestroyDebugUtilsMessengerEXT"] = Napi::Function::New(env, rawDestroyDebugUtilsMessengerEXT);
#endif
#ifdef VK_EXT_debug_utils
    exports["vkSubmitDebugUtilsMessageEXT"] = Napi::Function::New(env, rawSubmitDebugUtilsMessageEXT);
#endif
#ifdef VK_EXT_external_memory_host
    exports["vkGetMemoryHostPointerPropertiesEXT"] = Napi::Function::New(env, rawGetMemoryHostPointerPropertiesEXT);
#endif
#ifdef VK_AMD_buffer_marker
    exports["vkCmdWriteBufferMarkerAMD"] = Napi::Function::New(env, rawCmdWriteBufferMarkerAMD);
#endif
    exports["vkCreateRenderPass2"] = Napi::Function::New(env, rawCreateRenderPass2);
    exports["vkCmdBeginRenderPass2"] = Napi::Function::New(env, rawCmdBeginRenderPass2);
    exports["vkCmdNextSubpass2"] = Napi::Function::New(env, rawCmdNextSubpass2);
    exports["vkCmdEndRenderPass2"] = Napi::Function::New(env, rawCmdEndRenderPass2);
    exports["vkGetSemaphoreCounterValue"] = Napi::Function::New(env, rawGetSemaphoreCounterValue);
    exports["vkWaitSemaphores"] = Napi::Function::New(env, rawWaitSemaphores);
    exports["vkSignalSemaphore"] = Napi::Function::New(env, rawSignalSemaphore);
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["vkGetAndroidHardwareBufferPropertiesANDROID"] = Napi::Function::New(env, rawGetAndroidHardwareBufferPropertiesANDROID);
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    exports["vkGetMemoryAndroidHardwareBufferANDROID"] = Napi::Function::New(env, rawGetMemoryAndroidHardwareBufferANDROID);
#endif
    exports["vkCmdDrawIndirectCount"] = Napi::Function::New(env, rawCmdDrawIndirectCount);
    exports["vkCmdDrawIndexedIndirectCount"] = Napi::Function::New(env, rawCmdDrawIndexedIndirectCount);
#ifdef VK_NV_device_diagnostic_checkpoints
    exports["vkCmdSetCheckpointNV"] = Napi::Function::New(env, rawCmdSetCheckpointNV);
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
    exports["vkGetQueueCheckpointDataNV"] = Napi::Function::New(env, rawGetQueueCheckpointDataNV);
#endif
#ifdef VK_EXT_transform_feedback
    exports["vkCmdBindTransformFeedbackBuffersEXT"] = Napi::Function::New(env, rawCmdBindTransformFeedbackBuffersEXT);
#endif
#ifdef VK_EXT_transform_feedback
    exports["vkCmdBeginTransformFeedbackEXT"] = Napi::Function::New(env, rawCmdBeginTransformFeedbackEXT);
#endif
#ifdef VK_EXT_transform_feedback
    exports["vkCmdEndTransformFeedbackEXT"] = Napi::Function::New(env, rawCmdEndTransformFeedbackEXT);
#endif
#ifdef VK_EXT_transform_feedback
    exports["vkCmdBeginQueryIndexedEXT"] = Napi::Function::New(env, rawCmdBeginQueryIndexedEXT);
#endif
#ifdef VK_EXT_transform_feedback
    exports["vkCmdEndQueryIndexedEXT"] = Napi::Function::New(env, rawCmdEndQueryIndexedEXT);
#endif
#ifdef VK_EXT_transform_feedback
    exports["vkCmdDrawIndirectByteCountEXT"] = Napi::Function::New(env, rawCmdDrawIndirectByteCountEXT);
#endif
#ifdef VK_NV_scissor_exclusive
    exports["vkCmdSetExclusiveScissorNV"] = Napi::Function::New(env, rawCmdSetExclusiveScissorNV);
#endif
#ifdef VK_NV_shading_rate_image
    exports["vkCmdBindShadingRateImageNV"] = Napi::Function::New(env, rawCmdBindShadingRateImageNV);
#endif
#ifdef VK_NV_shading_rate_image
    exports["vkCmdSetViewportShadingRatePaletteNV"] = Napi::Function::New(env, rawCmdSetViewportShadingRatePaletteNV);
#endif
#ifdef VK_NV_shading_rate_image
    exports["vkCmdSetCoarseSampleOrderNV"] = Napi::Function::New(env, rawCmdSetCoarseSampleOrderNV);
#endif
#ifdef VK_NV_mesh_shader
    exports["vkCmdDrawMeshTasksNV"] = Napi::Function::New(env, rawCmdDrawMeshTasksNV);
#endif
#ifdef VK_NV_mesh_shader
    exports["vkCmdDrawMeshTasksIndirectNV"] = Napi::Function::New(env, rawCmdDrawMeshTasksIndirectNV);
#endif
#ifdef VK_NV_mesh_shader
    exports["vkCmdDrawMeshTasksIndirectCountNV"] = Napi::Function::New(env, rawCmdDrawMeshTasksIndirectCountNV);
#endif
#ifdef VK_EXT_mesh_shader
    exports["vkCmdDrawMeshTasksEXT"] = Napi::Function::New(env, rawCmdDrawMeshTasksEXT);
#endif
#ifdef VK_EXT_mesh_shader
    exports["vkCmdDrawMeshTasksIndirectEXT"] = Napi::Function::New(env, rawCmdDrawMeshTasksIndirectEXT);
#endif
#ifdef VK_EXT_mesh_shader
    exports["vkCmdDrawMeshTasksIndirectCountEXT"] = Napi::Function::New(env, rawCmdDrawMeshTasksIndirectCountEXT);
#endif
#ifdef VK_NV_ray_tracing
    exports["vkCompileDeferredNV"] = Napi::Function::New(env, rawCompileDeferredNV);
#endif
#ifdef VK_NV_ray_tracing
    exports["vkCreateAccelerationStructureNV"] = Napi::Function::New(env, rawCreateAccelerationStructureNV);
#endif
#ifdef VK_HUAWEI_invocation_mask
    exports["vkCmdBindInvocationMaskHUAWEI"] = Napi::Function::New(env, rawCmdBindInvocationMaskHUAWEI);
#endif
#ifdef VK_KHR_acceleration_structure
    exports["vkDestroyAccelerationStructureKHR"] = Napi::Function::New(env, rawDestroyAccelerationStructureKHR);
#endif
#ifdef VK_NV_ray_tracing
    exports["vkDestroyAccelerationStructureNV"] = Napi::Function::New(env, rawDestroyAccelerationStructureNV);
#endif
#ifdef VK_NV_ray_tracing
    exports["vkGetAccelerationStructureMemoryRequirementsNV"] = Napi::Function::New(env, rawGetAccelerationStructureMemoryRequirementsNV);
#endif
#ifdef VK_NV_ray_tracing
    exports["vkBindAccelerationStructureMemoryNV"] = Napi::Function::New(env, rawBindAccelerationStructureMemoryNV);
#endif
#ifdef VK_NV_ray_tracing
    exports["vkCmdCopyAccelerationStructureNV"] = Napi::Function::New(env, rawCmdCopyAccelerationStructureNV);
#endif
#ifdef VK_KHR_acceleration_structure
    exports["vkCmdCopyAccelerationStructureKHR"] = Napi::Function::New(env, rawCmdCopyAccelerationStructureKHR);
#endif
#ifdef VK_KHR_acceleration_structure
    exports["vkCopyAccelerationStructureKHR"] = Napi::Function::New(env, rawCopyAccelerationStructureKHR);
#endif
#ifdef VK_KHR_acceleration_structure
    exports["vkCmdCopyAccelerationStructureToMemoryKHR"] = Napi::Function::New(env, rawCmdCopyAccelerationStructureToMemoryKHR);
#endif
#ifdef VK_KHR_acceleration_structure
    exports["vkCopyAccelerationStructureToMemoryKHR"] = Napi::Function::New(env, rawCopyAccelerationStructureToMemoryKHR);
#endif
#ifdef VK_KHR_acceleration_structure
    exports["vkCmdCopyMemoryToAccelerationStructureKHR"] = Napi::Function::New(env, rawCmdCopyMemoryToAccelerationStructureKHR);
#endif
#ifdef VK_KHR_acceleration_structure
    exports["vkCopyMemoryToAccelerationStructureKHR"] = Napi::Function::New(env, rawCopyMemoryToAccelerationStructureKHR);
#endif
#ifdef VK_KHR_acceleration_structure
    exports["vkCmdWriteAccelerationStructuresPropertiesKHR"] = Napi::Function::New(env, rawCmdWriteAccelerationStructuresPropertiesKHR);
#endif
#ifdef VK_NV_ray_tracing
    exports["vkCmdWriteAccelerationStructuresPropertiesNV"] = Napi::Function::New(env, rawCmdWriteAccelerationStructuresPropertiesNV);
#endif
#ifdef VK_NV_ray_tracing
    exports["vkCmdBuildAccelerationStructureNV"] = Napi::Function::New(env, rawCmdBuildAccelerationStructureNV);
#endif
#ifdef VK_KHR_acceleration_structure
    exports["vkWriteAccelerationStructuresPropertiesKHR"] = Napi::Function::New(env, rawWriteAccelerationStructuresPropertiesKHR);
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["vkCmdTraceRaysKHR"] = Napi::Function::New(env, rawCmdTraceRaysKHR);
#endif
#ifdef VK_NV_ray_tracing
    exports["vkCmdTraceRaysNV"] = Napi::Function::New(env, rawCmdTraceRaysNV);
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["vkGetRayTracingShaderGroupHandlesKHR"] = Napi::Function::New(env, rawGetRayTracingShaderGroupHandlesKHR);
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["vkGetRayTracingCaptureReplayShaderGroupHandlesKHR"] = Napi::Function::New(env, rawGetRayTracingCaptureReplayShaderGroupHandlesKHR);
#endif
#ifdef VK_NV_ray_tracing
    exports["vkGetAccelerationStructureHandleNV"] = Napi::Function::New(env, rawGetAccelerationStructureHandleNV);
#endif
#ifdef VK_NV_ray_tracing
    exports["vkCreateRayTracingPipelinesNV"] = Napi::Function::New(env, rawCreateRayTracingPipelinesNV);
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["vkCreateRayTracingPipelinesKHR"] = Napi::Function::New(env, rawCreateRayTracingPipelinesKHR);
#endif
#ifdef VK_NV_cooperative_matrix
    exports["vkGetPhysicalDeviceCooperativeMatrixPropertiesNV"] = Napi::Function::New(env, rawGetPhysicalDeviceCooperativeMatrixPropertiesNV);
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["vkCmdTraceRaysIndirectKHR"] = Napi::Function::New(env, rawCmdTraceRaysIndirectKHR);
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
    exports["vkCmdTraceRaysIndirect2KHR"] = Napi::Function::New(env, rawCmdTraceRaysIndirect2KHR);
#endif
#ifdef VK_KHR_acceleration_structure
    exports["vkGetDeviceAccelerationStructureCompatibilityKHR"] = Napi::Function::New(env, rawGetDeviceAccelerationStructureCompatibilityKHR);
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["vkGetRayTracingShaderGroupStackSizeKHR"] = Napi::Function::New(env, rawGetRayTracingShaderGroupStackSizeKHR);
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    exports["vkCmdSetRayTracingPipelineStackSizeKHR"] = Napi::Function::New(env, rawCmdSetRayTracingPipelineStackSizeKHR);
#endif
#ifdef VK_NVX_image_view_handle
    exports["vkGetImageViewHandleNVX"] = Napi::Function::New(env, rawGetImageViewHandleNVX);
#endif
#ifdef VK_NVX_image_view_handle
    exports["vkGetImageViewAddressNVX"] = Napi::Function::New(env, rawGetImageViewAddressNVX);
#endif
#ifdef VK_EXT_full_screen_exclusive
    exports["vkGetPhysicalDeviceSurfacePresentModes2EXT"] = Napi::Function::New(env, rawGetPhysicalDeviceSurfacePresentModes2EXT);
#endif
#ifdef VK_EXT_full_screen_exclusive
    exports["vkGetDeviceGroupSurfacePresentModes2EXT"] = Napi::Function::New(env, rawGetDeviceGroupSurfacePresentModes2EXT);
#endif
#ifdef VK_EXT_full_screen_exclusive
    exports["vkAcquireFullScreenExclusiveModeEXT"] = Napi::Function::New(env, rawAcquireFullScreenExclusiveModeEXT);
#endif
#ifdef VK_EXT_full_screen_exclusive
    exports["vkReleaseFullScreenExclusiveModeEXT"] = Napi::Function::New(env, rawReleaseFullScreenExclusiveModeEXT);
#endif
#ifdef VK_KHR_performance_query
    exports["vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR"] = Napi::Function::New(env, rawEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR);
#endif
#ifdef VK_KHR_performance_query
    exports["vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR"] = Napi::Function::New(env, rawGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR);
#endif
#ifdef VK_KHR_performance_query
    exports["vkAcquireProfilingLockKHR"] = Napi::Function::New(env, rawAcquireProfilingLockKHR);
#endif
#ifdef VK_KHR_performance_query
    exports["vkReleaseProfilingLockKHR"] = Napi::Function::New(env, rawReleaseProfilingLockKHR);
#endif
#ifdef VK_EXT_image_drm_format_modifier
    exports["vkGetImageDrmFormatModifierPropertiesEXT"] = Napi::Function::New(env, rawGetImageDrmFormatModifierPropertiesEXT);
#endif
    exports["vkGetBufferOpaqueCaptureAddress"] = Napi::Function::New(env, rawGetBufferOpaqueCaptureAddress);
    exports["vkGetBufferDeviceAddress"] = Napi::Function::New(env, rawGetBufferDeviceAddress);
#ifdef VK_EXT_headless_surface
    exports["vkCreateHeadlessSurfaceEXT"] = Napi::Function::New(env, rawCreateHeadlessSurfaceEXT);
#endif
#ifdef VK_NV_coverage_reduction_mode
    exports["vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV"] = Napi::Function::New(env, rawGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV);
#endif
#ifdef VK_INTEL_performance_query
    exports["vkInitializePerformanceApiINTEL"] = Napi::Function::New(env, rawInitializePerformanceApiINTEL);
#endif
#ifdef VK_INTEL_performance_query
    exports["vkUninitializePerformanceApiINTEL"] = Napi::Function::New(env, rawUninitializePerformanceApiINTEL);
#endif
#ifdef VK_INTEL_performance_query
    exports["vkCmdSetPerformanceMarkerINTEL"] = Napi::Function::New(env, rawCmdSetPerformanceMarkerINTEL);
#endif
#ifdef VK_INTEL_performance_query
    exports["vkCmdSetPerformanceStreamMarkerINTEL"] = Napi::Function::New(env, rawCmdSetPerformanceStreamMarkerINTEL);
#endif
#ifdef VK_INTEL_performance_query
    exports["vkCmdSetPerformanceOverrideINTEL"] = Napi::Function::New(env, rawCmdSetPerformanceOverrideINTEL);
#endif
#ifdef VK_INTEL_performance_query
    exports["vkAcquirePerformanceConfigurationINTEL"] = Napi::Function::New(env, rawAcquirePerformanceConfigurationINTEL);
#endif
#ifdef VK_INTEL_performance_query
    exports["vkReleasePerformanceConfigurationINTEL"] = Napi::Function::New(env, rawReleasePerformanceConfigurationINTEL);
#endif
#ifdef VK_INTEL_performance_query
    exports["vkQueueSetPerformanceConfigurationINTEL"] = Napi::Function::New(env, rawQueueSetPerformanceConfigurationINTEL);
#endif
#ifdef VK_INTEL_performance_query
    exports["vkGetPerformanceParameterINTEL"] = Napi::Function::New(env, rawGetPerformanceParameterINTEL);
#endif
    exports["vkGetDeviceMemoryOpaqueCaptureAddress"] = Napi::Function::New(env, rawGetDeviceMemoryOpaqueCaptureAddress);
#ifdef VK_KHR_pipeline_executable_properties
    exports["vkGetPipelineExecutablePropertiesKHR"] = Napi::Function::New(env, rawGetPipelineExecutablePropertiesKHR);
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["vkGetPipelineExecutableStatisticsKHR"] = Napi::Function::New(env, rawGetPipelineExecutableStatisticsKHR);
#endif
#ifdef VK_KHR_pipeline_executable_properties
    exports["vkGetPipelineExecutableInternalRepresentationsKHR"] = Napi::Function::New(env, rawGetPipelineExecutableInternalRepresentationsKHR);
#endif
#ifdef VK_EXT_line_rasterization
    exports["vkCmdSetLineStippleEXT"] = Napi::Function::New(env, rawCmdSetLineStippleEXT);
#endif
    exports["vkGetPhysicalDeviceToolProperties"] = Napi::Function::New(env, rawGetPhysicalDeviceToolProperties);
#ifdef VK_KHR_acceleration_structure
    exports["vkCreateAccelerationStructureKHR"] = Napi::Function::New(env, rawCreateAccelerationStructureKHR);
#endif
#ifdef VK_KHR_acceleration_structure
    exports["vkCmdBuildAccelerationStructuresKHR"] = Napi::Function::New(env, rawCmdBuildAccelerationStructuresKHR);
#endif
#ifdef VK_KHR_acceleration_structure
    exports["vkCmdBuildAccelerationStructuresIndirectKHR"] = Napi::Function::New(env, rawCmdBuildAccelerationStructuresIndirectKHR);
#endif
#ifdef VK_KHR_acceleration_structure
    exports["vkBuildAccelerationStructuresKHR"] = Napi::Function::New(env, rawBuildAccelerationStructuresKHR);
#endif
#ifdef VK_KHR_acceleration_structure
    exports["vkGetAccelerationStructureDeviceAddressKHR"] = Napi::Function::New(env, rawGetAccelerationStructureDeviceAddressKHR);
#endif
#ifdef VK_KHR_deferred_host_operations
    exports["vkCreateDeferredOperationKHR"] = Napi::Function::New(env, rawCreateDeferredOperationKHR);
#endif
#ifdef VK_KHR_deferred_host_operations
    exports["vkDestroyDeferredOperationKHR"] = Napi::Function::New(env, rawDestroyDeferredOperationKHR);
#endif
#ifdef VK_KHR_deferred_host_operations
    exports["vkGetDeferredOperationMaxConcurrencyKHR"] = Napi::Function::New(env, rawGetDeferredOperationMaxConcurrencyKHR);
#endif
#ifdef VK_KHR_deferred_host_operations
    exports["vkGetDeferredOperationResultKHR"] = Napi::Function::New(env, rawGetDeferredOperationResultKHR);
#endif
#ifdef VK_KHR_deferred_host_operations
    exports["vkDeferredOperationJoinKHR"] = Napi::Function::New(env, rawDeferredOperationJoinKHR);
#endif
    exports["vkCmdSetCullMode"] = Napi::Function::New(env, rawCmdSetCullMode);
    exports["vkCmdSetFrontFace"] = Napi::Function::New(env, rawCmdSetFrontFace);
    exports["vkCmdSetPrimitiveTopology"] = Napi::Function::New(env, rawCmdSetPrimitiveTopology);
    exports["vkCmdSetViewportWithCount"] = Napi::Function::New(env, rawCmdSetViewportWithCount);
    exports["vkCmdSetScissorWithCount"] = Napi::Function::New(env, rawCmdSetScissorWithCount);
    exports["vkCmdBindVertexBuffers2"] = Napi::Function::New(env, rawCmdBindVertexBuffers2);
    exports["vkCmdSetDepthTestEnable"] = Napi::Function::New(env, rawCmdSetDepthTestEnable);
    exports["vkCmdSetDepthWriteEnable"] = Napi::Function::New(env, rawCmdSetDepthWriteEnable);
    exports["vkCmdSetDepthCompareOp"] = Napi::Function::New(env, rawCmdSetDepthCompareOp);
    exports["vkCmdSetDepthBoundsTestEnable"] = Napi::Function::New(env, rawCmdSetDepthBoundsTestEnable);
    exports["vkCmdSetStencilTestEnable"] = Napi::Function::New(env, rawCmdSetStencilTestEnable);
    exports["vkCmdSetStencilOp"] = Napi::Function::New(env, rawCmdSetStencilOp);
#ifdef VK_EXT_extended_dynamic_state2
    exports["vkCmdSetPatchControlPointsEXT"] = Napi::Function::New(env, rawCmdSetPatchControlPointsEXT);
#endif
    exports["vkCmdSetRasterizerDiscardEnable"] = Napi::Function::New(env, rawCmdSetRasterizerDiscardEnable);
    exports["vkCmdSetDepthBiasEnable"] = Napi::Function::New(env, rawCmdSetDepthBiasEnable);
#ifdef VK_EXT_extended_dynamic_state2
    exports["vkCmdSetLogicOpEXT"] = Napi::Function::New(env, rawCmdSetLogicOpEXT);
#endif
    exports["vkCmdSetPrimitiveRestartEnable"] = Napi::Function::New(env, rawCmdSetPrimitiveRestartEnable);
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetTessellationDomainOriginEXT"] = Napi::Function::New(env, rawCmdSetTessellationDomainOriginEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetDepthClampEnableEXT"] = Napi::Function::New(env, rawCmdSetDepthClampEnableEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetPolygonModeEXT"] = Napi::Function::New(env, rawCmdSetPolygonModeEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetRasterizationSamplesEXT"] = Napi::Function::New(env, rawCmdSetRasterizationSamplesEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetSampleMaskEXT"] = Napi::Function::New(env, rawCmdSetSampleMaskEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetAlphaToCoverageEnableEXT"] = Napi::Function::New(env, rawCmdSetAlphaToCoverageEnableEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetAlphaToOneEnableEXT"] = Napi::Function::New(env, rawCmdSetAlphaToOneEnableEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetLogicOpEnableEXT"] = Napi::Function::New(env, rawCmdSetLogicOpEnableEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetColorBlendEnableEXT"] = Napi::Function::New(env, rawCmdSetColorBlendEnableEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetColorBlendEquationEXT"] = Napi::Function::New(env, rawCmdSetColorBlendEquationEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetColorWriteMaskEXT"] = Napi::Function::New(env, rawCmdSetColorWriteMaskEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetRasterizationStreamEXT"] = Napi::Function::New(env, rawCmdSetRasterizationStreamEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetConservativeRasterizationModeEXT"] = Napi::Function::New(env, rawCmdSetConservativeRasterizationModeEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetExtraPrimitiveOverestimationSizeEXT"] = Napi::Function::New(env, rawCmdSetExtraPrimitiveOverestimationSizeEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetDepthClipEnableEXT"] = Napi::Function::New(env, rawCmdSetDepthClipEnableEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetSampleLocationsEnableEXT"] = Napi::Function::New(env, rawCmdSetSampleLocationsEnableEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetColorBlendAdvancedEXT"] = Napi::Function::New(env, rawCmdSetColorBlendAdvancedEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetProvokingVertexModeEXT"] = Napi::Function::New(env, rawCmdSetProvokingVertexModeEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetLineRasterizationModeEXT"] = Napi::Function::New(env, rawCmdSetLineRasterizationModeEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetLineStippleEnableEXT"] = Napi::Function::New(env, rawCmdSetLineStippleEnableEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetDepthClipNegativeOneToOneEXT"] = Napi::Function::New(env, rawCmdSetDepthClipNegativeOneToOneEXT);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetViewportWScalingEnableNV"] = Napi::Function::New(env, rawCmdSetViewportWScalingEnableNV);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetViewportSwizzleNV"] = Napi::Function::New(env, rawCmdSetViewportSwizzleNV);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetCoverageToColorEnableNV"] = Napi::Function::New(env, rawCmdSetCoverageToColorEnableNV);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetCoverageToColorLocationNV"] = Napi::Function::New(env, rawCmdSetCoverageToColorLocationNV);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetCoverageModulationModeNV"] = Napi::Function::New(env, rawCmdSetCoverageModulationModeNV);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetCoverageModulationTableEnableNV"] = Napi::Function::New(env, rawCmdSetCoverageModulationTableEnableNV);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetCoverageModulationTableNV"] = Napi::Function::New(env, rawCmdSetCoverageModulationTableNV);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetShadingRateImageEnableNV"] = Napi::Function::New(env, rawCmdSetShadingRateImageEnableNV);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetCoverageReductionModeNV"] = Napi::Function::New(env, rawCmdSetCoverageReductionModeNV);
#endif
#ifdef VK_EXT_extended_dynamic_state3
    exports["vkCmdSetRepresentativeFragmentTestEnableNV"] = Napi::Function::New(env, rawCmdSetRepresentativeFragmentTestEnableNV);
#endif
    exports["vkCreatePrivateDataSlot"] = Napi::Function::New(env, rawCreatePrivateDataSlot);
    exports["vkDestroyPrivateDataSlot"] = Napi::Function::New(env, rawDestroyPrivateDataSlot);
    exports["vkSetPrivateData"] = Napi::Function::New(env, rawSetPrivateData);
    exports["vkGetPrivateData"] = Napi::Function::New(env, rawGetPrivateData);
    exports["vkCmdCopyBuffer2"] = Napi::Function::New(env, rawCmdCopyBuffer2);
    exports["vkCmdCopyImage2"] = Napi::Function::New(env, rawCmdCopyImage2);
    exports["vkCmdBlitImage2"] = Napi::Function::New(env, rawCmdBlitImage2);
    exports["vkCmdCopyBufferToImage2"] = Napi::Function::New(env, rawCmdCopyBufferToImage2);
    exports["vkCmdCopyImageToBuffer2"] = Napi::Function::New(env, rawCmdCopyImageToBuffer2);
    exports["vkCmdResolveImage2"] = Napi::Function::New(env, rawCmdResolveImage2);
#ifdef VK_KHR_fragment_shading_rate
    exports["vkCmdSetFragmentShadingRateKHR"] = Napi::Function::New(env, rawCmdSetFragmentShadingRateKHR);
#endif
#ifdef VK_KHR_fragment_shading_rate
    exports["vkGetPhysicalDeviceFragmentShadingRatesKHR"] = Napi::Function::New(env, rawGetPhysicalDeviceFragmentShadingRatesKHR);
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    exports["vkCmdSetFragmentShadingRateEnumNV"] = Napi::Function::New(env, rawCmdSetFragmentShadingRateEnumNV);
#endif
#ifdef VK_KHR_acceleration_structure
    exports["vkGetAccelerationStructureBuildSizesKHR"] = Napi::Function::New(env, rawGetAccelerationStructureBuildSizesKHR);
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
    exports["vkCmdSetVertexInputEXT"] = Napi::Function::New(env, rawCmdSetVertexInputEXT);
#endif
#ifdef VK_EXT_color_write_enable
    exports["vkCmdSetColorWriteEnableEXT"] = Napi::Function::New(env, rawCmdSetColorWriteEnableEXT);
#endif
    exports["vkCmdSetEvent2"] = Napi::Function::New(env, rawCmdSetEvent2);
    exports["vkCmdResetEvent2"] = Napi::Function::New(env, rawCmdResetEvent2);
    exports["vkCmdWaitEvents2"] = Napi::Function::New(env, rawCmdWaitEvents2);
    exports["vkCmdPipelineBarrier2"] = Napi::Function::New(env, rawCmdPipelineBarrier2);
    exports["vkQueueSubmit2"] = Napi::Function::New(env, rawQueueSubmit2);
    exports["vkCmdWriteTimestamp2"] = Napi::Function::New(env, rawCmdWriteTimestamp2);
#ifdef VK_KHR_synchronization2
    exports["vkCmdWriteBufferMarker2AMD"] = Napi::Function::New(env, rawCmdWriteBufferMarker2AMD);
#endif
#ifdef VK_KHR_synchronization2
    exports["vkGetQueueCheckpointData2NV"] = Napi::Function::New(env, rawGetQueueCheckpointData2NV);
#endif
#ifdef VK_KHR_video_queue
    exports["vkGetPhysicalDeviceVideoCapabilitiesKHR"] = Napi::Function::New(env, rawGetPhysicalDeviceVideoCapabilitiesKHR);
#endif
#ifdef VK_KHR_video_queue
    exports["vkGetPhysicalDeviceVideoFormatPropertiesKHR"] = Napi::Function::New(env, rawGetPhysicalDeviceVideoFormatPropertiesKHR);
#endif
#ifdef VK_KHR_video_queue
    exports["vkCreateVideoSessionKHR"] = Napi::Function::New(env, rawCreateVideoSessionKHR);
#endif
#ifdef VK_KHR_video_queue
    exports["vkDestroyVideoSessionKHR"] = Napi::Function::New(env, rawDestroyVideoSessionKHR);
#endif
#ifdef VK_KHR_video_queue
    exports["vkCreateVideoSessionParametersKHR"] = Napi::Function::New(env, rawCreateVideoSessionParametersKHR);
#endif
#ifdef VK_KHR_video_queue
    exports["vkUpdateVideoSessionParametersKHR"] = Napi::Function::New(env, rawUpdateVideoSessionParametersKHR);
#endif
#ifdef VK_KHR_video_queue
    exports["vkDestroyVideoSessionParametersKHR"] = Napi::Function::New(env, rawDestroyVideoSessionParametersKHR);
#endif
#ifdef VK_KHR_video_queue
    exports["vkGetVideoSessionMemoryRequirementsKHR"] = Napi::Function::New(env, rawGetVideoSessionMemoryRequirementsKHR);
#endif
#ifdef VK_KHR_video_queue
    exports["vkBindVideoSessionMemoryKHR"] = Napi::Function::New(env, rawBindVideoSessionMemoryKHR);
#endif
#ifdef VK_KHR_video_decode_queue
    exports["vkCmdDecodeVideoKHR"] = Napi::Function::New(env, rawCmdDecodeVideoKHR);
#endif
#ifdef VK_KHR_video_queue
    exports["vkCmdBeginVideoCodingKHR"] = Napi::Function::New(env, rawCmdBeginVideoCodingKHR);
#endif
#ifdef VK_KHR_video_queue
    exports["vkCmdControlVideoCodingKHR"] = Napi::Function::New(env, rawCmdControlVideoCodingKHR);
#endif
#ifdef VK_KHR_video_queue
    exports["vkCmdEndVideoCodingKHR"] = Napi::Function::New(env, rawCmdEndVideoCodingKHR);
#endif
#ifdef VK_KHR_video_encode_queue
    exports["vkCmdEncodeVideoKHR"] = Napi::Function::New(env, rawCmdEncodeVideoKHR);
#endif
#ifdef VK_NV_memory_decompression
    exports["vkCmdDecompressMemoryNV"] = Napi::Function::New(env, rawCmdDecompressMemoryNV);
#endif
#ifdef VK_NV_memory_decompression
    exports["vkCmdDecompressMemoryIndirectCountNV"] = Napi::Function::New(env, rawCmdDecompressMemoryIndirectCountNV);
#endif
#ifdef VK_NVX_binary_import
    exports["vkCreateCuModuleNVX"] = Napi::Function::New(env, rawCreateCuModuleNVX);
#endif
#ifdef VK_NVX_binary_import
    exports["vkCreateCuFunctionNVX"] = Napi::Function::New(env, rawCreateCuFunctionNVX);
#endif
#ifdef VK_NVX_binary_import
    exports["vkDestroyCuModuleNVX"] = Napi::Function::New(env, rawDestroyCuModuleNVX);
#endif
#ifdef VK_NVX_binary_import
    exports["vkDestroyCuFunctionNVX"] = Napi::Function::New(env, rawDestroyCuFunctionNVX);
#endif
#ifdef VK_NVX_binary_import
    exports["vkCmdCuLaunchKernelNVX"] = Napi::Function::New(env, rawCmdCuLaunchKernelNVX);
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["vkGetDescriptorSetLayoutSizeEXT"] = Napi::Function::New(env, rawGetDescriptorSetLayoutSizeEXT);
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["vkGetDescriptorSetLayoutBindingOffsetEXT"] = Napi::Function::New(env, rawGetDescriptorSetLayoutBindingOffsetEXT);
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["vkGetDescriptorEXT"] = Napi::Function::New(env, rawGetDescriptorEXT);
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["vkCmdBindDescriptorBuffersEXT"] = Napi::Function::New(env, rawCmdBindDescriptorBuffersEXT);
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["vkCmdSetDescriptorBufferOffsetsEXT"] = Napi::Function::New(env, rawCmdSetDescriptorBufferOffsetsEXT);
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["vkCmdBindDescriptorBufferEmbeddedSamplersEXT"] = Napi::Function::New(env, rawCmdBindDescriptorBufferEmbeddedSamplersEXT);
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["vkGetBufferOpaqueCaptureDescriptorDataEXT"] = Napi::Function::New(env, rawGetBufferOpaqueCaptureDescriptorDataEXT);
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["vkGetImageOpaqueCaptureDescriptorDataEXT"] = Napi::Function::New(env, rawGetImageOpaqueCaptureDescriptorDataEXT);
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["vkGetImageViewOpaqueCaptureDescriptorDataEXT"] = Napi::Function::New(env, rawGetImageViewOpaqueCaptureDescriptorDataEXT);
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["vkGetSamplerOpaqueCaptureDescriptorDataEXT"] = Napi::Function::New(env, rawGetSamplerOpaqueCaptureDescriptorDataEXT);
#endif
#ifdef VK_EXT_descriptor_buffer
    exports["vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT"] = Napi::Function::New(env, rawGetAccelerationStructureOpaqueCaptureDescriptorDataEXT);
#endif
#ifdef VK_EXT_pageable_device_local_memory
    exports["vkSetDeviceMemoryPriorityEXT"] = Napi::Function::New(env, rawSetDeviceMemoryPriorityEXT);
#endif
#ifdef VK_EXT_acquire_drm_display
    exports["vkAcquireDrmDisplayEXT"] = Napi::Function::New(env, rawAcquireDrmDisplayEXT);
#endif
#ifdef VK_EXT_acquire_drm_display
    exports["vkGetDrmDisplayEXT"] = Napi::Function::New(env, rawGetDrmDisplayEXT);
#endif
#ifdef VK_KHR_present_wait
    exports["vkWaitForPresentKHR"] = Napi::Function::New(env, rawWaitForPresentKHR);
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["vkCreateBufferCollectionFUCHSIA"] = Napi::Function::New(env, rawCreateBufferCollectionFUCHSIA);
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["vkSetBufferCollectionBufferConstraintsFUCHSIA"] = Napi::Function::New(env, rawSetBufferCollectionBufferConstraintsFUCHSIA);
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["vkSetBufferCollectionImageConstraintsFUCHSIA"] = Napi::Function::New(env, rawSetBufferCollectionImageConstraintsFUCHSIA);
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["vkDestroyBufferCollectionFUCHSIA"] = Napi::Function::New(env, rawDestroyBufferCollectionFUCHSIA);
#endif
#ifdef VK_FUCHSIA_buffer_collection
    exports["vkGetBufferCollectionPropertiesFUCHSIA"] = Napi::Function::New(env, rawGetBufferCollectionPropertiesFUCHSIA);
#endif
    exports["vkCmdBeginRendering"] = Napi::Function::New(env, rawCmdBeginRendering);
    exports["vkCmdEndRendering"] = Napi::Function::New(env, rawCmdEndRendering);
#ifdef VK_VALVE_descriptor_set_host_mapping
    exports["vkGetDescriptorSetLayoutHostMappingInfoVALVE"] = Napi::Function::New(env, rawGetDescriptorSetLayoutHostMappingInfoVALVE);
#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
    exports["vkGetDescriptorSetHostMappingVALVE"] = Napi::Function::New(env, rawGetDescriptorSetHostMappingVALVE);
#endif
#ifdef VK_EXT_opacity_micromap
    exports["vkCreateMicromapEXT"] = Napi::Function::New(env, rawCreateMicromapEXT);
#endif
#ifdef VK_EXT_opacity_micromap
    exports["vkCmdBuildMicromapsEXT"] = Napi::Function::New(env, rawCmdBuildMicromapsEXT);
#endif
#ifdef VK_EXT_opacity_micromap
    exports["vkBuildMicromapsEXT"] = Napi::Function::New(env, rawBuildMicromapsEXT);
#endif
#ifdef VK_EXT_opacity_micromap
    exports["vkDestroyMicromapEXT"] = Napi::Function::New(env, rawDestroyMicromapEXT);
#endif
#ifdef VK_EXT_opacity_micromap
    exports["vkCmdCopyMicromapEXT"] = Napi::Function::New(env, rawCmdCopyMicromapEXT);
#endif
#ifdef VK_EXT_opacity_micromap
    exports["vkCopyMicromapEXT"] = Napi::Function::New(env, rawCopyMicromapEXT);
#endif
#ifdef VK_EXT_opacity_micromap
    exports["vkCmdCopyMicromapToMemoryEXT"] = Napi::Function::New(env, rawCmdCopyMicromapToMemoryEXT);
#endif
#ifdef VK_EXT_opacity_micromap
    exports["vkCopyMicromapToMemoryEXT"] = Napi::Function::New(env, rawCopyMicromapToMemoryEXT);
#endif
#ifdef VK_EXT_opacity_micromap
    exports["vkCmdCopyMemoryToMicromapEXT"] = Napi::Function::New(env, rawCmdCopyMemoryToMicromapEXT);
#endif
#ifdef VK_EXT_opacity_micromap
    exports["vkCopyMemoryToMicromapEXT"] = Napi::Function::New(env, rawCopyMemoryToMicromapEXT);
#endif
#ifdef VK_EXT_opacity_micromap
    exports["vkCmdWriteMicromapsPropertiesEXT"] = Napi::Function::New(env, rawCmdWriteMicromapsPropertiesEXT);
#endif
#ifdef VK_EXT_opacity_micromap
    exports["vkWriteMicromapsPropertiesEXT"] = Napi::Function::New(env, rawWriteMicromapsPropertiesEXT);
#endif
#ifdef VK_EXT_opacity_micromap
    exports["vkGetDeviceMicromapCompatibilityEXT"] = Napi::Function::New(env, rawGetDeviceMicromapCompatibilityEXT);
#endif
#ifdef VK_EXT_opacity_micromap
    exports["vkGetMicromapBuildSizesEXT"] = Napi::Function::New(env, rawGetMicromapBuildSizesEXT);
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["vkGetShaderModuleIdentifierEXT"] = Napi::Function::New(env, rawGetShaderModuleIdentifierEXT);
#endif
#ifdef VK_EXT_shader_module_identifier
    exports["vkGetShaderModuleCreateInfoIdentifierEXT"] = Napi::Function::New(env, rawGetShaderModuleCreateInfoIdentifierEXT);
#endif
#ifdef VK_EXT_image_compression_control
    exports["vkGetImageSubresourceLayout2EXT"] = Napi::Function::New(env, rawGetImageSubresourceLayout2EXT);
#endif
#ifdef VK_EXT_pipeline_properties
    exports["vkGetPipelinePropertiesEXT"] = Napi::Function::New(env, rawGetPipelinePropertiesEXT);
#endif
#ifdef VK_EXT_metal_objects
    exports["vkExportMetalObjectsEXT"] = Napi::Function::New(env, rawExportMetalObjectsEXT);
#endif
#ifdef VK_QCOM_tile_properties
    exports["vkGetFramebufferTilePropertiesQCOM"] = Napi::Function::New(env, rawGetFramebufferTilePropertiesQCOM);
#endif
#ifdef VK_QCOM_tile_properties
    exports["vkGetDynamicRenderingTilePropertiesQCOM"] = Napi::Function::New(env, rawGetDynamicRenderingTilePropertiesQCOM);
#endif
#ifdef VK_NV_optical_flow
    exports["vkGetPhysicalDeviceOpticalFlowImageFormatsNV"] = Napi::Function::New(env, rawGetPhysicalDeviceOpticalFlowImageFormatsNV);
#endif
#ifdef VK_NV_optical_flow
    exports["vkCreateOpticalFlowSessionNV"] = Napi::Function::New(env, rawCreateOpticalFlowSessionNV);
#endif
#ifdef VK_NV_optical_flow
    exports["vkDestroyOpticalFlowSessionNV"] = Napi::Function::New(env, rawDestroyOpticalFlowSessionNV);
#endif
#ifdef VK_NV_optical_flow
    exports["vkBindOpticalFlowSessionImageNV"] = Napi::Function::New(env, rawBindOpticalFlowSessionImageNV);
#endif
#ifdef VK_NV_optical_flow
    exports["vkCmdOpticalFlowExecuteNV"] = Napi::Function::New(env, rawCmdOpticalFlowExecuteNV);
#endif
#ifdef VK_EXT_device_fault
    exports["vkGetDeviceFaultInfoEXT"] = Napi::Function::New(env, rawGetDeviceFaultInfoEXT);
#endif

    // TODO: Unified Syntax

#ifdef ENABLE_GLFW_SUPPORT
    // Context functions
    exports.Set("glfwMakeContextCurrent", Napi::Function::New(env, __glfwMakeContextCurrent));
    exports.Set("glfwGetCurrentContext", Napi::Function::New(env, __glfwGetCurrentContext));
    exports.Set("glfwSwapInterval", Napi::Function::New(env, __glfwSwapInterval));
    exports.Set("glfwExtensionSupported", Napi::Function::New(env, __glfwExtensionSupported));

    // Initialization, version and error functions
    exports.Set("glfwInit", Napi::Function::New(env, __glfwInit));
    exports.Set("glfwTerminate", Napi::Function::New(env, __glfwTerminate));
    exports.Set("glfwInitHint", Napi::Function::New(env, __glfwInitHint));
    exports.Set("glfwGetVersion", Napi::Function::New(env, __glfwGetVersion));
    exports.Set("glfwGetVersionString", Napi::Function::New(env, __glfwGetVersionString));
    exports.Set("glfwGetError", Napi::Function::New(env, __glfwGetError));
    exports.Set("glfwSetErrorCallback", Napi::Function::New(env, __glfwSetErrorCallback));

    // Input functions
    exports.Set("glfwGetInputMode", Napi::Function::New(env, __glfwGetInputMode));
    exports.Set("glfwSetInputMode", Napi::Function::New(env, __glfwSetInputMode));
    exports.Set("glfwRawMouseMotionSupported", Napi::Function::New(env, __glfwRawMouseMotionSupported));
    exports.Set("glfwGetKeyName", Napi::Function::New(env, __glfwGetKeyName));
    exports.Set("glfwGetKeyScancode", Napi::Function::New(env, __glfwGetKeyScancode));
    exports.Set("glfwGetKey", Napi::Function::New(env, __glfwGetKey));
    exports.Set("glfwGetMouseButton", Napi::Function::New(env, __glfwGetMouseButton));
    exports.Set("glfwGetCursorPos", Napi::Function::New(env, __glfwGetCursorPos));
    exports.Set("glfwSetCursorPos", Napi::Function::New(env, __glfwSetCursorPos));
    exports.Set("glfwCreateCursor", Napi::Function::New(env, __glfwCreateCursor));
    exports.Set("glfwCreateStandardCursor", Napi::Function::New(env, __glfwCreateStandardCursor));
    exports.Set("glfwDestroyCursor", Napi::Function::New(env, __glfwDestroyCursor));
    exports.Set("glfwSetCursor", Napi::Function::New(env, __glfwSetCursor));
    exports.Set("glfwSetKeyCallback", Napi::Function::New(env, __glfwSetKeyCallback));
    exports.Set("glfwSetCharCallback", Napi::Function::New(env, __glfwSetCharCallback));
    exports.Set("glfwSetCharModsCallback", Napi::Function::New(env, __glfwSetCharModsCallback));
    exports.Set("glfwSetMouseButtonCallback", Napi::Function::New(env, __glfwSetMouseButtonCallback));
    exports.Set("glfwSetCursorPosCallback", Napi::Function::New(env, __glfwSetCursorPosCallback));
    exports.Set("glfwSetCursorEnterCallback", Napi::Function::New(env, __glfwSetCursorEnterCallback));
    exports.Set("glfwSetScrollCallback", Napi::Function::New(env, __glfwSetScrollCallback));
    exports.Set("glfwSetDropCallback", Napi::Function::New(env, __glfwSetDropCallback));
    exports.Set("glfwJoystickPresent", Napi::Function::New(env, __glfwJoystickPresent));
    exports.Set("glfwGetJoystickAxes", Napi::Function::New(env, __glfwGetJoystickAxes));
    exports.Set("glfwGetJoystickButtons", Napi::Function::New(env, __glfwGetJoystickButtons));
    exports.Set("glfwGetJoystickHats", Napi::Function::New(env, __glfwGetJoystickHats));
    exports.Set("glfwGetJoystickName", Napi::Function::New(env, __glfwGetJoystickName));
    exports.Set("glfwGetJoystickGUID", Napi::Function::New(env, __glfwGetJoystickGUID));
    exports.Set("glfwJoystickIsGamepad", Napi::Function::New(env, __glfwJoystickIsGamepad));
    exports.Set("glfwSetJoystickCallback", Napi::Function::New(env, __glfwSetJoystickCallback));
    exports.Set("glfwUpdateGamepadMappings", Napi::Function::New(env, __glfwUpdateGamepadMappings));
    exports.Set("glfwGetGamepadName", Napi::Function::New(env, __glfwGetGamepadName));
    exports.Set("glfwGetGamepadState", Napi::Function::New(env, __glfwGetGamepadState));
    exports.Set("glfwSetClipboardString", Napi::Function::New(env, __glfwSetClipboardString));
    exports.Set("glfwGetClipboardString", Napi::Function::New(env, __glfwGetClipboardString));
    exports.Set("glfwGetTime", Napi::Function::New(env, __glfwGetTime));
    exports.Set("glfwSetTime", Napi::Function::New(env, __glfwSetTime));
    exports.Set("glfwGetTimerValue", Napi::Function::New(env, __glfwGetTimerValue));
    exports.Set("glfwGetTimerFrequency", Napi::Function::New(env, __glfwGetTimerFrequency));

    // Monitor functions
    exports.Set("glfwGetMonitors", Napi::Function::New(env, __glfwGetMonitors));
    exports.Set("glfwGetPrimaryMonitor", Napi::Function::New(env, __glfwGetPrimaryMonitor));
    exports.Set("glfwGetMonitorPos", Napi::Function::New(env, __glfwGetMonitorPos));
    exports.Set("glfwGetMonitorWorkarea", Napi::Function::New(env, __glfwGetMonitorWorkarea));
    exports.Set("glfwGetMonitorPhysicalSize", Napi::Function::New(env, __glfwGetMonitorPhysicalSize));
    exports.Set("glfwGetMonitorContentScale", Napi::Function::New(env, __glfwGetMonitorContentScale));
    exports.Set("glfwGetMonitorName", Napi::Function::New(env, __glfwGetMonitorName));
    exports.Set("glfwSetMonitorCallback", Napi::Function::New(env, __glfwSetMonitorCallback));
    exports.Set("glfwGetVideoModes", Napi::Function::New(env, __glfwGetVideoModes));
    exports.Set("glfwGetVideoMode", Napi::Function::New(env, __glfwGetVideoMode));
    exports.Set("glfwSetGamma", Napi::Function::New(env, __glfwSetGamma));
    exports.Set("glfwGetGammaRamp", Napi::Function::New(env, __glfwGetGammaRamp));
    exports.Set("glfwSetGammaRamp", Napi::Function::New(env, __glfwSetGammaRamp));

    // Window functions
    exports.Set("glfwDefaultWindowHints", Napi::Function::New(env, __glfwDefaultWindowHints));
    exports.Set("glfwWindowHint", Napi::Function::New(env, __glfwWindowHint));
    exports.Set("glfwWindowHintString", Napi::Function::New(env, __glfwWindowHintString));
    exports.Set("glfwCreateWindow", Napi::Function::New(env, __glfwCreateWindow));
    exports.Set("glfwDestroyWindow", Napi::Function::New(env, __glfwDestroyWindow));
    exports.Set("glfwWindowShouldClose", Napi::Function::New(env, __glfwWindowShouldClose));
    exports.Set("glfwSetWindowShouldClose", Napi::Function::New(env, __glfwSetWindowShouldClose));
    exports.Set("glfwSetWindowTitle", Napi::Function::New(env, __glfwSetWindowTitle));
    exports.Set("glfwSetWindowIcon", Napi::Function::New(env, __glfwSetWindowIcon));
    exports.Set("glfwGetWindowPos", Napi::Function::New(env, __glfwGetWindowPos));
    exports.Set("glfwSetWindowPos", Napi::Function::New(env, __glfwSetWindowPos));
    exports.Set("glfwGetWindowSize", Napi::Function::New(env, __glfwGetWindowSize));
    exports.Set("glfwSetWindowSizeLimits", Napi::Function::New(env, __glfwSetWindowSizeLimits));
    exports.Set("glfwSetWindowAspectRatio", Napi::Function::New(env, __glfwSetWindowAspectRatio));
    exports.Set("glfwSetWindowSize", Napi::Function::New(env, __glfwSetWindowSize));
    exports.Set("glfwGetFramebufferSize", Napi::Function::New(env, __glfwGetFramebufferSize));
    exports.Set("glfwGetWindowFrameSize", Napi::Function::New(env, __glfwGetWindowFrameSize));
    exports.Set("glfwGetWindowContentScale", Napi::Function::New(env, __glfwGetWindowContentScale));
    exports.Set("glfwGetWindowOpacity", Napi::Function::New(env, __glfwGetWindowOpacity));
    exports.Set("glfwSetWindowOpacity", Napi::Function::New(env, __glfwSetWindowOpacity));
    exports.Set("glfwIconifyWindow", Napi::Function::New(env, __glfwIconifyWindow));
    exports.Set("glfwRestoreWindow", Napi::Function::New(env, __glfwRestoreWindow));
    exports.Set("glfwMaximizeWindow", Napi::Function::New(env, __glfwMaximizeWindow));
    exports.Set("glfwShowWindow", Napi::Function::New(env, __glfwShowWindow));
    exports.Set("glfwHideWindow", Napi::Function::New(env, __glfwHideWindow));
    exports.Set("glfwFocusWindow", Napi::Function::New(env, __glfwFocusWindow));
    exports.Set("glfwRequestWindowAttention", Napi::Function::New(env, __glfwRequestWindowAttention));
    exports.Set("glfwGetWindowMonitor", Napi::Function::New(env, __glfwGetWindowMonitor));
    exports.Set("glfwSetWindowMonitor", Napi::Function::New(env, __glfwSetWindowMonitor));
    exports.Set("glfwGetWindowAttrib", Napi::Function::New(env, __glfwGetWindowAttrib));
    exports.Set("glfwSetWindowAttrib", Napi::Function::New(env, __glfwSetWindowAttrib));
    exports.Set("glfwSetWindowPosCallback", Napi::Function::New(env, __glfwSetWindowPosCallback));
    exports.Set("glfwSetWindowSizeCallback", Napi::Function::New(env, __glfwSetWindowSizeCallback));
    exports.Set("glfwSetWindowCloseCallback", Napi::Function::New(env, __glfwSetWindowCloseCallback));
    exports.Set("glfwSetWindowRefreshCallback", Napi::Function::New(env, __glfwSetWindowRefreshCallback));
    exports.Set("glfwSetWindowFocusCallback", Napi::Function::New(env, __glfwSetWindowFocusCallback));
    exports.Set("glfwSetWindowIconifyCallback", Napi::Function::New(env, __glfwSetWindowIconifyCallback));
    exports.Set("glfwSetWindowMaximizeCallback", Napi::Function::New(env, __glfwSetWindowMaximizeCallback));
    exports.Set("glfwSetFramebufferSizeCallback", Napi::Function::New(env, __glfwSetFramebufferSizeCallback));
    exports.Set("glfwSetWindowContentScaleCallback", Napi::Function::New(env, __glfwSetWindowContentScaleCallback));
    exports.Set("glfwPollEvents", Napi::Function::New(env, __glfwPollEvents));
    exports.Set("glfwWaitEvents", Napi::Function::New(env, __glfwWaitEvents));
    exports.Set("glfwWaitEventsTimeout", Napi::Function::New(env, __glfwWaitEventsTimeout));
    exports.Set("glfwPostEmptyEvent", Napi::Function::New(env, __glfwPostEmptyEvent));
    exports.Set("glfwSwapBuffers", Napi::Function::New(env, __glfwSwapBuffers));

    // TODO: Unified Syntax
    exports["glfwCreateWindowSurface"] = Napi::Function::New(env, __glfwCreateWindowSurface);
    exports["glfwVulkanSupported"] = Napi::Function::New(env, __glfwVulkanSupported);
    exports["glfwGetRequiredInstanceExtensions"] = Napi::Function::New(env, __glfwGetRequiredInstanceExtensions);
    exports["glfwGetPhysicalDevicePresentationSupport"] = Napi::Function::New(env, __glfwGetPhysicalDevicePresentationSupport);
#endif

    // TODO: Unified Syntax
    exports["vkGetStructureSizeBySType"] = Napi::Function::New(env, rawGetStructureSizeBySType);
    exports["uint8" ] = Napi::Function::New(env, DebugUint8);
    exports["uint16"] = Napi::Function::New(env, DebugUint16);
    exports["uint32"] = Napi::Function::New(env, DebugUint32);
    exports["uint64"] = Napi::Function::New(env, DebugUint64);
    exports["float32"] = Napi::Function::New(env, DebugFloat32);
    exports["float64"] = Napi::Function::New(env, DebugFloat64);
    exports["nativeAddress"] = Napi::Function::New(env, GetAddressJS);
    exports["arrayBuffer"] = Napi::Function::New(env, WrapArrayBuffer);
    exports["buffer"] = Napi::Function::New(env, WrapBuffer);
    exports["string"] = Napi::Function::New(env, WrapString);
    exports["stringUtf16"] = Napi::Function::New(env, WrapStringUTF16);
    return exports;
}

NODE_API_MODULE(native, Init)
    